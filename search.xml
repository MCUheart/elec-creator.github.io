<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>总结基础知识点面(一) 单片机篇</title>
      <link href="/posts/a8c481ea.html"/>
      <url>/posts/a8c481ea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-预处理器-preprocessor"><a class="markdownIt-Anchor" href="#1-预处理器-preprocessor"></a> 1. 预处理器 (Preprocessor)</h1><h2 id="11-用预处理指令define-声明一个常数用以表明1年中有多少秒忽略闰年问题"><a class="markdownIt-Anchor" href="#11-用预处理指令define-声明一个常数用以表明1年中有多少秒忽略闰年问题"></a> 1.1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒(忽略闰年问题)</h2><p><code>#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</code></p><p>在这想看到几件事情：</p><ol><li><p>#define 语法的基本知识(例如：不能以分号结束，括号的使用，等等)</p></li><li><p>懂得预处理器将为你计算常数表达式的值，因此直接写出你如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。</p></li><li><p>意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。</p></li><li><p>如果你在你的表达式中用到UL(表示无符号长整型)，那么你有了一个好的起点。记住，第一印象很重要。</p></li></ol><h2 id="12-写一个标准宏min-这个宏输入两个参数并返回较小的一个"><a class="markdownIt-Anchor" href="#12-写一个标准宏min-这个宏输入两个参数并返回较小的一个"></a> 1.2. 写一个&quot;标准&quot;宏MIN ，这个宏输入两个参数并返回较小的一个。</h2><p><code>#define MIN(A,B)((A)&lt;= (B) ? (A) : (B))</code></p><p>这个测试是为下面的目的而设的：</p><ol><li><p>标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。</p></li><li><p>三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优的代码，了解这个用法是很重要的。</p></li><li><p>懂得在宏中小心地把参数用括号括起来</p></li><li><p>我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？</p></li></ol><p><code>least = MIN(*p++, b); -&gt;((*p++) &lt;b ？(*p++) : b)</code>  此时前后两个的<em>p++ 的值已经不是同一个了，多处使用这个宏时，每次的</em>p++ 都不是同一个值</p><h2 id="13-预处理器标识error的目的是什么"><a class="markdownIt-Anchor" href="#13-预处理器标识error的目的是什么"></a> 1.3. 预处理器标识#error的目的是什么？</h2><p>这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。</p><h1 id="2-死循环-infinite-loops"><a class="markdownIt-Anchor" href="#2-死循环-infinite-loops"></a> 2. 死循环 (Infinite loops)</h1><h2 id="21-嵌入式系统中经常要用到无限循环你怎么样用-c-编写死循环呢"><a class="markdownIt-Anchor" href="#21-嵌入式系统中经常要用到无限循环你怎么样用-c-编写死循环呢"></a> 2.1. 嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？</h2><p>这个问题用几个解决方案。我首选的方案是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些程序员更喜欢如下方案：</p><p>一些程序员更喜欢如下方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现方式让我为难， 因为这个语法没有确切表达到底怎么回事。 如果一个应试者给出这个作为方案， 我将用这个作为一个机会去探究他们这样做的基本原理。 如果他们的基本答案是： “我被教着这样做，但从没有想到过为什么。 ”这会给我留下一个坏印象。第三个方案是用 goto</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line"><span class="keyword">goto</span> Loop;</span><br></pre></td></tr></table></figure><p>应试者如给出上面的方案， 这说明或者他是一个汇编语言程序员 (这也许是好事) 或者他是一个想进入新领域的 BASIC/FORTRAN 程序员。</p><h1 id="3-数据声明-data-declarations"><a class="markdownIt-Anchor" href="#3-数据声明-data-declarations"></a> 3. 数据声明 (Data declarations)</h1><h2 id="31-用变量-a-给出下面的定义"><a class="markdownIt-Anchor" href="#31-用变量-a-给出下面的定义"></a> 3.1. 用变量 a 给出下面的定义</h2><p>a) 一个整型数(An integer )<br />b) 一个指向整型数的指针(A pointer to an integer )<br />c) 一个指向指针的的指针，它指向的指针是指向一个整型数(A pointer to a pointer to aninteger)<br />d) 一个有 10 个整型数的数组(An array of 10 integers )<br />e) 一个有 10 个指针的数组， 该指针是指向一个整型数的 (An array of 10 pointers to integers )<br />f) 一个指向有 10 个整型数数组的指针(A pointer to an array of 10 integers )<br />g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数(A pointer to a function that takes an integer as an argument and returns an integer )<br />h) 一个有 10 个指针的数组， 该指针指向一个函数， 该函数有一个整型参数并返回一个整型数(An array of ten pointers to functions that take an integer argument and return an integer )</p><p>答案是：</p><p>a) int a; // An integer<br />b) int *a; // A pointer to an integer<br />c) int **a; // A pointer to a pointer to an integer<br />d) int a[10]; // An array of 10 integers<br />e) int *a[10]; // An array of 10 pointers to integers<br />f) int (*a)[10]; // A pointer to an array of 10 integers<br />g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br />h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p><p>人们经常声称这里有几个问题是那种要翻一下书才能回答的问题， 我同意这种说法。 当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题 (或者相近的问题) 。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案(或至少大部分答案) ，那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么做出准备呢？</p><h1 id="4-关键字-static"><a class="markdownIt-Anchor" href="#4-关键字-static"></a> 4. 关键字 Static</h1><h2 id="41-关键字-static-的作用是什么"><a class="markdownIt-Anchor" href="#41-关键字-static-的作用是什么"></a> 4.1. 关键字 static 的作用是什么？</h2><p>这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：<br />(1) 函数体内 static 变量的作用范围为该函数体， 不同于 auto 变量，该变量的内存只被分<br />配一次，因此其值在下次调用时仍维持上次的值；<br />(2)在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访<br />问；<br />(3)在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限<br />制在声明它的模块内；<br />(4)在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br />(5)在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访<br />问类的 static 成员变量。</p><h1 id="5-关键字-const"><a class="markdownIt-Anchor" href="#5-关键字-const"></a> 5. 关键字 Const</h1><h2 id="51-关键字-const-是什么含意"><a class="markdownIt-Anchor" href="#51-关键字-const-是什么含意"></a> 5.1 关键字 const 是什么含意？</h2><p>我只要一听到被面试者说： “ const意味着常数 ”，我就知道我正在和一个业余者打交道。去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP(译者： Embedded Systems Programming)的每一位读者应该非常熟悉 const 能做什么和不能做什么 .如果你从没有读到那篇文章，只要能说出 const 意味着 “只读 ”就可以了。尽管这个答案不是完全的答案， 但我接受它作为一个正确的答案。 (如果你想知道更详细的答案，仔细读一下 Saks 的文章吧。)如果应试者能正确回答这个问题，我将问他一个附加的问题：<br />下面的声明都是什么意思？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>前两个的作用是一样， <code>a</code> 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针(也就是，整型数是不可修改的，但指针可以)。第四个意思 a 是一个指向整型数的常指针(也就是说，指针指向的整型数是可以修改的，但指针是不可修改的)。最后一个意味着 <code>a</code> 是一个指向常整型数的常指针 (也就是说， 指针指向的整型数是不可修改的， 同时指针也是不可修改的) 。 如果应试者能正确回答这些问题， 那么他就给我留下了一个好印象。 顺带提一句，也许你可能会问，即使不用关键字 <code>const</code>，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字 <code>const</code> 呢？我也如下的几下理由：</p><ol><li>关键字 <code>const</code> 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。(当然，懂得用 <code>const</code> 的程序员很少会留下的垃圾让别人来清理的。)</li><li>通过给优化器一些附加的信息，使用关键字 <code>const</code> 也许能产生更紧凑的代码。</li><li>合理地使用关键字 <code>const</code> 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少 <code>bug</code> 的出现。</li></ol><p>(1)欲阻止一个变量被改变，可以使用 <code>const</code> 关键字。在定义该 <code>const</code> 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br />(2)对指针来说，可以指定指针本身为 <code>const</code>，也可以指定指针所指的数据为 <code>const</code>，或二者同时指定为 <code>const</code>；<br />(3)在一个函数声明中， <code>const</code> 可以修饰形参 ，表明它是一个输入参数，在函数内部不能改变其值；<br />(4)对于类的成员函数，若指定其为 <code>const</code> 类型，则表明其是一个常函数，不能修改类的成员变量；<br />(5) 对于类的成员函数， 有时候必须指定其返回值为 <code>const</code> 类型， 以使得其返回值不为 “左值”。例如：<br /><code>const classA operator*(const classA&amp; a1,const classA&amp; a2);*</code><br /><code>operator*</code> 的返回结果必须是一个 <code>const</code> 对象。如果不是，这样的变态代码也不会编译出错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classA a, b, c;</span><br><span class="line">(a * b) = c; <span class="comment">// 对 a*b 的结果赋值</span></span><br></pre></td></tr></table></figure><p>​操作 <code>(a * b) = c</code> 显然不符合编程者的初衷，也没有任何意义。<br />剖析：惊讶吗？小小的 <code>static</code> 和 <code>const</code> 居然有这么多功能，我们能回答几个？如果只能回答1~2 个，那还真得闭关再好好修炼修炼。这个题可以考查面试者对程序设计知识的掌握程度是初级、 中级还是比较深入， 没有一定的知识广度和深度，不可能对这个问题给出全面的解答。大多数人只能回答出 <code>static</code> 和 <code>const</code><br />关键字的部分功能。</p><h2 id="52-写一个函数返回-123-n-的值假定结果不会超过长整型变量的范围"><a class="markdownIt-Anchor" href="#52-写一个函数返回-123-n-的值假定结果不会超过长整型变量的范围"></a> 5.2 写一个函数返回 <code>1+2+3+ , +n</code> 的值(假定结果不会超过长整型变量的范围)</h2><p>解答：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">( <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">return</span> ( (<span class="keyword">long</span>)<span class="number">1</span> + n) * n / <span class="number">2</span>; <span class="comment">//或 return (1l + n) * n / 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剖析：对于这个题，只能说，也许最简单的答案就是最好的答案。下面的解答，或者基于下面的解答思路去优化，不管怎么“折腾” ，其效率也不可能与直接 <code>return ( 1 l + n ) * n / 2</code> 相比！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Sum( int n )</span><br><span class="line">&#123;</span><br><span class="line">long sum = 0;for( int i=1; i&lt;=n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">    sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以程序员们需要敏感地将数学等知识用在程序设计中。</p><h1 id="6-6-关键字-volatile"><a class="markdownIt-Anchor" href="#6-6-关键字-volatile"></a> 6. 6 关键字 Volatile</h1><h2 id="61-关键字-volatile-有什么含意并给出三个不同的例子"><a class="markdownIt-Anchor" href="#61-关键字-volatile-有什么含意并给出三个不同的例子"></a> 6.1 关键字 volatile 有什么含意并给出三个不同的例子。</h2><p>一个定义为 <code>volatile</code> 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假<br />设这个变量的值了。 精确地说就是， 优化器在用到这个变量时必须每次都小心地重新读取这<br />个变量的值，而不是使用保存在寄存器里的备份。下面是 <code>volatile</code> 变量的几个例子：<br />1). 并行设备的硬件寄存器（如：状态寄存器）<br />2). 一个中断服务子程序中会访问到的非自动变量 <strong>(Non-automatic variables</strong>)<br />3). 多线程应用中被几个任务共享的变量回答不出这个问题的人是不会被雇佣的。我认为这<br />是区分 C 程序员和嵌入式系统程序员的最基本的问题<br />。嵌入式系统程序员经常同硬件、中断、 <strong>RTOS</strong> 等等打交道，所用这些都要求 <code>volatile</code> 变量。<br />不懂得 <code>volatile</code> 内容将会带来灾难。假设被面试者正确地回答了这是问题（嗯，怀疑这否会<br />是这样），我将稍微深究一下，看一下这家伙<br />是不是直正懂得 <code>volatile</code> 完全的重要性。<br />1). 一个参数既可以是 <code>const</code> 还可以是 <code>volatile</code> 吗？解释为什么。<br />2). 一个指针可以是 <code>volatile</code> 吗？解释为什么。<br />3). 下面的函数有什么错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">return *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是答案：<br />1). 是的。一个例子是只读的状态寄存器。它是 <code>volatile</code> 因为它可能被意想不到地改变。它<br />是 <code>const</code> 因为程序不应该试图去修改它。<br />2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 <code>buffer</code> 的<br />指针时。<br />3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 <code>*ptr</code> 指向值的平方，但是，由于<br /><code>\*ptr</code> 指向一个 <code>volatile</code> 型参数，编译器将产生类似下面的代码：</p><p>下面是答案：<br />1). 是的。一个例子是只读的状态寄存器。它是 <code>volatile</code> 因为它可能被意想不到地改变。它<br />是 <code>const</code> 因为程序不应该试图去修改它。<br />2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 <code>buffer</code> 的<br />指针时。<br />3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 <code>*ptr</code> 指向值的平方，但是，由于<br /><code>*ptr</code> 指向一个<code>volatile</code> 型参数，编译器将产生类似下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">a = *ptr;</span><br><span class="line">b = *ptr;</span><br><span class="line">return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>*ptr</code> 的值可能被意想不到地该变，因此 <code>a</code> 和 <code>b</code> 可能是不同的。结果，这段代码可能返不<br />是你所期望的平方值！正确的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">a = *ptr;</span><br><span class="line">return a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-位操作-bit-manipulation"><a class="markdownIt-Anchor" href="#7-位操作-bit-manipulation"></a> 7. 位操作（ Bit manipulation）</h1><h2 id="71"><a class="markdownIt-Anchor" href="#71"></a> 7.1</h2><p>嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量 <code>a</code>，写两段代码，第一个设置 <code>a</code> 的 bit 3，第二个清除 <code>a</code> 的 bit 3。在以上两个操作中，要保持其它位不变。对这个问题有三种基本的反应<br />1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。<br />2). 用 bit fields 。 Bit fields 是被扔到 C 语言死角的东西，它保证你的代码在不同编译器之间是不可移植的， 同时也保证了的你的代码是不可重用的。 我最近不幸看到 Infineon 为其较复杂的通信芯片写的驱动程序， 它用到了 bit fields 因此完全对我无用， 因为我的编译器用其它的方式来实现 bit fields 的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。<br />3). 用 <code>#defines</code> 和 bit masks 操作。 这是一个有极高可移植性的方法， 是应该被用到的方法。<br />最佳的解决方案如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1&lt;&lt;3)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a |= BIT3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a &amp;= ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数， 这也是可以接受的。 我希望看到几个要点：<strong>说明常数</strong>、 <code>|=</code>和&amp;<code>=~</code> 操作。</p><h1 id="8-访问固定的内存位置-accessing-fixed-memory-locations"><a class="markdownIt-Anchor" href="#8-访问固定的内存位置-accessing-fixed-memory-locations"></a> 8. 访问固定的内存位置（ Accessing fixed memory locations ）</h1><h2 id="81"><a class="markdownIt-Anchor" href="#81"></a> 8.1</h2><p>嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为 0x67a9 的整型变量的值为 0xaa66。编译器是一个纯粹的 ANSI 编译器。写代码去完成这一任务。这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（ typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> *)<span class="number">0x67a9</span>;*ptr = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>一个较晦涩的方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><p>一个较晦涩的方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><h1 id="9-中断-interrupts"><a class="markdownIt-Anchor" href="#9-中断-interrupts"></a> 9. 中断（ Interrupts）</h1><h2 id="91"><a class="markdownIt-Anchor" href="#91"></a> 9.1</h2><p>中断是嵌入式系统中重要的组成部分， 这导致了很多编译开发商提供一种扩展 —让标准C 支持中断。具代表事实是，产生了一个新的关键字 <code>interrupt</code> 。下面的代码就使用了<code>interrupt</code> 关键字去定义了一个中断服务子程序 (<strong>ISR</strong>) ，请评论一下这段代码的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__interrupt <span class="keyword">double</span> <span class="title">compute_area</span> <span class="params">(<span class="keyword">double</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> area = PI * radius * radius;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Area = %f&quot;</span>, area);</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有太多的错误了，以至让人不知从何说起了：</p><ol><li><strong>ISR</strong> 不能返回一个值。如果你不懂这个，那么你不会被雇用的。</li><li><strong>ISR</strong> 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。</li><li>在许多的处理器 /编译器中，浮点一般都是不可重入的。有些处理器 /编译器需要让额处的寄存器入栈，有些处理器 /编译器就是不允许在 <strong>ISR</strong> 中做浮点运算。此外， <strong>ISR</strong> 应该是短而有效率的，在 <strong>ISR</strong> 中做浮点运算是不明智的。</li><li>与第三点一脉相承， <code>printf()</code> 经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。代码例子（ <strong>Code examples</strong>）</li></ol><h2 id="92"><a class="markdownIt-Anchor" href="#92"></a> 9.2</h2><p>下面的代码输出是什么，为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-20</span>;</span><br><span class="line">(a+b &gt; <span class="number">6</span>) <span class="built_in">puts</span>(<span class="string">&quot;&gt; 6&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;&lt;= 6&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。 不管如何， 这无符号整型问题的答案是输出是 “ <code>&gt;6</code>”。 原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此 -20 变成了一个非常大的正整数，所以该表达式计算出的结果大于 6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。</p><h2 id="93"><a class="markdownIt-Anchor" href="#93"></a> 9.3</h2><p>评价下面的代码片断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compzero = <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">/*1&#x27;s complement of zero */</span></span><br></pre></td></tr></table></figure><p>对于一个 <code>int</code> 型不是 16 位的处理器为说，上面的代码是不正确的。应编写如下：<br /><code>unsigned int compzero = ~0;</code>这一问题真正能揭露出应试者是否懂得处理器字长的重要性。 在我的经验里， 好的嵌入式程序员非常准确地明白硬件的细节和它的局限， 然而 PC 机程序往往把硬件作为一个无法避免的烦恼。 到了这个阶段， 应试者或者完全垂头丧气了或者信心满满志在必得。 如果显然应试者不是很好， 那么这个测试就在这里结束了。 但如果显然应试者做得不错， 那么我就扔出下面的追加问题， 这些问题是比较难的， 我想仅仅非常优秀的应试者能做得不错。 提出这些问题， 我希望更多看到应试者应付问题的方法， 而不是答案。 不管如何， 你就当是这个娱乐吧 …</p><h1 id="10-动态内存分配-dynamic-memory-allocation"><a class="markdownIt-Anchor" href="#10-动态内存分配-dynamic-memory-allocation"></a> 10. 动态内存分配（ Dynamic memory allocation）</h1><h2 id="101"><a class="markdownIt-Anchor" href="#101"></a> 10.1</h2><p>尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（ <strong>heap</strong>）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br />这里， 我期望应试者能提到内存碎片，碎片收集的问题， 变量的持行时间等等。这个主题已经在 ESP 杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">if</span> ((ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0</span>)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Got a null pointer&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Got a valid pointer&quot;</span>);</span><br></pre></td></tr></table></figure><p>这是一个有趣的问题。 最近在我的一个同事不经意把 0 值传给了函数 <code>malloc</code>， 得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是 “ <code>Gota validpointer</code> ” 。我用这个来开始讨论这样的一问题， 看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。</p><h1 id="11-数据类型-typedef"><a class="markdownIt-Anchor" href="#11-数据类型-typedef"></a> 11. 数据类型 Typedef</h1><h2 id="111"><a class="markdownIt-Anchor" href="#111"></a> 11.1</h2><p>Typedef 在 C 语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define dPS struct s *</span><br><span class="line">typedef struct s * tPS;</span><br></pre></td></tr></table></figure><p>以上两种情况的意图都是要定义 <strong>dPS</strong> 和 <strong>tPS</strong> 作为一个指向结构 s 指针。哪种方法更好呢？（如果有的话） 为什么？这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是： <code>typedef</code> 更好。思考下面的例子：</p><p>以上两种情况的意图都是要定义 <strong>dPS</strong> 和 tPS <strong>作为</strong>一个指向结构 <strong>s</strong> 指针。哪种方法更好呢？（如果有的话） 为什么？这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是： typedef 更好。思考下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dPS p1,p2;</span><br><span class="line">tPS p3,p4;</span><br></pre></td></tr></table></figure><p>第一个扩展为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">p1</span>, <span class="title">p2</span>;</span></span><br></pre></td></tr></table></figure><p>上面的代码定义 <strong>p1</strong> 为一个指向结构的指， <strong>p2</strong> 为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了 <strong>p3</strong> 和 <strong>p4</strong> 两个指针。</p><p>第一个扩展为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">p1</span>, <span class="title">p2</span>;</span></span><br></pre></td></tr></table></figure><p>上面的代码定义 p1 为一个指向结构的指， p2 为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了 p3 和 p4 两个指针。</p><p>上面的代码定义 p1 为一个指向结构的指， p2 为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了 p3 和 p4 两个指针。</p><h1 id="12-晦涩的语法"><a class="markdownIt-Anchor" href="#12-晦涩的语法"></a> 12. 晦涩的语法</h1><h2 id="121"><a class="markdownIt-Anchor" href="#121"></a> 12.1</h2><p>C 语言同意一些令人震惊的结构 ,下面的结构是合法的吗，如果是它做些什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">7</span>, c;</span><br><span class="line">c = a+++b;</span><br></pre></td></tr></table></figure><p>这个问题将做为这个测验的一个愉快的结尾。 不管你相不相信， 上面的例子是完全合乎语法的。 问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题， 根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a++ + b;</span><br></pre></td></tr></table></figure><p>因此 , 这段代码持行后 <code>a = 6, b = 7, c = 12</code>。如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是 :这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题</p>]]></content>
      
      
      <categories>
          
          <category> 知识梳理 </category>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> 知识梳理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ array模板类使用</title>
      <link href="/posts/3a13bccb.html"/>
      <url>/posts/3a13bccb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>C++中的数组类型是继承了C语言的特性，在使用数组的时候要注意数组越界操作问题。为了更安全的对数组进行操作，C++提出了数组模板类array。</p><h1 id="1-array模板类的定义"><a class="markdownIt-Anchor" href="#1-array模板类的定义"></a> 1. array模板类的定义</h1><h2 id="11-array模板类的声明"><a class="markdownIt-Anchor" href="#11-array模板类的声明"></a> 1.1 array模板类的声明</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>，<span class="title">size_t</span> <span class="title">N</span>&gt;</span> <span class="class"><span class="keyword">class</span> <span class="title">array</span>;</span></span><br></pre></td></tr></table></figure><p>数组类是固定大小的序列容器，它们包含以严格线性序列排序的特定数量的元素。数组类具有固定大小，并且不通过分配器管理其元素的分配，它们是封装固定大小元素数组的聚合类型。</p><h2 id="12-容器属性"><a class="markdownIt-Anchor" href="#12-容器属性"></a> 1.2 容器属性</h2><p>序列容器中的元素按严格的线性顺序排序。各个元素按其顺序访问它们的位置。<br />元素存储在连续的存储器位置，允许对元素进行恒定时间随机访问。可以偏移元素的指针以访问其他元素。<br />容器使用隐式构造函数和析构函数静态分配所需的空间。它的大小是编译时常量。没有内存或时间开销。</p><h2 id="13-array模板类的说明"><a class="markdownIt-Anchor" href="#13-array模板类的说明"></a> 1.3 array模板类的说明</h2><p>array模板类中T为包含元素的类型<code>（std::array::value_type）</code>，<strong>N</strong>为元素个数。</p><h2 id="14-array模板类头文件"><a class="markdownIt-Anchor" href="#14-array模板类头文件"></a> 1.4 array模板类头文件</h2><p>使用array模板类之前需要包含<code>#include &lt;array&gt;</code>头文件！</p><h1 id="2-array模板类的使用"><a class="markdownIt-Anchor" href="#2-array模板类的使用"></a> 2. array模板类的使用</h1><h2 id="21-iterators"><a class="markdownIt-Anchor" href="#21-iterators"></a> 2.1 Iterators</h2><p>Iterators迭代器的作用是遍历array数组类中的元素。可以通过<strong>begin/end()</strong>、<strong>rbegin/rend()</strong>、<strong>cbegin/cend()</strong>、**crbegin/crend()**等函数进行访问。</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:left">功能</th></tr></thead><tbody><tr><td style="text-align:center">begin</td><td style="text-align:left">Return iterator to beginning</td></tr><tr><td style="text-align:center">end</td><td style="text-align:left">Return iterator to end</td></tr><tr><td style="text-align:center">rbegin</td><td style="text-align:left">Return reverse iterator to reverse beginning</td></tr><tr><td style="text-align:center">rend</td><td style="text-align:left">Return reverse iterator to reverse end</td></tr><tr><td style="text-align:center">cbegin</td><td style="text-align:left">Return const_iterator to beginning</td></tr><tr><td style="text-align:center">cend</td><td style="text-align:left">Return const_iterator to end</td></tr><tr><td style="text-align:center">crbegin</td><td style="text-align:left">Return const_reverse_iterator to reverse beginning</td></tr><tr><td style="text-align:center">crend</td><td style="text-align:left">Return const_reverse_iterator to reverse end</td></tr></tbody></table><p>参考代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = arr.<span class="built_in">begin</span>(); it != arr.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array values: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> <span class="number">4</span> <span class="number">5</span></span><br></pre></td></tr></table></figure><h2 id="22-capacity"><a class="markdownIt-Anchor" href="#22-capacity"></a> 2.2 Capacity</h2><p>array数组容器的大小是固定的。可以通过<strong>sizeof()</strong>、<strong>size()</strong>、<strong>max_size()</strong>、**empty()**等函数进行检测。</p><table><thead><tr><th style="text-align:center">函数</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">size</td><td>Return size</td></tr><tr><td style="text-align:center">max_size</td><td>Return maximum size</td></tr><tr><td style="text-align:center">empty</td><td>Test whether list is empty</td></tr></tbody></table><p>测试array数组容器大小的参考代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 5&gt; arr = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;sizeof(array) = &quot;</span> &lt;&lt; <span class="built_in"><span class="keyword">sizeof</span></span>(arr) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;size of array = &quot;</span> &lt;&lt; arr.<span class="built_in">size</span>() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;max_size of array = &quot;</span> &lt;&lt; arr.<span class="built_in">max_size</span>() &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">if</span> (arr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;array is empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;array is not empty!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in"><span class="keyword">sizeof</span></span>(array) = <span class="number">20</span></span><br><span class="line">size of array = <span class="number">5</span></span><br><span class="line">max_size of array = <span class="number">5</span></span><br><span class="line">array is <span class="keyword">not</span> empty!</span><br></pre></td></tr></table></figure><h2 id="23-element-access"><a class="markdownIt-Anchor" href="#23-element-access"></a> 2.3 Element access</h2><p>可以通过<strong>下标[ ]</strong>、<strong>at()</strong>、<strong>front()</strong>、<strong>back()</strong>、<strong>data()<strong>等函数访问</strong>array</strong>容器内的元素。</p><table><thead><tr><th>函数</th><th>功能</th></tr></thead><tbody><tr><td>operator[ ]</td><td>Access element</td></tr><tr><td>at</td><td>Access element</td></tr><tr><td>front</td><td>Access first element</td></tr><tr><td>back</td><td>Access last element</td></tr><tr><td>data</td><td>Get pointer to first data</td></tr></tbody></table><p>参考代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    std::array&lt;int, 5&gt; arr = &#123;1, 2, 3, 4, 5&#125;;</span><br><span class="line">    std::cout &lt;&lt; &quot;array[0] = &quot; &lt;&lt; arr[0] &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;array.at(4) = &quot; &lt;&lt; arr.at(4) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;array.front() = &quot; &lt;&lt; arr.front() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;array.back() = &quot; &lt;&lt; arr.back() &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; &quot;&amp;array: &quot; &lt;&lt; arr.data() &lt;&lt; &quot; = &quot; &lt;&lt; &amp;arr &lt;&lt; std::endl;</span><br><span class="line">    return 0;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">array[<span class="number">0</span>] = <span class="number">1</span></span><br><span class="line">array.<span class="built_in">at</span>(<span class="number">4</span>) = <span class="number">5</span></span><br><span class="line">array.<span class="built_in">front</span>() = <span class="number">1</span></span><br><span class="line">array.<span class="built_in">back</span>() = <span class="number">5</span></span><br><span class="line">&amp;array: <span class="number">0x7ffd22df6e50</span> = <span class="number">0x7ffd22df6e50</span></span><br></pre></td></tr></table></figure><h2 id="24-modifiers"><a class="markdownIt-Anchor" href="#24-modifiers"></a> 2.4 Modifiers</h2><p>可以使用<strong>fill()</strong>、<strong>swap()<strong>等函数对</strong>array</strong>容器整体进行操作。</p><table><thead><tr><th style="text-align:center">函数</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">fill</td><td>Fill array with value</td></tr><tr><td style="text-align:center">swap</td><td>Swap content</td></tr></tbody></table><p>参考代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 5&gt; arr;</span><br><span class="line">    arr.<span class="built_in">fill</span>(<span class="number">5</span>);  <span class="comment">// fill</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> i : arr) &#123;</span><br><span class="line">        std::cout &lt;&lt; i &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 3&gt; first = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>&#125;;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>, 3&gt; second = &#123;<span class="number">6</span>, <span class="number">5</span>, <span class="number">4</span>&#125;;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first  array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = first.<span class="built_in">begin</span>(); it != first.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;second array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = second.<span class="built_in">begin</span>(); it != second.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    first.<span class="built_in">swap</span>(second);  <span class="comment">// swap</span></span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;swap array success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first  array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = first.<span class="built_in">begin</span>(); it != first.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;second array values: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> it = second.<span class="built_in">begin</span>(); it != second.<span class="built_in">end</span>(); ++it) &#123;</span><br><span class="line">        std::cout &lt;&lt; *it &lt;&lt; <span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array values: <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> <span class="number">5</span> </span><br><span class="line">first  array values: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br><span class="line">second array values: <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line">swap array success!</span><br><span class="line">first  array values: <span class="number">6</span> <span class="number">5</span> <span class="number">4</span> </span><br><span class="line">second array values: <span class="number">1</span> <span class="number">2</span> <span class="number">3</span> </span><br></pre></td></tr></table></figure><h2 id="25-compare"><a class="markdownIt-Anchor" href="#25-compare"></a> 2.5 Compare</h2><p>还可以使用**&gt;  &lt;  ==<strong>等符号对两个</strong>array**数组容器进行比较。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;array&gt;</span><br><span class="line"></span><br><span class="line">int main(void) &#123;</span><br><span class="line">    std::array&lt;int,5&gt; a = &#123;10, 20, 30, 40, 50&#125;;</span><br><span class="line">    std::array&lt;int,5&gt; b = &#123;10, 20, 30, 40, 50&#125;;</span><br><span class="line">    std::array&lt;int,5&gt; c = &#123;50, 40, 30, 20, 10&#125;;</span><br><span class="line">    if (a == b) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;a == b&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;a != b&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a == c) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;a == c&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;a != c&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    if (a &lt; c) &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;a &lt; c&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;a &gt;= c&quot; &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a == b</span><br><span class="line">a != c</span><br><span class="line">a &lt; c</span><br></pre></td></tr></table></figure><h2 id="26-other"><a class="markdownIt-Anchor" href="#26-other"></a> 2.6 Other</h2><p>c++重载了<strong>get()<strong>函数来访问数组容器中的元素，为了和元组相似，还重载了</strong>tuple_size</strong>和<strong>tuple_element</strong>类型。</p><table><thead><tr><th style="text-align:center">函数</th><th>功能</th></tr></thead><tbody><tr><td style="text-align:center">get( array)</td><td>Get element (tuple interface)</td></tr><tr><td style="text-align:center">tuple_element&lt;array&gt;</td><td>Tuple element type for array</td></tr><tr><td style="text-align:center">tuple_size&lt;array&gt;</td><td>Tuple size traits for array</td></tr></tbody></table><p>参考代码如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;array&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;tuple&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">void</span>)</span> </span>&#123;</span><br><span class="line">    std::array&lt;<span class="keyword">int</span>,3&gt; myarray = &#123;<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>&#125;;</span><br><span class="line">    <span class="function">std::tuple&lt;<span class="keyword">int</span>, <span class="keyword">int</span>, <span class="keyword">int</span>&gt; <span class="title">mytuple</span> <span class="params">(<span class="number">10</span>, <span class="number">20</span>, <span class="number">30</span>)</span></span>;</span><br><span class="line">    std::tuple_element&lt;<span class="number">0</span>, <span class="keyword">decltype</span>(myarray)&gt;::type myelement;  <span class="comment">// int myelement</span></span><br><span class="line">    myelement = std::get&lt;<span class="number">2</span>&gt;(myarray);</span><br><span class="line">    std::get&lt;<span class="number">2</span>&gt;(myarray) = std::get&lt;<span class="number">0</span>&gt;(myarray);</span><br><span class="line">    std::get&lt;<span class="number">0</span>&gt;(myarray) = myelement;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first element in myarray: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(myarray) &lt;&lt; std::endl;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;first element in mytuple: &quot;</span> &lt;&lt; std::get&lt;<span class="number">0</span>&gt;(mytuple) &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>运行结果如下所示：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">first element in myarray: <span class="number">30</span></span><br><span class="line">first element in mytuple: <span class="number">10</span></span><br></pre></td></tr></table></figure><p>建议：多使用array数组容器代替c类型数组，使操作数组元素更加安全！</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 代码换行的问题</title>
      <link href="/posts/925153f2.html"/>
      <url>/posts/925153f2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>编写代码时遇到代码超长的情况，为了代码的易读性,美观及方便调试，需要涉及到代码的换行问题。</p><h1 id="1-define宏"><a class="markdownIt-Anchor" href="#1-define宏"></a> 1. #define宏</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) \ </span></span><br><span class="line">((a) &lt; (b) ? (b) : (a)) </span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAX(a,b) ((a) &lt;(b) ? (b) : (a)) </span></span><br></pre></td></tr></table></figure><h1 id="2-关键字的换行"><a class="markdownIt-Anchor" href="#2-关键字的换行"></a> 2. 关键字的换行</h1><p>关键字换行支持：+ - * / % = , | &amp; ^ ~ || &amp;&amp; == !=以及括号等，均能作为换行符号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (!_IsValidIndex(nIndex) </span><br><span class="line">        || m_nChkStyle == RC_CHKBOX_NONE</span><br><span class="line">        || (bBefore &amp;&amp; bAfter)</span><br><span class="line">        || (!bBefore &amp;&amp; !bAfter))</span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">return</span> FALSE;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-字符串的换行"><a class="markdownIt-Anchor" href="#3-字符串的换行"></a> 3. 字符串的换行</h1><p>换行的字符串行尾添加双引号，下一行开头也加上双引号。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;1234567890ab&quot;</span></span><br><span class="line"><span class="string">&quot;cdefg&quot;</span>); </span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> buf[<span class="number">128</span>]; </span><br><span class="line"><span class="built_in">strcpy</span>(buf, <span class="string">&quot;1234567890abcdefg&quot;</span>);</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 对数组进行复制</title>
      <link href="/posts/dd9d548b.html"/>
      <url>/posts/dd9d548b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-c-风格的复制操作"><a class="markdownIt-Anchor" href="#1-c-风格的复制操作"></a> 1. C++ 风格的复制操作</h1><h2 id="11-使用stl中的copy算法"><a class="markdownIt-Anchor" href="#11-使用stl中的copy算法"></a> 1.1 使用STL中的copy算法</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> b[<span class="number">5</span>];</span><br><span class="line">std::<span class="built_in">copy</span>(std::<span class="built_in">begin</span>(a),std::<span class="built_in">end</span>(a),std::<span class="built_in">begin</span>(b));</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:b) cout&lt;&lt;e&lt;&lt;<span class="string">&quot; &quot;</span>;     <span class="comment">// 输出 1,2,3,4,5</span></span><br></pre></td></tr></table></figure><p>上述程序中，copy算法将数组a区间中的数复制到以begin(b)开始的区间中去.</p><h2 id="12-使用array容器c11"><a class="markdownIt-Anchor" href="#12-使用array容器c11"></a> 1.2 使用array容器(C++11)</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">std::array&lt;<span class="keyword">int</span>,5&gt; arr = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line">std::array&lt;<span class="keyword">int</span>,5&gt; copy;</span><br><span class="line">copy = arr;      <span class="comment">// 将arr中的元素复制到copy中</span></span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">100</span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:copy) cout&lt;&lt;e&lt;&lt;<span class="string">&quot; &quot;</span>;      <span class="comment">//输出 1,2,3,4,5</span></span><br></pre></td></tr></table></figure><h1 id="2-c风格的复制操作"><a class="markdownIt-Anchor" href="#2-c风格的复制操作"></a> 2. C风格的复制操作</h1><h2 id="21-使用memcpy"><a class="markdownIt-Anchor" href="#21-使用memcpy"></a> 2.1 使用memcpy()</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> copy[<span class="number">5</span>];</span><br><span class="line"><span class="keyword">int</span> len = <span class="built_in"><span class="keyword">sizeof</span></span>(arr) / <span class="built_in"><span class="keyword">sizeof</span></span>(arr[<span class="number">0</span>]);</span><br><span class="line"><span class="built_in">memcpy</span>(copy,arr,len*<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>));   <span class="comment">// 输出 1,2,3,4,5</span></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:copy) cout&lt;&lt;e&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>注意：memcpy()函数的第三个参数表示的是要复制的字节数，而不是要复制的元素数目。至于这样做的原因，可以先来看memcpy()的原型:</strong><br /><code>void* memcpy(void* destination,const void* source,size_t num);</code></p><p><strong>由memcpy()的函数原型可以看到，该函数的前两个参数的类型是void*类型，这样做是为了使memcpy()可以作用于任何类型的指针。</strong></p><p><strong>但这样做又导致了一个问题，即memcpy()不知道传入数组的每个元素用多少字节来表示。也正是因为这个原因，使得memcpy()的第三个参数不能是要复制的元素个数，而是要复制的字节数。</strong></p><h2 id="22-使用memmove"><a class="markdownIt-Anchor" href="#22-使用memmove"></a> 2.2 使用memmove()</h2><p>该函数与memcpy()类似，只是memmove允许目的位置和源位置重叠，示例如下:</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> arr[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>&#125;;</span><br><span class="line"><span class="built_in">memmove</span>(arr+<span class="number">3</span>,arr+<span class="number">1</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(<span class="keyword">int</span>)*<span class="number">5</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">auto</span> e:arr) cout&lt;&lt;e&lt;&lt;<span class="string">&quot; &quot;</span>;       <span class="comment">// 输出 1,2,3,2,3,4,5,6</span></span><br></pre></td></tr></table></figure><p><strong>注意：上面的程序中，如果将memmove()换作memcpy()可能也会正常工作，但是这种行为是不可预计的，当目的位置与源位置存在重叠时，应当使用memmove()。</strong></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ vector的用法</title>
      <link href="/posts/4858c62f.html"/>
      <url>/posts/4858c62f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>vector 是向量类型，它可以容纳许多类型的数据，如若干个整数，所以称其为容器。vector没有find()函数, 且返回的是迭代器, 不是数值, vector 是C++ STL的一个重要成员，使用它时需要包含头文件：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;vector&gt;</span>;</span></span><br></pre></td></tr></table></figure><h1 id="1-vector-的初始化可以有五种方式举例说明如下"><a class="markdownIt-Anchor" href="#1-vector-的初始化可以有五种方式举例说明如下"></a> 1. vector 的初始化：可以有五种方式,举例说明如下：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> (<span class="number">1</span>) <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量（尖括号中为元素类型名，它可以是任何合法的数据类型），但没有给出初值，其值是不确定的。</span></span><br><span class="line">（<span class="number">2</span>）<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(<span class="number">10</span>,<span class="number">1</span>)</span></span>; <span class="comment">//定义了10个整型元素的向量,且给出每个元素的初值为1</span></span><br><span class="line">（<span class="number">3</span>）<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b)</span></span>; <span class="comment">//用b向量来创建a向量，整体复制性赋值</span></span><br><span class="line">（<span class="number">4</span>）<span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b.begin(),b.begin+<span class="number">3</span>)</span></span>; <span class="comment">//定义了a值为b中第0个到第2个（共3个）元素</span></span><br><span class="line">（<span class="number">5</span>）<span class="keyword">int</span> b[<span class="number">7</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">9</span>,<span class="number">8</span>&#125;;</span><br><span class="line">     <span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">a</span><span class="params">(b,b+<span class="number">7</span>)</span></span>; <span class="comment">//从数组中获得初值</span></span><br></pre></td></tr></table></figure><h1 id="2-vector对象的几个重要操作举例说明如下"><a class="markdownIt-Anchor" href="#2-vector对象的几个重要操作举例说明如下"></a> 2. vector对象的几个重要操作，举例说明如下：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">（<span class="number">1</span>）a.<span class="built_in">assign</span>(b.<span class="built_in">begin</span>(), b.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//b为向量，将b的0~2个元素构成的向量赋给a</span></span><br><span class="line">（<span class="number">2</span>）a.<span class="built_in">assign</span>(<span class="number">4</span>,<span class="number">2</span>); <span class="comment">//是a只含4个元素，且每个元素为2</span></span><br><span class="line">（<span class="number">3</span>）a.<span class="built_in">back</span>(); <span class="comment">//返回a的最后一个元素</span></span><br><span class="line">（<span class="number">4</span>）a.<span class="built_in">front</span>(); <span class="comment">//返回a的第一个元素</span></span><br><span class="line">（<span class="number">5</span>）a[i]; <span class="comment">//返回a的第i个元素，当且仅当a[i]存在2013-12-07</span></span><br><span class="line">（<span class="number">6</span>）a.<span class="built_in">clear</span>(); <span class="comment">//清空a中的元素</span></span><br><span class="line">（<span class="number">7</span>）a.<span class="built_in">empty</span>(); <span class="comment">//判断a是否为空，空则返回ture,不空则返回false</span></span><br><span class="line">（<span class="number">8</span>）a.<span class="built_in">pop_back</span>(); <span class="comment">//删除a向量的最后一个元素</span></span><br><span class="line">（<span class="number">9</span>）a.<span class="built_in">erase</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,a.<span class="built_in">begin</span>()+<span class="number">3</span>); <span class="comment">//删除a中第1个（从第0个算起）到第2个元素，也就是说删除的元素从a.begin()+1算起（包括它）一直到a.begin()+         3（不包括它）</span></span><br><span class="line">（<span class="number">10</span>）a.<span class="built_in">push_back</span>(<span class="number">5</span>); <span class="comment">//在a的最后一个向量后插入一个元素，其值为5</span></span><br><span class="line">（<span class="number">11</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入数值5，如a为1,2,3,4，插入元素后为1,5,2,3,4</span></span><br><span class="line">（<span class="number">12</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,<span class="number">3</span>,<span class="number">5</span>); <span class="comment">//在a的第1个元素（从第0个算起）的位置插入3个数，其值都为5</span></span><br><span class="line">（<span class="number">13</span>）a.<span class="built_in">insert</span>(a.<span class="built_in">begin</span>()+<span class="number">1</span>,b+<span class="number">3</span>,b+<span class="number">6</span>); <span class="comment">//b为数组，在a的第1个元素（从第0个算起）的位置插入b的第3个元素到第5个元素（不包括b+6），如b为1,2,3,4,5,9,8         ，插入元素后为1,4,5,9,2,3,4,5,9,8</span></span><br><span class="line">（<span class="number">14</span>）a.<span class="built_in">size</span>(); <span class="comment">//返回a中元素的个数；</span></span><br><span class="line">（<span class="number">15</span>）a.<span class="built_in">capacity</span>(); <span class="comment">//返回a在内存中总共可以容纳的元素个数</span></span><br><span class="line">（<span class="number">16</span>）a.<span class="built_in">resize</span>(<span class="number">10</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值随机</span></span><br><span class="line">（<span class="number">17</span>）a.<span class="built_in">resize</span>(<span class="number">10</span>,<span class="number">2</span>); <span class="comment">//将a的现有元素个数调至10个，多则删，少则补，其值为2</span></span><br><span class="line">（<span class="number">18</span>）a.<span class="built_in">reserve</span>(<span class="number">100</span>); <span class="comment">//将a的容量（capacity）扩充至100，也就是说现在测试a.capacity();的时候返回值是100.这种操作只有在需要给a添加大量数据的时候才         显得有意义，因为这将避免内存多次容量扩充操作（当a的容量不足时电脑会自动扩容，当然这必然降低性能） </span></span><br><span class="line">（<span class="number">19</span>）a.<span class="built_in">swap</span>(b); <span class="comment">//b为向量，将a中的元素和b中的元素进行整体性交换</span></span><br><span class="line">（<span class="number">20</span>）a==b; <span class="comment">//b为向量，向量的比较操作还有!=,&gt;=,&lt;=,&gt;,&lt;</span></span><br></pre></td></tr></table></figure><h1 id="3-顺序访问vector的几种方式举例说明如下"><a class="markdownIt-Anchor" href="#3-顺序访问vector的几种方式举例说明如下"></a> 3. 顺序访问vector的几种方式，举例说明如下：</h1><h2 id="31-向向量a中添加元素"><a class="markdownIt-Anchor" href="#31-向向量a中添加元素"></a> 3.1 向向量a中添加元素</h2><ol><li><p>向向量a中逐个添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>也可以从数组中选择元素向向量中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; b；</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">4</span>;i++)</span><br><span class="line">b.<span class="built_in">push_back</span>(a[i]);</span><br></pre></td></tr></table></figure></li><li><p>也可以从现有向量中选择元素向向量中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; b;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">c</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=c.<span class="built_in">begin</span>();it&lt;c.<span class="built_in">end</span>();it++)</span><br><span class="line">b.<span class="built_in">push_back</span>(*it);</span><br></pre></td></tr></table></figure></li><li><p>也可以从文件中读取元素向向量中添加</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ifstream <span class="title">in</span><span class="params">(<span class="string">&quot;data.txt&quot;</span>)</span></span>;</span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i; in&gt;&gt;i)</span><br><span class="line">    a.<span class="built_in">push_back</span>(i);</span><br></pre></td></tr></table></figure></li><li><p>误区</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; a;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)</span><br><span class="line">    a[i]=i;</span><br></pre></td></tr></table></figure><p>这种做法以及类似的做法都是错误的。下标只能用于获取已存在的元素，而现在的a[i]还是空的对象</p></li></ol><h2 id="32-向向量中读取元素"><a class="markdownIt-Anchor" href="#32-向向量中读取元素"></a> 3.2 向向量中读取元素</h2><ol><li><p>通过下标方式读取</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;=b.<span class="built_in">size</span>()<span class="number">-1</span>;i++)</span><br><span class="line">    cout&lt;&lt;b[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure></li><li><p>通过遍历器方式读取</p></li></ol><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a[<span class="number">6</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">b</span><span class="params">(a,a+<span class="number">4</span>)</span></span>;</span><br><span class="line"><span class="keyword">for</span>(vector&lt;<span class="keyword">int</span>&gt;::iterator it=b.<span class="built_in">begin</span>();it!=b.<span class="built_in">end</span>();it++)</span><br><span class="line">    cout&lt;&lt;*it&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br></pre></td></tr></table></figure><h1 id="4-几种重要的算法使用时需要包含头文件"><a class="markdownIt-Anchor" href="#4-几种重要的算法使用时需要包含头文件"></a> 4. 几种重要的算法，使用时需要包含头文件：</h1><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line">（<span class="number">1</span>）<span class="built_in">sort</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素进行从小到大排列</span></span><br><span class="line">（<span class="number">2</span>）<span class="built_in">reverse</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>()); <span class="comment">//对a中的从a.begin()（包括它）到a.end()（不包括它）的元素倒置，但不排列，如a中元素为1,3,2,4,倒置后为4,2,3,1</span></span><br><span class="line">（<span class="number">3</span>）<span class="built_in">copy</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),b.<span class="built_in">begin</span>()+<span class="number">1</span>); <span class="comment">//把a中的从a.begin()（包括它）到a.end()（不包括它）的元素复制到b中，从b.begin()+1的位置（包括它）开        始复制，覆盖掉原有元素</span></span><br><span class="line">（<span class="number">4</span>）<span class="built_in">find</span>(a.<span class="built_in">begin</span>(),a.<span class="built_in">end</span>(),<span class="number">10</span>); <span class="comment">//在a中的从a.begin()（包括它）到a.end()（不包括它）的元素中查找10，若存在返回其在向量中的位置</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS学习过程的疑问</title>
      <link href="/posts/b74e4547.html"/>
      <url>/posts/b74e4547.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-ros每一个订阅器都需要一个回调函数吗"><a class="markdownIt-Anchor" href="#1-ros每一个订阅器都需要一个回调函数吗"></a> 1. ros每一个订阅器都需要一个回调函数吗?</h1><p>在使用ros::spin()的情况下，一般来说在初始化时已经设置好所有消息的回调，并且不需要其他背景程序运行。这样以来，每次消息到达时会执行用户的回调函数进行操作，相当于程序是消息事件驱动的；而在使用ros::spinOnce()的情况下，一般来说仅仅使用回调不足以完成任务，还需要其他辅助程序的执行：比如定时任务、数据处理、用户界面等。<br />关于消息接收回调机制在ROS上略有说明 (callbacks and spinning)。总体来说其原理是这样的：除了用户的主程序以外，ROS的socket连接控制进程会在后台接收订阅的消息，所有接收到的消息并不是立即处理，而是等到spin()或者spinOnce()执行时才集中处理。所以为了保证消息可以正常接收，需要尤其注意spinOnce()函数的使用 (对于spin()来说则不涉及太多的人为因素)。<br />I. 对于速度较快的消息，需要注意合理控制消息队列及spinOnce()的时间。例如，如果消息到达的频率是100Hz，而spinOnce()的执行频率是10Hz，那么就要至少保证消息队列中预留的大小大于10。<br />II. 如果对于用户自己的周期性任务，最好和spinOnce()并列调用。即使该任务是周期性的对于数据进行处理，例如对接收到的IMU数据进行Kalman滤波，也不建议直接放在回调函数中：因为存在通信接收的不确定性，不能保证该回调执行在时间上的稳定性。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">100</span>)</span></span>;</span><br><span class="line"><span class="keyword">while</span> (ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">libusb_handle_events_timeout</span>(); <span class="comment">// Handle USB events</span></span><br><span class="line">ros::<span class="built_in">spinOnce</span>(); <span class="comment">// Handle ROS events</span></span><br><span class="line">r.<span class="built_in">sleep</span>();</span><br><span class="line">&#125;</span><br><span class="line">III. 最后说明一下将ROS集成到其他程序架构时的情况。有些图形处理程序会将<span class="built_in">main</span>()包裹起来，此时就需要找到一个合理的位置调用ros::<span class="built_in">spinOnce</span>()。比如对于OpenGL来说，其中有一个方法就是采用设置定时器定时调用的方法：</span><br><span class="line"><span class="comment">// 示例代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">timerCb</span><span class="params">(<span class="keyword">int</span> value)</span> </span>&#123;</span><br><span class="line">ros::<span class="built_in">spinOnce</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">glutTimerFunc</span>(<span class="number">10</span>, timerCb, <span class="number">0</span>);</span><br><span class="line"><span class="built_in">glutMainLoop</span>(); <span class="comment">// Never returns</span></span><br></pre></td></tr></table></figure><h1 id="2-运行roscore出现unable-to-contact-my-own-server-at-http192168010135099"><a class="markdownIt-Anchor" href="#2-运行roscore出现unable-to-contact-my-own-server-at-http192168010135099"></a> 2. 运行roscore出现Unable to contact my own server at [<a href="http://192.168.0.101:35099/">http://192.168.0.101:35099/</a>].</h1><p>解决: 对开启的终端运行 source .bashrc同步环境变量信息,所有大打开的终端重新打开</p><h1 id="3-编译问题"><a class="markdownIt-Anchor" href="#3-编译问题"></a> 3. 编译问题</h1><p>Python是解释性语言， 不需要使用Cmake进行编译，</p><p>可以直接运行， 但是“message_generation”需要经过</p><p>Cmake编译（ msg类型）</p><h1 id="4-catkin_make时需要关闭roscore吗"><a class="markdownIt-Anchor" href="#4-catkin_make时需要关闭roscore吗"></a> 4. catkin_make时需要关闭roscore吗?</h1><p>经过测试,不需要</p><h1 id="5-linux的unixn编码与widnows的docrn问题"><a class="markdownIt-Anchor" href="#5-linux的unixn编码与widnows的docrn问题"></a> 5. Linux的unix(\n)编码与Widnows的doc(\r\n)问题</h1><p>/opt/ros/melodic/bin/rosrun: /home/nanorobot/catkin_ws/src/topic_demo/scripts/pytalker.py: /usr/bin/python^M: 解释器错误: 没有那个文件或目录</p><p>![img](D:\Program Files (x86)\Youdao\qqDBF48B315E1731BEC336E4C6BAA62381\829432d629814538a9a61298a96ee8a0\clipboard.png)</p><h1 id="6-多机通讯问题"><a class="markdownIt-Anchor" href="#6-多机通讯问题"></a> 6. 多机通讯问题</h1><p>连接了多主机通讯的时候, 从机订阅本地自己的Topic msg时回调不到消息, 断开与主机的连接修改好环境变量重新加载环境变量时又能正常订阅回调消息???待查证</p><h1 id="7-刚刚创建的pkg里面没有c只有python脚本需要catkin_make吗"><a class="markdownIt-Anchor" href="#7-刚刚创建的pkg里面没有c只有python脚本需要catkin_make吗"></a> 7. 刚刚创建的pkg里面没有C++,只有python脚本需要catkin_make吗?</h1><p>经过测试,需要,不make一下的话rosrun只能找到该包,但是找不到该包下的可执行文件</p><h1 id="8-刚刚创建的pkg里面没有c只有python脚本需要catkin_make吗"><a class="markdownIt-Anchor" href="#8-刚刚创建的pkg里面没有c只有python脚本需要catkin_make吗"></a> 8. 刚刚创建的pkg里面没有C++,只有python脚本需要catkin_make吗?</h1><p>否认上一点!</p><p>不需要, 但是要确认python脚本的权限为可执行,不然rosrun找不到该执行文件来运行</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS常用指令整理</title>
      <link href="/posts/894a0bcb.html"/>
      <url>/posts/894a0bcb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-系统环境变量"><a class="markdownIt-Anchor" href="#1-系统环境变量"></a> 1. 系统环境变量</h1><h2 id="11-打印ros环境变量"><a class="markdownIt-Anchor" href="#11-打印ros环境变量"></a> 1.1. 打印ros环境变量</h2><p><code>$ echo $ROS_PACKAGE_PATH</code></p><h2 id="12-确认环境变量已经设置正确"><a class="markdownIt-Anchor" href="#12-确认环境变量已经设置正确"></a> 1.2. 确认环境变量已经设置正确</h2><p><code>export | grep ROS</code></p><h2 id="13-环境变量设置文件"><a class="markdownIt-Anchor" href="#13-环境变量设置文件"></a> 1.3. 环境变量设置文件</h2><p><code>sudo gedit ./.bashrc</code></p><p>包含：</p><ul><li><code>source /opt/ros/indigo/setup.bash</code></li><li><code>source ~/catkin_ws/devel/setup.bash</code></li></ul><h1 id="2-多机通讯环境设置"><a class="markdownIt-Anchor" href="#2-多机通讯环境设置"></a> 2. 多机通讯环境设置</h1><h2 id="21-主机端"><a class="markdownIt-Anchor" href="#21-主机端"></a> 2.1. 主机端:</h2><ol><li><p>使用编辑器打开/etc/hosts文件(操作/etc/hosts文件需要管理员权限)</p><p><code>sudo vim /etc/hosts</code></p></li><li><p>在文件中增加下面这一行（192.168.31.202为移动机器人的IP地址），</p><p><code>192.168.31.202 master_ip</code></p></li><li><p>打开.bashrc文件</p><p><code>vim .bashrc</code></p></li><li><p>在文件末尾增加下面三行，修改完成后保存退出（如果之前有设置过相关环境变量，则删除原先设置的）：</p><p><code>export ROS_IP=hostname -I | awk '&#123;print $1&#125;'</code></p><p><code>export ROS_HOSTNAME=hostname -I | awk '&#123;print $1&#125;'</code></p><p><code>export ROS_MASTER_URI=http://master_ip:11311</code></p></li><li><p>设置完成后保存，关闭当前打开的终端重新打开或者在当前打开的每个终端中重新加载一下.bashrc</p><p><code>source ～/.bashrc</code></p></li></ol><h2 id="22-从机端"><a class="markdownIt-Anchor" href="#22-从机端"></a> 2.2. 从机端:</h2><p><code>export ROS_IP=hostname -I | awk '&#123;print $1&#125;'</code></p><p><code>export ROS_HOSTNAME=hostname -I | awk '&#123;print $1&#125;'</code></p><p><code>export ROS_MASTER_URI=http://hostname -I | awk '&#123;print $1&#125;':11311</code></p><p>到这里多机通讯就设置好了,验证是否正确设置的方法很简单，在移动机器人端启动roscore，然后在PC端输出话题列表</p><p><code>rostopic list</code></p><h1 id="3-rospack"><a class="markdownIt-Anchor" href="#3-rospack"></a> 3. rospack</h1><ol><li><p>查看软件包列表</p><p><code>rospack list</code></p></li><li><p>定位软件包</p><p><code>rospack find package-name</code></p></li><li><p>查看ROS包</p><p><code>rospack profile</code></p></li></ol><h1 id="4-rosnode"><a class="markdownIt-Anchor" href="#4-rosnode"></a> 4. rosnode</h1><ol><li><p>查看节点、终止节点</p><p><code>rosnode info node-name</code></p><p><code>rosnode kill node-name</code></p></li><li><p>查看节点构成的计算图</p><p><code>rqt_graph</code></p></li></ol><h1 id="5-rostopic"><a class="markdownIt-Anchor" href="#5-rostopic"></a> 5. rostopic</h1><ol><li><p>输出当前运行的topic列表：</p><p><code>rostopic list</code></p></li><li><p>查看在一个话题上发布的数据</p><p><code>rostopic echo [topic]</code> （用–分割两个相邻的消息）</p></li><li><p>查看topic的类型、发布者、订阅者</p><p><code>rostopic info topic-name</code></p></li><li><p>测量发布频率</p><p><code>rostopic hz topic-name</code> (每秒发布的消息数量)</p><p><code>rostopic bw topic-name</code> （每秒发布信息所占的字节量）</p></li><li><p>用命令行发布消息</p><p><code>rostopic pub -r rate-in-hz topic-name message-type message-content</code></p><p><code>rostopic pub -r 1 /turtle1/cmd_vel geometry_msgs/Twist '[2,0,0]''[0,0,0]'</code></p></li></ol><h1 id="6-rosmsg"><a class="markdownIt-Anchor" href="#6-rosmsg"></a> 6. rosmsg</h1><ol><li><p>查看消息类型</p><p><code>rosmsg show message-type-name</code></p></li></ol><h1 id="7-rosparam"><a class="markdownIt-Anchor" href="#7-rosparam"></a> 7. rosparam</h1><ol><li><p>查看参数列表</p><p><code>rosparam list</code></p></li><li><p>查询参数</p><p><code>rosparam get parameter_name</code></p></li><li><p>设置参数</p><p><code>rosparam set parameter_name parameter_value</code> (rosservice call/clear之后起作用)</p></li><li><p>创建和加载参数文件</p><p><code>rosparam dump/load filename namespace</code></p></li><li><p>在启动文件中设置参数</p><p><code>&lt;param name=&quot;param-name&quot; value=&quot;param-value&quot; /&gt;</code> (可在node标签中设置私有化参数)</p></li><li><p>从文件中读取参数</p><p><code>&lt;rosparam command=&quot;load&quot; file=&quot;$(find package-name)/param-file&quot; /&gt;</code></p></li></ol><h1 id="8-rosservice"><a class="markdownIt-Anchor" href="#8-rosservice"></a> 8. rosservice</h1><ol><li><p>列出所有服务</p><p><code>rosservice list</code></p></li><li><p>查看某一特定节点提供的服务</p><p><code>rosnode info node-name</code></p></li><li><p>查找提供特定服务的节点</p><p><code>rosservice node service-name</code></p></li><li><p>查看服务的数据类型</p><p><code>rosservice info service-name</code></p></li><li><p>查看服务类型的详情</p><p><code>rossrv show service-data-type-name</code>(–之前是请求项，之后是响应项)</p></li><li><p>从命令行调用服务</p><p><code>rosservice call service-name request-content</code></p></li></ol><h1 id="9-rosbag"><a class="markdownIt-Anchor" href="#9-rosbag"></a> 9. rosbag</h1><ol><li><p>录制包文件</p><p><code>rosbag record -O filename.bag topic-names</code></p></li><li><p>回放包文件</p><p><code>rosbag play filename.bag</code></p></li><li><p>检查文件包</p><p><code>rosbag info filename.bag</code></p></li></ol><h1 id="10-rqt"><a class="markdownIt-Anchor" href="#10-rqt"></a> 10. rqt</h1><ol><li><p>用于显示和重放ROS bag文件的工具</p><p><code>rqt_bag</code></p></li><li><p>用于可视化ROS依赖关系图的工具</p><p><code>rqt_dep</code></p></li><li><p>使用image_transport显示图像的工具，<code>rqt_image_view</code>是<code>image_view的rqt</code>版本</p><p><code>rqt_image_view</code></p></li><li><p>画出发布在topic上的数据变化图</p><p><code>rqt_plot</code></p></li><li><p>日志输出工具</p><p><code>rqt_console</code></p></li><li><p>通过节点、节点管理器、话题、服务组成的计算图-点对点的网络形式，图形化查看相应关系</p><p><code>rqt_graph</code></p></li><li><p>用于配置ROS节点的记录器级别的工具</p><p><code>rqt_logger_level</code></p></li><li><p>提供交互式shell的Python GUI插件</p><p><code>rqt_shell</code></p></li><li><p>参数动态配置工具</p><p><code>rqt_reconfigure</code></p></li></ol><p>更多官方参考Wiki:</p><p><em><strong><a href="http://wiki.ros.org/rqt_common_plugins?distro=melodic">rqt_common_plugins</a></strong>：</em><a href="http://wiki.ros.org/rqt_action?distro=melodic">rqt_action</a> | <a href="http://wiki.ros.org/rqt_bag?distro=melodic">rqt_bag</a> | <a href="http://wiki.ros.org/rqt_bag_plugins?distro=melodic">rqt_bag_plugins</a> | <a href="http://wiki.ros.org/rqt_console?distro=melodic">rqt_console</a> | <a href="http://wiki.ros.org/rqt_dep?distro=melodic">rqt_dep</a> | <a href="http://wiki.ros.org/rqt_graph?distro=melodic">rqt_graph</a> | <a href="http://wiki.ros.org/rqt_image_view?distro=melodic">rqt_image_view</a> | <a href="http://wiki.ros.org/rqt_launch?distro=melodic">rqt_launch</a> | <a href="http://wiki.ros.org/rqt_logger_level?distro=melodic">rqt_logger_level</a> | <a href="http://wiki.ros.org/rqt_msg?distro=melodic">rqt_msg</a> | <a href="http://wiki.ros.org/rqt_plot?distro=melodic">rqt_plot</a> | <a href="http://wiki.ros.org/rqt_publisher?distro=melodic">rqt_publisher</a> | <a href="http://wiki.ros.org/rqt_py_common?distro=melodic">rqt_py_common</a> | <a href="http://wiki.ros.org/rqt_py_console?distro=melodic">rqt_py_console</a> | <a href="http://wiki.ros.org/rqt_reconfigure?distro=melodic">rqt_reconfigure</a> | <a href="http://wiki.ros.org/rqt_service_caller?distro=melodic">rqt_service_caller</a> | <a href="http://wiki.ros.org/rqt_shell?distro=melodic">rqt_shell</a> | <a href="http://wiki.ros.org/rqt_srv?distro=melodic">rqt_srv</a> | <a href="http://wiki.ros.org/rqt_top?distro=melodic">rqt_top</a> | <a href="http://wiki.ros.org/rqt_topic?distro=melodic">rqt_topic</a> | <a href="http://wiki.ros.org/rqt_web?distro=melodic">rqt_web</a></p><p>参考:<a href="https://wiki.ros.org/rqt">官方rqt wiki</a></p><p>运行rqt工具后可以在菜单里启动一些插件:</p><table><thead><tr><th>插件</th><th>功能描述</th></tr></thead><tbody><tr><td>topics monitor</td><td>可以监视当前的某一个话题的传输数据，占用带宽，话题频率等等，相当于我们原来的rostopic echo msg_name</td></tr><tr><td>message publisher</td><td>可以自定义名称发布一个话题，并且指定话题发布的消息类型，发布数据，以及发布频率</td></tr><tr><td>message type brower</td><td>可以查看当前所有已经定义的消息类型，包括自己定义的msg，基本相当于</td></tr><tr><td>robot steering</td><td>可以发布一个话题cmd_vel,发布Twist话题消息，可以可视化的修改速度，转角变量，用于测试一些控制指令十分方便</td></tr><tr><td>bag</td><td>可以用于录制一个bag文件包，可以任意选择指定录制哪些话题。也可以打开一个bag文件包，里面可以很方便的控制bag包play的播放或者暂停，同时可以指定播放前一帧和下一帧</td></tr><tr><td>node_graph(rqt_graph)</td><td>查看当前节点运行的所有节点</td></tr><tr><td>process monitor</td><td>查看当前的所有节点，以及节点的PID，占用CPU，占用内存</td></tr><tr><td>launch</td><td>可以方便的在可视化界面下选择package和launch文件， 可以方便的运行和停止launch一个节点</td></tr><tr><td>image view</td><td>可以很方便的查看ROS话题中传递的图片消息，这一点方便于我们观察机器人当前看到的图像</td></tr><tr><td>plot</td><td>可以将某一个话题的数据(全部数据或部分数据)进行绘图显示，这样可以更加直观看到话题消息的变化，方便于我们调试</td></tr><tr><td>tf tree</td><td>可以显示当前的tf树的结构</td></tr><tr><td>rviz</td><td>在rqt里面也集成了rviz工具，我们可以很方便的从这里打开rviz工具</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS通信框架</title>
      <link href="/posts/8ae22c6d.html"/>
      <url>/posts/8ae22c6d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-node"><a class="markdownIt-Anchor" href="#1-node"></a> 1. Node</h1><p>在ROS的世界里，<strong>最小的进程单元</strong>就是节点（node）。一个软件包里可以有多个可执行文件，可执行文件在运行之后就成了一个进程(process)，这个进程在ROS中就叫做<strong>节点</strong>。 从程序角度来说，node就是一个可执行文件（通常为C++编译生成的可执行文件、Python脚本）被执行，加载到了内存之中；从功能角度来说，通常一个node负责者机器人的某一个单独的功能。由于机器人的功能模块非常复杂，我们往往不会把所有功能都集中到一个node上，而会采用分布式的方式，把鸡蛋放到不同的篮子里。例如有一个node来控制底盘轮子的运动，有一个node驱动摄像头获取图像，有一个node驱动激光雷达，有一个node根据传感器信息进行路径规划……<strong>这样做可以降低程序发生崩溃的可能性，试想一下如果把所有功能都写到一个程序中，模块间的通信、异常处理将会很麻烦。</strong></p><h1 id="2-master"><a class="markdownIt-Anchor" href="#2-master"></a> 2. Master</h1><p>由于机器人的元器件很多，功能庞大，因此实际运行时往往会运行众多的node，负责感知世界、控制运动、决策和计算等功能。那么如何合理的进行调配、管理这些node？这就要利用ROS提供给我们的节点管理器master, master在整个网络通信架构里相当于管理中心，管理着各个node。<strong>node首先在master处进行注册，之后master会将该node纳入整个ROS程序中。<strong>node之间的通信也是</strong>先由master进行“牵线”</strong>，才能两两的进行点对点通信。当ROS程序启动时，第一步首先启动master，由节点管理器处理依次启动node。</p><h1 id="3-启动master和node"><a class="markdownIt-Anchor" href="#3-启动master和node"></a> 3. 启动master和node</h1><p>当我们要启动ROS时，首先输入命令:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roscore</span><br></pre></td></tr></table></figure><p>此时ROS master启动，同时启动的还有**<code>rosout</code><strong>和</strong><code>parameter server</code><strong>,其中<code>rosout</code>是</strong>负责日志输出的一个节点**，其作用是告知用户当前系统的状态，包括输出系统的error、warning等等，并且将log记录于日志文件中，<code>parameter server</code>即是<strong>参数服务器</strong>，它并不是一个node，<strong>而是存储参数配置的一个服务器</strong>，后文我们会单独介绍。每一次我们运行ROS的节点前，都需要把master启动起来，这样才能够让节点启动和注册。</p><p>master之后，节点管理器就开始按照系统的安排协调进行启动具体的节点。节点就是一个进程，只不过在ROS中它被赋予了专用的名字里——node。在第二章我们介绍了ROS的文件系统，我们知道一个package中存放着可执行文件，可执行文件是静态的，当系统执行这些可执行文件，将这些文件加载到内存中，它就成为了<strong>动态的node</strong>。具体启动node的语句是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun pkg_name node_name</span><br></pre></td></tr></table></figure><p>通常我们运行ROS，就是按照这样的顺序启动，有时候节点太多，我们会选择用launch文件来启动，下一小节会有介绍。 Master、Node之间以及Node之间的关系如下图所示：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/masterandnode.png" alt="img" /></p><h1 id="4-rosrun和rosnode命令"><a class="markdownIt-Anchor" href="#4-rosrun和rosnode命令"></a> 4. rosrun和rosnode命令</h1><p><strong>rosrun命令的详细用法如下</strong>：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun [--prefix cmd] [--debug] pkg_name node_name [ARGS]</span><br></pre></td></tr></table></figure><p>rosrun将会寻找PACKAGE下的名为EXECUTABLE的可执行程序，将可选参数ARGS传入。 例如在GDB下运行ros程序：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun --prefix &#x27;gdb -ex run --args&#x27; pkg_name node_name</span><br></pre></td></tr></table></figure><p><strong>rosnode命令的详细作用列表如下</strong>：</p><table><thead><tr><th style="text-align:center">rosnode命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosnode list</code></td><td style="text-align:center">列出当前运行的node信息</td></tr><tr><td style="text-align:center"><code>rosnode info node_name</code></td><td style="text-align:center">显示出node的详细信息</td></tr><tr><td style="text-align:center"><code>rosnode kill node_name</code></td><td style="text-align:center">结束某个node</td></tr><tr><td style="text-align:center"><code>rosnode ping</code></td><td style="text-align:center">测试连接节点</td></tr><tr><td style="text-align:center"><code>rosnode machine</code></td><td style="text-align:center">列出在特定机器或列表机器上运行的节点</td></tr><tr><td style="text-align:center"><code>rosnode cleanup</code></td><td style="text-align:center">清除不可到达节点的注册信息</td></tr></tbody></table><p>以上命令中常用的为前三个，在开发调试时经常会需要查看当前node以及node信息，所以请记住这些常用命令。如果你想不起来，也可以通过<code>rosnode help</code>来查看<code>rosnode</code>命令的用法。</p><h1 id="5-launch文件"><a class="markdownIt-Anchor" href="#5-launch文件"></a> 5. launch文件</h1><h2 id="51-简介"><a class="markdownIt-Anchor" href="#51-简介"></a> 5.1. 简介</h2><p>机器人是一个系统工程，通常一个机器人运行操作时要开启很多个node，对于一个复杂的机器人的启动操作应该怎么做呢？当然，我们并不需要每个节点依次进行rosrun，ROS为我们提供了一个命令能一次性启动master和多个node。该命令是：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ roslaunch pkg_name file_name.launch</span><br></pre></td></tr></table></figure><p><strong>roslaunch命令首先会自动进行检测系统的roscore有没有运行</strong>，也即是确认节点管理器是否在运行状态中，如果master没有启动，那么roslaunch就会首先启动master，然后再按照launch的规则执行。launch文件里已经配置好了启动的规则。 所以<code>roslaunch</code>就像是一个<strong>启动工具</strong>，能够一次性把多个节点按照我们预先的配置启动起来，减少我们在终端中一条条输入指令的麻烦。</p><h2 id="52-写法与格式"><a class="markdownIt-Anchor" href="#52-写法与格式"></a> 5.2. 写法与格式</h2><p>launch文件同样也遵循着xml格式规范，是一种标签文本，它的格式包括以下标签：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span>    <span class="comment">&lt;!--根标签--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span>&gt;</span>    <span class="comment">&lt;!--需要启动的node及其参数--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span>&gt;</span>    <span class="comment">&lt;!--包含其他launch--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">machine</span>&gt;</span>    <span class="comment">&lt;!--指定运行的机器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">env-loader</span>&gt;</span>    <span class="comment">&lt;!--设置环境变量--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span>&gt;</span>    <span class="comment">&lt;!--定义参数到参数服务器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">rosparam</span>&gt;</span>    <span class="comment">&lt;!--启动yaml文件参数到参数服务器--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span>&gt;</span>    <span class="comment">&lt;!--定义变量--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">remap</span>&gt;</span>    <span class="comment">&lt;!--设定参数映射--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">group</span>&gt;</span>    <span class="comment">&lt;!--设定命名空间--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span>    <span class="comment">&lt;!--根标签--&gt;</span></span><br></pre></td></tr></table></figure><p>参考链接:<a href="http://wiki.ros.org/roslaunch/XML">http://wiki.ros.org/roslaunch/XML</a></p><h2 id="53-示例"><a class="markdownIt-Anchor" href="#53-示例"></a> 5.3. 示例</h2><p>launch文件的写法和格式看起来内容比较复杂，我们先来介绍一个最简单的例子如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;talker&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;rospy_tutorials&quot;</span> <span class="attr">type</span>=<span class="string">&quot;talker&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这是官网给出的一个最小的例子，文本中的信息是，它启动了一个单独的节点<code>talker</code>,该节点是包<code>rospy_tutorials</code>软件包中的节点。</p><p>然而实际中的launch文件要复杂很多，我们以<code>Ros-Academy-for-Beginners</code>中的<code>robot_sim_demo</code>为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!--arg是launch标签中的变量声明，arg的name为变量名，default或者value为值--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;robot&quot;</span> <span class="attr">default</span>=<span class="string">&quot;xbot2&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">default</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">default</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Start Gazebo with a blank world --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find gazebo_ros)/launch/empty_world.launch&quot;</span>&gt;</span> <span class="comment">&lt;!--include用来嵌套仿真场景的launch文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;world_name&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(find robot_sim_demo)/worlds/ROS-Academy.world&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;debug&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg debug)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;gui&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg gui)&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;paused&quot;</span> <span class="attr">value</span>=<span class="string">&quot;false&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;use_sim_time&quot;</span> <span class="attr">value</span>=<span class="string">&quot;true&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">arg</span> <span class="attr">name</span>=<span class="string">&quot;headless&quot;</span> <span class="attr">value</span>=<span class="string">&quot;$(arg headless)&quot;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- Oh, you wanted a robot? --&gt;</span> <span class="comment">&lt;!--嵌套了机器人的launch文件--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">file</span>=<span class="string">&quot;$(find robot_sim_demo)/launch/include/$(arg robot).launch.xml&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--如果你想连同RViz一起启动，可以按照以下方式加入RViz这个node--&gt;</span></span><br><span class="line"><span class="comment">&lt;!--node name=&quot;rviz&quot; pkg=&quot;rviz&quot; type=&quot;rviz&quot; args=&quot;-d $(find robot_sim_demo)/urdf_gazebo.rviz&quot; /--&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这个launch文件相比上一个简单的例子来说，内容稍微有些复杂，它的作用是：启动gazebo模拟器，导入参数内容，加入机器人模型。</p><h2 id="54-小结"><a class="markdownIt-Anchor" href="#54-小结"></a> 5.4. 小结</h2><p>对于初学者，我们不要求掌握每一个标签是什么作用，但至少应该有一个印象。如果我们要进行自己写launch文件，可以先从改launch文件的模板入手，基本可以满足普通项目的要求。</p><h1 id="6-topic"><a class="markdownIt-Anchor" href="#6-topic"></a> 6. Topic</h1><h2 id="61-简介"><a class="markdownIt-Anchor" href="#61-简介"></a> 6.1. 简介</h2><p>ROS的通信方式是ROS最为核心的概念，ROS系统的精髓就在于它提供的通信架构。ROS的通信方式有以下四种：</p><ul><li>Topic 主题</li><li>Service 服务</li><li>Parameter Service 参数服务器</li><li>Actionlib 动作库</li></ul><h2 id="62-topic"><a class="markdownIt-Anchor" href="#62-topic"></a> 6.2. Topic</h2><p>ROS中的通信方式中，topic是常用的一种。对于<strong>实时性、周期性</strong>的消息，使用topic来传输是最佳的选择。topic是一种<strong>点对点的单向通信方式</strong>，这里的“点”指的是node，也就是说node之间可以通过topic方式来传递信息。topic要经历下面几步的初始化过程：首先，publisher节点和subscriber节点都要到节点管理器进行注册，然后publisher会发布topic，subscriber在master的指挥下会订阅该topic，从而建立起sub-pub之间的通信。**注意整个过程是单向的。**其结构示意图如下：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/topic-stru.jpg" alt="img" /></p><p>Subscriber接收消息会进行处理，一般这个过程叫做<strong>回调(Callback)</strong>。所谓回调就是<strong>提前定义好了一个处理函数（写在代码中），当有消息来就会触发这个处理函数，函数会对消息进行处理。</strong></p><p>上图就是ROS的topic通信方式的流程示意图。topic通信属于一种异步的通信方式。下面我们通过一个示例来了解下如何使用topic通信。</p><h2 id="63-通信示例"><a class="markdownIt-Anchor" href="#63-通信示例"></a> 6.3. 通信示例</h2><p>参考下图，我们以摄像头画面的发布、处理、显示为例讲讲topic通信的流程。在机器人上的摄像头拍摄程序是一个node（圆圈表示,我们记作node1），当node1运行启动之后，它作为一个Publisher就开始发布topic。比如它发布了一个topic（方框表示），叫做<code>/camera_rgb</code>，是rgb颜色信息，即采集到的彩色图像。同时，node2假如是图像处理程序,它订阅了<code>/camera_rgb</code>这个topic，经过节点管理器的介绍，它就能建立和摄像头节点（node1）的连接。</p><p>那么怎么样来理解**“异步”**这个概念呢？在node1每发布一次消息之后，就会继续执行下一个动作，至于消息是什么状态、被怎样处理，它不需要了解；而对于node2图像处理程序，它只管接收和处理<code>/camera_rgb</code>上的消息，至于是谁发来的，它不会关心。所以node1、node2两者都是各司其责，<strong>不存在协同工作</strong>，我们称这样的通信方式是异步的。</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/ex-camera.jpg" alt="img" /></p><p>ROS是一种分布式的架构，**一个topic可以被多个节点同时发布，也可以同时被多个节点接收。**比如在这个场景中用户可以再加入一个图像显示的节点，我们在想看看摄像头节点的画面，则可以用自己的笔记本连接到机器人上的节点管理器，然后在自己的电脑上启动图像显示节点。</p><p>这就体现了分布式系统通信的好处：扩展性好、软件复用率高。</p><p><strong>总结三点</strong>：</p><ol><li>topic通信方式是异步的，<strong>发送时调用publish()方法，发送完成立即返回，不用等待反馈。</strong></li><li>subscriber通过回调函数的方式来处理消息。</li><li>topic可以同时有多个subscribers，也可以同时有多个publishers。ROS中这样的例子有：/rosout、/tf等等。</li></ol><h2 id="64-操作命令"><a class="markdownIt-Anchor" href="#64-操作命令"></a> 6.4. 操作命令</h2><p>在实际应用中，我们应该熟悉topic的几种使用命令，下表详细的列出了各自的命令及其作用。</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rostopic list</code></td><td style="text-align:center">列出当前所有的topic</td></tr><tr><td style="text-align:center"><code>rostopic info topic_name</code></td><td style="text-align:center">显示某个topic的属性信息</td></tr><tr><td style="text-align:center"><code>rostopic echo topic_name</code></td><td style="text-align:center">显示某个topic的内容</td></tr><tr><td style="text-align:center"><code>rostopic pub topic_name ...</code></td><td style="text-align:center">向某个topic发布内容</td></tr><tr><td style="text-align:center"><code>rostopic bw topic_name</code></td><td style="text-align:center">查看某个topic的带宽</td></tr><tr><td style="text-align:center"><code>rostopic hz topic_name</code></td><td style="text-align:center">查看某个topic的频率</td></tr><tr><td style="text-align:center"><code>rostopic find topic_type</code></td><td style="text-align:center">查找某个类型的topic</td></tr><tr><td style="text-align:center"><code>rostopic type topic_name</code></td><td style="text-align:center">查看某个topic的类型(msg)</td></tr></tbody></table><p>如果你一时忘记了命令的写法，可以通过<code>rostopic help</code>或<code>rostopic command -h</code>查看具体用法。</p><h2 id="65-测试实例"><a class="markdownIt-Anchor" href="#65-测试实例"></a> 6.5. 测试实例</h2><ol><li>首先打开<code>ROS-Academy-for-Beginners</code>的模拟场景，输入<code>roslaunch robot_sim_demo robot_spawn_launch</code>,看到我们仿真的模拟环境。该<code>launch</code>文件启动了模拟场景、机器人。</li><li>查看当前模拟器中存在的topic，输入命令<code>rostopic list</code>。可以看到许多topic，它们可以视为模拟器与外界交互的接口。</li><li>查询topic<code>/camera/rgb/image_raw</code>的相关信息：<code>rostopic info /camera/rgb/image_raw</code>。则会显示类型信息type，发布者和订阅者的信息。</li><li>上步我们在演示中可以得知，并没有订阅者订阅该主题，我们指定<code>image_view</code>来接收这个消息，运行命令<code>rosrun image_view image_view image:= [transport]</code>。我们可以看到message，即是上一步中的type。</li><li>同理我们可以查询摄像头的深度信息depth图像。</li><li>在用键盘控制仿真机器人运动的时候，我们可以查看速度指令topic的内容<code>rostopic echo /cmd_vel</code> ，可以看到窗口显示的各种坐标参数在不断的变化。</li></ol><p>通过这些实例的测试，帮助我们更快的掌握topic各种操作命令的使用，以及对topic通信的理解。</p><h2 id="66-小结"><a class="markdownIt-Anchor" href="#66-小结"></a> 6.6. 小结</h2><p>topic的通信方式是ROS中比较常见的单向异步通信方式，它在很多时候的通信是比较易用且高效的。但是有些需要交互的通信时该方式就显露出自己的不足之处了，后续我们会介绍双向同步的通信方式service。</p><h1 id="7-message"><a class="markdownIt-Anchor" href="#7-message"></a> 7. Message</h1><h2 id="71-简介"><a class="markdownIt-Anchor" href="#71-简介"></a> 7.1. 简介</h2><p>topic有很严格的格式要求，比如上节的摄像头进程中的rgb图像topic，它就必然要遵循ROS中定义好的rgb图像格式。这种数据格式就是Message。**Message按照定义解释就是topic内容的数据类型，也称之为topic的格式标准。**这里和我们平常用到的Massage直观概念有所不同，这里的Message不单单指一条发布或者订阅的消息，也指定为topic的格式标准。</p><h2 id="72-结构与类型"><a class="markdownIt-Anchor" href="#72-结构与类型"></a> 7.2. 结构与类型</h2><p>基本的msg包括**bool、int8、int16、int32、int64(以及uint)、float、float64、string、time、duration、header、可变长数组array[]、固定长度数组array[C]。**那么具体的一个msg是怎么组成的呢？我们用一个具体的msg来了解，例如上例中的msg <code>sensor_msg/image</code>,位置存放在<code>sensor_msgs/msg/image.msg</code>里,它的结构如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">std_msg/Header header</span><br><span class="line">    uint32    seq</span><br><span class="line">    time    stamp</span><br><span class="line">    string    frame_id</span><br><span class="line">uint32    height</span><br><span class="line">uint32    width</span><br><span class="line">string    encoding</span><br><span class="line">uint8    is_bigendian</span><br><span class="line">uint32    step</span><br><span class="line">uint8[]    data</span><br></pre></td></tr></table></figure><p>观察上面msg的定义，**是不是很类似C语言中的结构体呢？**通过具体的定义图像的宽度，高度等等来规范图像的格式。所以这就解释了Message不仅仅是我们平时理解的一条一条的消息，而且更是ROS中topic的格式规范。或者可以理解msg是一个“类”，那么我们每次发布的内容可以理解为“对象”，这么对比来理解可能更加容易。 我们实际通常不会把Message概念分的那么清，**通常说Message既指的是类，也是指它的对象。**而msg文件则相当于类的定义了。</p><h2 id="73-操作命令"><a class="markdownIt-Anchor" href="#73-操作命令"></a> 7.3. 操作命令</h2><p>rosmsg的命令相比topic就比较少了，只有两个如下：</p><table><thead><tr><th style="text-align:center">rosmsg命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosmsg list</code></td><td style="text-align:center">列出系统上所有的msg</td></tr><tr><td style="text-align:center"><code>rosmsg show msg_name</code></td><td style="text-align:center">显示某个msg的内容</td></tr></tbody></table><h2 id="74-常见message"><a class="markdownIt-Anchor" href="#74-常见message"></a> 7.4. 常见message</h2><p>我们看看常见的message类型，包括std_msgs, sensor_msgs, nav_msgs, geometry_msgs等</p><p><strong>Vector3.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:geometry_msgs/Vector3.msg</span><br><span class="line"></span><br><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 z</span><br></pre></td></tr></table></figure><p><strong>Accel.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#定义加速度项，包括线性加速度和角加速度</span><br><span class="line">#文件位置:geometry_msgs/Accel.msg</span><br><span class="line">Vector3 linear</span><br><span class="line">Vector3 angular</span><br></pre></td></tr></table></figure><p><strong>Header.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#定义数据的参考时间和参考坐标</span><br><span class="line">#文件位置:std_msgs/Header.msg</span><br><span class="line">uint32 seq      #数据ID</span><br><span class="line">time stamp      #数据时间戳</span><br><span class="line">string frame_id #数据的参考坐标系</span><br></pre></td></tr></table></figure><p><strong>Echos.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#定义超声传感器</span><br><span class="line">#文件位置:自定义msg文件</span><br><span class="line">Header header</span><br><span class="line">uint16 front_left</span><br><span class="line">uint16 front_center</span><br><span class="line">uint16 front_right</span><br><span class="line">uint16 rear_left</span><br><span class="line">uint16 rear_center</span><br><span class="line">uint16 rear_right</span><br></pre></td></tr></table></figure><p><strong>Quaternion.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#消息代表空间中旋转的四元数</span><br><span class="line">#文件位置:geometry_msgs/Quaternion.msg</span><br><span class="line"></span><br><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 z</span><br><span class="line">float64 w</span><br></pre></td></tr></table></figure><p><strong>Imu.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#消息包含了从惯性原件中得到的数据，加速度为m/^2，角速度为rad/s</span><br><span class="line">#如果所有的测量协方差已知，则需要全部填充进来如果只知道方差，则</span><br><span class="line">#只填充协方差矩阵的对角数据即可</span><br><span class="line">#位置：sensor_msgs/Imu.msg</span><br><span class="line"></span><br><span class="line">Header header</span><br><span class="line">Quaternion orientation</span><br><span class="line">float64[9] orientation_covariance</span><br><span class="line">Vector3 angular_velocity</span><br><span class="line">float64[9] angular_velocity_covariance</span><br><span class="line">Vector3 linear_acceleration</span><br><span class="line">float64[] linear_acceleration_covariance</span><br></pre></td></tr></table></figure><p><strong>LaserScan.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#平面内的激光测距扫描数据，注意此消息类型仅仅适配激光测距设备</span><br><span class="line">#如果有其他类型的测距设备(如声呐)，需要另外创建不同类型的消息</span><br><span class="line">#位置：sensor_msgs/LaserScan.msg</span><br><span class="line"></span><br><span class="line">Header header            #时间戳为接收到第一束激光的时间</span><br><span class="line">float32 angle_min        #扫描开始时的角度(单位为rad)</span><br><span class="line">float32 angle_max        #扫描结束时的角度(单位为rad)</span><br><span class="line">float32 angle_increment    #两次测量之间的角度增量(单位为rad)</span><br><span class="line">float32 time_increment    #两次测量之间的时间增量(单位为s)</span><br><span class="line">float32 scan_time        #两次扫描之间的时间间隔(单位为s)</span><br><span class="line">float32 range_min        #距离最小值(m)</span><br><span class="line">float32 range_max        #距离最大值(m)</span><br><span class="line">float32[] ranges        #测距数据(m,如果数据不在最小数据和最大数据之间，则抛弃)</span><br><span class="line">float32[] intensities    #强度，具体单位由测量设备确定，如果仪器没有强度测量，则数组为空即可</span><br></pre></td></tr></table></figure><p><strong>Point.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#空间中的点的位置</span><br><span class="line">#文件位置:geometry_msgs/Point.msg</span><br><span class="line"></span><br><span class="line">float64 x</span><br><span class="line">float64 y</span><br><span class="line">float64 z</span><br></pre></td></tr></table></figure><p><strong>Pose.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#消息定义自由空间中的位姿信息，包括位置和指向信息</span><br><span class="line">#文件位置:geometry_msgs/Pose.msg</span><br><span class="line"></span><br><span class="line">Point position</span><br><span class="line">Quaternion orientation</span><br></pre></td></tr></table></figure><p><strong>PoseStamped.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#定义有时空基准的位姿</span><br><span class="line">#文件位置：geometry_msgs/PoseStamped.msg</span><br><span class="line"></span><br><span class="line">Header header</span><br><span class="line">Pose pose</span><br></pre></td></tr></table></figure><p><strong>PoseWithCovariance.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#表示空间中含有不确定性的位姿信息</span><br><span class="line">#文件位置：geometry_msgs/PoseWithCovariance.msg</span><br><span class="line"></span><br><span class="line">Pose pose</span><br><span class="line">float64[36] covariance</span><br></pre></td></tr></table></figure><p><strong>Power.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#表示电源状态，是否开启</span><br><span class="line">#文件位置：自定义msg文件</span><br><span class="line">Header header</span><br><span class="line">bool power</span><br><span class="line">######################</span><br><span class="line">bool ON  = 1</span><br><span class="line">bool OFF = 0</span><br></pre></td></tr></table></figure><p><strong>Twist.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#定义空间中物体运动的线速度和角速度</span><br><span class="line">#文件位置：geometry_msgs/Twist.msg</span><br><span class="line"></span><br><span class="line">Vector3 linear</span><br><span class="line">Vector3 angular</span><br></pre></td></tr></table></figure><p><strong>TwistWithCovariance.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">#消息定义了包含不确定性的速度量，协方差矩阵按行分别表示：</span><br><span class="line">#沿x方向速度的不确定性，沿y方向速度的不确定性，沿z方向速度的不确定性</span><br><span class="line">#绕x转动角速度的不确定性，绕y轴转动的角速度的不确定性，绕z轴转动的</span><br><span class="line">#角速度的不确定性</span><br><span class="line">#文件位置：geometry_msgs/TwistWithCovariance.msg</span><br><span class="line"></span><br><span class="line">Twist twist</span><br><span class="line">float64[36] covariance  #分别表示[x; y; z; Rx; Ry; Rz]</span><br></pre></td></tr></table></figure><p><strong>Odometry.msg</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#消息描述了自由空间中位置和速度的估计值</span><br><span class="line">#文件位置：nav_msgs/Odometry.msg</span><br><span class="line"></span><br><span class="line">Header header</span><br><span class="line">string child_frame_id</span><br><span class="line">PoseWithCovariance pose</span><br><span class="line">TwistWithCovariance twist</span><br></pre></td></tr></table></figure><h1 id="8-service"><a class="markdownIt-Anchor" href="#8-service"></a> 8. Service</h1><h2 id="81-service"><a class="markdownIt-Anchor" href="#81-service"></a> 8.1. Service</h2><p>我们介绍了ROS的通信方式中的topic(主题)通信，我们知道topic是ROS中的一种单向的异步通信方式。然而有些时候单向的通信满足不了通信要求，比如<strong>当一些节点只是临时而非周期性的需要某些数据</strong>，如果用topic通信方式时就会消耗大量不必要的系统资源，造成系统的低效率高功耗。<br />这种情况下，**就需要有另外一种请求-查询式的通信模型。**这节我们来介绍ROS通信中的另一种通信方式——service(服务)。</p><h2 id="82-工作原理"><a class="markdownIt-Anchor" href="#82-工作原理"></a> 8.2. 工作原理</h2><h3 id="821-简介"><a class="markdownIt-Anchor" href="#821-简介"></a> 8.2.1. 简介</h3><p>为了解决以上问题，service方式在通信模型上与topic做了区别。<strong>Service通信是双向的，它不仅可以发送消息，同时还会有反馈。<strong>所以service包括两部分，一部分是请求方（Clinet），另一部分是应答方/服务提供方（Server）。这时请求方（Client）就会发送一个request，要等待server处理，反馈回一个reply，这</strong>样通过类似“请求-应答”的机制完成整个服务通信。</strong></p><p>这种通信方式的示意图如下：<br />Node B是server（应答方），提供了一个服务的接口，叫做<code>/Service</code>，我们一般都会用string类型来指定service的名称，类似于topic。Node A向Node B发起了请求，经过处理后得到了反馈。<br /><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/service_structure.png" alt="img" /></p><h3 id="822-过程"><a class="markdownIt-Anchor" href="#822-过程"></a> 8.2.2. 过程</h3><p>Service是同步通信方式，所谓同步就是说，此时Node A发布请求后会在原地等待reply，直到Node B处理完了请求并且完成了reply，Node A才会继续执行。**Node A等待过程中，是处于阻塞状态的成通信。**这样的通信模型没有频繁的消息传递，<strong>没有冲突与高系统资源的占用，只有接受请求才执行服务，简单而且高效。</strong></p><h2 id="83-topic-vs-service"><a class="markdownIt-Anchor" href="#83-topic-vs-service"></a> 8.3. topic VS service</h2><p>我们对比一下这两种最常用的通信方式，加深我们对两者的理解和认识，具体见下表：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">Topic</th><th style="text-align:center">Service</th></tr></thead><tbody><tr><td style="text-align:center">通信方式</td><td style="text-align:center">异步通信</td><td style="text-align:center">同步通信</td></tr><tr><td style="text-align:center">实现原理</td><td style="text-align:center">TCP/IP</td><td style="text-align:center">TCP/IP</td></tr><tr><td style="text-align:center">通信模型</td><td style="text-align:center">Publish-Subscribe</td><td style="text-align:center">Request-Reply</td></tr><tr><td style="text-align:center">映射关系</td><td style="text-align:center">Publish-Subscribe(多对多)</td><td style="text-align:center">Request-Reply（多对一）</td></tr><tr><td style="text-align:center">特点</td><td style="text-align:center">接受者收到数据会回调（Callback）</td><td style="text-align:center">远程过程调用（RPC）服务器端的服务</td></tr><tr><td style="text-align:center">应用场景</td><td style="text-align:center">连续、高频的数据发布</td><td style="text-align:center">偶尔使用的功能/具体的任务</td></tr><tr><td style="text-align:center">举例</td><td style="text-align:center">激光雷达、里程计发布数据</td><td style="text-align:center">开关传感器、拍照、逆解计算</td></tr></tbody></table><p>**注意：**远程过程调用(Remote Procedure Call，RPC),可以简单通俗的理解为在一个进程里调用另一个进程的函数。</p><h2 id="84-操作命令"><a class="markdownIt-Anchor" href="#84-操作命令"></a> 8.4. 操作命令</h2><p>在实际应用中，service通信方式的命令<code>rosservice</code>，具体的命令参数如下表：</p><table><thead><tr><th style="text-align:center">rosservice 命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosservice list</code></td><td style="text-align:center">显示服务列表</td></tr><tr><td style="text-align:center"><code>rosservice info</code></td><td style="text-align:center">打印服务信息</td></tr><tr><td style="text-align:center"><code>rosservice type</code></td><td style="text-align:center">打印服务类型</td></tr><tr><td style="text-align:center"><code>rosservice uri</code></td><td style="text-align:center">打印服务ROSRPC uri</td></tr><tr><td style="text-align:center"><code>rosservice find</code></td><td style="text-align:center">按服务类型查找服务</td></tr><tr><td style="text-align:center"><code>rosservice call</code></td><td style="text-align:center">使用所提供的args调用服务</td></tr><tr><td style="text-align:center"><code>rosservice args</code></td><td style="text-align:center">打印服务参数</td></tr></tbody></table><h2 id="85-测试实例"><a class="markdownIt-Anchor" href="#85-测试实例"></a> 8.5. 测试实例</h2><ol><li>首先依然是打开我们教材的模拟场景<code>roslaunch robot_sim_demo robot_spawn.launch</code>。</li><li>输入<code>rosservice list</code>，查看当前运行的服务。</li><li>随机选择<code>/gazebo/delete_light</code>服务，观察名称，是删除光源的操作。</li><li>输入<code>rosservice info /gazebo/delete_light</code>查看属性信息。可以看到信息，Node：/gazebo，Type：gazebo_msgs/DeleteLight, Args：Light_name。这里的类型type也就是下文介绍的srv,传递参数Light_name</li><li>输入<code>rosservice call /gazebo/delete_light sun</code>,这里的sun 是参数名，使我们模拟场景中的唯一光源太阳。操作完成后可以看到场景中的光线消失。</li><li>可以看到终端的回传信息：success: True和sun successfully deleted。这就是双向通信的信息反馈，通知操作已经成功完成。</li></ol><h2 id="86-小结"><a class="markdownIt-Anchor" href="#86-小结"></a> 8.6. 小结</h2><p>本节我们详细介绍了service通信方式，建议与topic通信方式进行对比记忆，这样我们能更深的理解这两种通信方式，也能在以后的学习工作中更加合理使用每个通信方式，获得更高的效率。</p><h1 id="9-srv"><a class="markdownIt-Anchor" href="#9-srv"></a> 9. Srv</h1><h2 id="91-简介"><a class="markdownIt-Anchor" href="#91-简介"></a> 9.1. 简介</h2><p>类似msg文件，srv文件是用来描述service服务的文件 (service的数据类型，service通信的数据格式定义在*.srv中) 它声明了一个服务，包括请求 (<strong>request</strong>) 和响应 (<strong>reply</strong>) 两部分。其格式声明如下：</p><p><strong>举例：</strong></p><p>msgs_demo/srv/DetectHuman.srv</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">bool start_detect</span><br><span class="line">---</span><br><span class="line">my_pkg/HumanPose[] pose_data</span><br></pre></td></tr></table></figure><p>msgs_demo/msg/HumanPose.msg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">std_msgs/Header header</span><br><span class="line">string uuid</span><br><span class="line">int32 number_of_joints</span><br><span class="line">my_pkg/JointPose[]joint_data</span><br></pre></td></tr></table></figure><p>msgs_demo/msg/JointPose.msg</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string joint_name</span><br><span class="line">geometry_msgs/Pose pose</span><br><span class="line">floar32 confidence</span><br></pre></td></tr></table></figure><p>以<code>DetectHUman.srv</code>文件为例，该服务例子取自OpenNI的人体检测ROS软件包。它是用来查询当前深度摄像头中的人体姿态和关节数的。srv文件格式很固定，<strong>第一行是请求的格式</strong>，中间用**—**隔开，<strong>第三行是应答的格式</strong>。在本例中，请求为是否开始检测，应答为一个数组，数组的每个元素为某个人的姿态（HumanPose）。而对于人的姿态，其实是一个msg，<strong>所以srv可以嵌套msg在其中，但它不能嵌套srv。</strong></p><h2 id="92-操作命令"><a class="markdownIt-Anchor" href="#92-操作命令"></a> 9.2. 操作命令</h2><p>具体的操作指令如下表：</p><table><thead><tr><th style="text-align:center">rossrv 命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rossrv show</code></td><td style="text-align:center">显示服务描述</td></tr><tr><td style="text-align:center"><code>rossrv list</code></td><td style="text-align:center">列出所有服务</td></tr><tr><td style="text-align:center"><code>rossrv md5</code></td><td style="text-align:center">显示服务md5sum</td></tr><tr><td style="text-align:center"><code>rossrv package</code></td><td style="text-align:center">列出包中的服务</td></tr><tr><td style="text-align:center"><code>rossrv packages</code></td><td style="text-align:center">列出包含服务的包</td></tr></tbody></table><h2 id="93-修改部分文件"><a class="markdownIt-Anchor" href="#93-修改部分文件"></a> 9.3. 修改部分文件</h2><p>定义完了msg、srv文件，还有重要的一个步骤就是修改package.xml和修改CMakeList.txt。这些文件需要添加一些必要的依赖等，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;build_depend&gt;** message_generation **&lt;/build_depend&gt;</span><br><span class="line">&lt;run_depend&gt;** message_runtime **&lt;/run_depend&gt;</span><br></pre></td></tr></table></figure><p>上述文本中“**”所引就是新添加的依赖。又例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">find_package(...roscpp rospy std_msgs ** message_generation **)</span><br><span class="line">catkin_package(</span><br><span class="line">...</span><br><span class="line">CATJIN_DEPENDS ** message_runtime ** ...</span><br><span class="line">...)</span><br><span class="line"></span><br><span class="line">add_message_file(</span><br><span class="line">FILES</span><br><span class="line">** DetectHuman.srv **</span><br><span class="line">** HumanPose.msg **</span><br><span class="line">** JointPos.msg **)</span><br><span class="line"></span><br><span class="line">** generate_messages(DEPENDENCIES std_msgs) **</span><br></pre></td></tr></table></figure><p>**添加的这些内容指定了srv或者msg在编译或者运行中需要的依赖。**具体的作用我们初学者可不深究，我们需要了解的是，<strong>无论我们自定义了srv,还是msg，修改上述部分添加依赖都是必不可少的一步。</strong></p><h1 id="10-parameter-server"><a class="markdownIt-Anchor" href="#10-parameter-server"></a> 10. Parameter server</h1><h2 id="101-简介"><a class="markdownIt-Anchor" href="#101-简介"></a> 10.1. 简介</h2><p>前文介绍了ROS中常见的两种通信方式——主题和服务，这节介绍另外一种通信方式——参数服务器（parameter server）。与前两种通信方式不同，参数服务器也可以说是特殊的“通信方式”。<strong>特殊点在于参数服务器是节点存储参数的地方、用于配置参数，全局共享参数。参数服务器使用互联网传输，在节点管理器中运行，实现整个通信过程。</strong></p><p>参数服务器，作为ROS中另外一种数据传输方式，有别于topic和service，<strong>它更加的静态。<strong>参数服务器维护着一个</strong>数据字典，字典里存储着各种参数和配置。</strong></p><h3 id="1011-字典简介"><a class="markdownIt-Anchor" href="#1011-字典简介"></a> 10.1.1. 字典简介</h3><p>何为字典，其实就是<strong>一个个的键值对</strong>，我们小时候学习语文的时候，常常都会有一本字典，当遇到不认识的字了我们可以查部首查到这个字，获取这个字的读音、意义等等，而这里的字典可以对比理解记忆。键值kay可以理解为语文里的“部首”这个概念，每一个key都是唯一的，参照下图：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/dictionaries%20_kay.png" alt="img" /></p><p>每一个key不重复，且每一个key对应着一个value。<strong>也可以说字典就是一种映射关系</strong>，在实际的项目应用中，<strong>因为字典的这种静态的映射特点，我们往往将一些不常用到的参数和配置放入参数服务器里的字典里，这样对这些数据进行读写都将方便高效。</strong></p><h3 id="1012-维护方式"><a class="markdownIt-Anchor" href="#1012-维护方式"></a> 10.1.2. 维护方式</h3><p>参数服务器的维护方式非常的简单灵活，总的来讲有<strong>三种方式</strong>：</p><ul><li>命令行维护</li><li>launch文件内读写</li><li>node源码</li></ul><p>下面我们来一一介绍这三种维护方式。</p><h2 id="102-命令行维护"><a class="markdownIt-Anchor" href="#102-命令行维护"></a> 10.2. 命令行维护</h2><p>使用命令行来维护参数服务器，主要使用<code>rosparam</code>语句来进行操作的各种命令，如下表：</p><table><thead><tr><th style="text-align:center">rosparam 命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosparam set param_key param_value</code></td><td style="text-align:center">设置参数</td></tr><tr><td style="text-align:center"><code>rosparam get param_key</code></td><td style="text-align:center">显示参数</td></tr><tr><td style="text-align:center"><code>rosparam load file_name</code></td><td style="text-align:center">从文件加载参数</td></tr><tr><td style="text-align:center"><code>rosparam dump file_name</code></td><td style="text-align:center">保存参数到文件</td></tr><tr><td style="text-align:center"><code>rosparam delete</code></td><td style="text-align:center">删除参数</td></tr><tr><td style="text-align:center"><code>rosparam list</code></td><td style="text-align:center">列出参数名称</td></tr></tbody></table><h3 id="1021-loaddump文件"><a class="markdownIt-Anchor" href="#1021-loaddump文件"></a> 10.2.1. load&amp;&amp;dump文件</h3><p>load和dump文件需要遵守YAML格式，YAML格式具体示例如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">name:&#x27;Zhangsan&#x27;</span><br><span class="line">age:20</span><br><span class="line">gender:&#x27;M&#x27;</span><br><span class="line">score&#123;Chinese:80,Math:90&#125;</span><br><span class="line">score_history:[85,82,88,90]</span><br></pre></td></tr></table></figure><p>简明解释。就是“名称+：+值”这样一种常用的解释方式。一般格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">key : value</span><br></pre></td></tr></table></figure><p>遵循格式进行定义参数。其实就可以把YAML文件的内容理解为字典，因为它也是键值对的形式。</p><h2 id="103-launch文件内读写"><a class="markdownIt-Anchor" href="#103-launch文件内读写"></a> 10.3. launch文件内读写</h2><p>launch文件中有很多标签，而与参数服务器相关的标签只有两个，一个是<code>，另一个是</code>。这两个标签功能比较相近，但``一般只设置一个参数，请看下例：</p><p>（1） （2） （3）</p><p>观察上例比如序号3的param就定义了一个key和一个value，交给了参数服务器维护。而序号1的param只给出了key，没有直接给出value，这里的value是由后没的脚本运行结果作为value进行定义的。序号(2)就是rosparam的典型用法，先指定一个YAML文件，然后施加command,其效果等于<code>rosparam load file_name</code> 。</p><h2 id="104-node源码"><a class="markdownIt-Anchor" href="#104-node源码"></a> 10.4. node源码</h2><p>除了上述最常用的两种读写参数服务器的方法，还有一种就是修改ROS的源码，也就是利用API来对参数服务器进行操作。具体内容我们学习完后面章节再进行介绍。</p><h2 id="105-操作实例"><a class="markdownIt-Anchor" href="#105-操作实例"></a> 10.5. 操作实例</h2><ol><li>首先依然是打开我们教材的模拟场景<code>roslaunch robot_sim_demo robot_spawn.launch</code>。</li><li>输入<code>rosparam list</code>查看参数服务器上的param。</li><li>查询参数信息，例如查询竖直方向重力参数。输入<code>rosparam get /gazebo/gravity_z</code>回车得到参数值value=-9.8。</li><li>尝试保存一个参数到文件输入<code>rosparam dump param.yaml</code>之后就可以在当前路径看到该文件，也就能打开去查看到相关的参数信息。</li><li>参数服务器的其他命令操作方式大致相同，我们可以多多练习，巩固对参数服务器的理解和应用。</li></ol><h2 id="106-参数类型"><a class="markdownIt-Anchor" href="#106-参数类型"></a> 10.6. 参数类型</h2><p>ROS参数服务器为参数值使用XMLRPC数据类型，其中包括:strings, integers, floats, booleans, lists, dictionaries, iso8601 dates, and base64-encoded data。</p><h1 id="11-action"><a class="markdownIt-Anchor" href="#11-action"></a> 11. Action</h1><h2 id="111-简介"><a class="markdownIt-Anchor" href="#111-简介"></a> 11.1. 简介</h2><p>Actionlib是ROS中一个很重要的库，**类似service通信机制，actionlib也是一种请求响应机制的通信方式，**actionlib主要弥补了service通信的一个不足，就是当机器人执行一个长时间的任务时，假如利用service通信方式，那么publisher会很长时间接受不到反馈的reply，致使通信受阻。当service通信不能很好的完成任务时候，<strong>actionlib则可以比较适合实现长时间的通信过程，actionlib通信过程可以随时被查看过程进度，也可以终止请求，这样的一个特性，使得它在一些特别的机制中拥有很高的效率。</strong></p><h1 id="12-通信原理"><a class="markdownIt-Anchor" href="#12-通信原理"></a> 12. 通信原理</h1><blockquote><p>Action的工作原理是client-server模式，也是一个<strong>双向的通信模式</strong>。通信双方在<strong>ROS Action Protocol</strong>下通过消息进行数据的交流通信。<strong>client和server为用户提供一个简单的API来请求目标（在客户端）或通过函数调用和回调来执行目标（在服务器端）。</strong></p></blockquote><p>工作模式的结构示意图如下：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/actionlib.png" alt="img" /></p><p>通信双方在ROS Action Protocal下进行交流通信是通过接口来实现,如下图:</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/action_interface.png" alt="img" /></p><p><strong>我们可以看到,客户端会向服务器发送目标指令和取消动作指令,而服务器则可以给客户端发送实时的状态信息,结果信息,反馈信息等等,从而完成了service没法做到的部分.</strong></p><h2 id="121-action-规范"><a class="markdownIt-Anchor" href="#121-action-规范"></a> 12.1. Action 规范</h2><p>利用动作库进行请求响应，动作的内容格式应包含三个部分，目标、反馈、结果。</p><ul><li>目标</li></ul><p>机器人执行一个动作，应该有明确的移动目标信息，包括一些参数的设定，方向、角度、速度等等。从而使机器人完成动作任务。</p><ul><li>反馈</li></ul><p>在动作进行的过程中，应该有实时的状态信息反馈给服务器的实施者，告诉实施者动作完成的状态，可以使实施者作出准确的判断去修正命令。</p><ul><li>结果</li></ul><p>当运动完成时，动作服务器把本次运动的结果数据发送给客户端，使客户端得到本次动作的全部信息，例如可能包含机器人的运动时长，最终姿势等等。</p><h2 id="122-action规范文件格式"><a class="markdownIt-Anchor" href="#122-action规范文件格式"></a> 12.2. Action规范文件格式</h2><p>Action规范文件的后缀名是.action，它的内容格式如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Define the goal</span><br><span class="line">uint32 dishwasher_id  # Specify which dishwasher we want to use</span><br><span class="line">---</span><br><span class="line"># Define the result</span><br><span class="line">uint32 total_dishes_cleaned</span><br><span class="line">---</span><br><span class="line"># Define a feedback message</span><br><span class="line">float32 percent_complete</span><br></pre></td></tr></table></figure><h2 id="123-action实例详解"><a class="markdownIt-Anchor" href="#123-action实例详解"></a> 12.3. Action实例详解</h2><p>Actionlib是一个用来实现action的一个功能包集。我们在demo中设置一个场景，执行一个搬运的action，搬运过程中客户端会不断的发回反馈信息，最终完成整个搬运过程．</p><p>本小节的演示源码在课程的演示代码包里,<a href="https://github.com/sychaichangkun/ROS-Academy-for-Beginners">此处为链接</a>.</p><p>首先写handling.action文件,类比如上的格式.包括三个部分,目标,结果,反馈.如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># Define the goal</span><br><span class="line">uint32 handling_id </span><br><span class="line">---</span><br><span class="line"># Define the result</span><br><span class="line">uint32 Handling_completed</span><br><span class="line">---</span><br><span class="line"># Define a feedback message</span><br><span class="line">float32 percent_complete</span><br></pre></td></tr></table></figure><p>写完之后修改文件夹里CmakeLists.txt如下内容:</p><ol><li>find_package(catkin REQUIRED genmsg actionlib_msgs actionlib)</li><li>add_action_files(DIRECTORY action FILES DoDishes.action) generate_messages(DEPENDENCIES actionlib_msgs)</li><li>add_action_files(DIRECTORY action FILES Handling.action)</li><li>generate_messages( DEPENDENCIES actionlib_msgs)</li></ol><p>修改package.xml,添加所需要的依赖如下:</p><ol><li><code>actionlib</code></li><li><code>actionlib_msgs</code></li><li><code>actionlib</code></li><li><code>actionlib_msgs</code></li></ol><p>然后回到工作空间 <code>catkin_ws</code>进行编译.</p><p>本例中设置的的action,定义了一个搬运的例子,首先写客户端,实现功能发送action请求,包括进行目标活动,或者目标活动.之后写服务器,实验返回客户端活动当前状态信息,结果信息,和反馈信息.从而实现action.本例测试结果截图如下:</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/3.7.1.png" alt="img" /> <img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/3.7.2.png" alt="img" /> <img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/3.7.3.png" alt="img" /> <img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/3.7.4.png" alt="img" /></p><h2 id="124-小结"><a class="markdownIt-Anchor" href="#124-小结"></a> 12.4. 小结</h2><p>至此，<strong>ROS通信架构的四种通信方式</strong>就介绍结束，我们可以对比学习这四种通信方式，去思考每一种通信的优缺点和适用条件，在正确的地方用正确的通信方式，这样整个ROS的通信会更加高效，机器人也将更加的灵活和智能。机器人学会了通信，也就相当于有了“灵魂”。</p><h1 id="13-常见srv类型"><a class="markdownIt-Anchor" href="#13-常见srv类型"></a> 13. 常见srv类型</h1><p>本小节介绍常见的srv类型及其定义 srv类型相当于两个message通道，一个发送，一个接收</p><p><strong>AddTwoInts.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#对两个整数求和，虚线前是输入量，后是返回量</span><br><span class="line">#文件位置：自定义srv文件</span><br><span class="line">int32 a</span><br><span class="line">int32 b</span><br><span class="line">---</span><br><span class="line">int32 sum</span><br></pre></td></tr></table></figure><p><strong>Empty.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#文件位置：std_srvs/Empty.srv</span><br><span class="line">#代表一个空的srv类型</span><br><span class="line"></span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>GetMap.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:nav_msgs/GetMap.srv</span><br><span class="line">#获取地图，注意请求部分为空</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">nav_msgs/OccupancyGrid map</span><br></pre></td></tr></table></figure><p><strong>GetPlan.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:nav_msgs/GetPlan.srv</span><br><span class="line">#得到一条从当前位置到目标点的路径</span><br><span class="line">geometry_msgs/PoseStamped start        #起始点</span><br><span class="line">geometry_msgs/PoseStamped goal        #目标点</span><br><span class="line">float32 tolerance    #到达目标点的x，y方向的容错距离</span><br><span class="line">---</span><br><span class="line">nav_msgs/Path plan</span><br></pre></td></tr></table></figure><p><strong>SetBool.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#文件位置：std_srvs/SetBools.srv</span><br><span class="line">bool data # 启动或者关闭硬件</span><br><span class="line">---</span><br><span class="line">bool success   # 标示硬件是否成功运行</span><br><span class="line">string message # 运行信息</span><br></pre></td></tr></table></figure><p><strong>SetCameraInfo.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:sensor_msgs/SetCameraInfo.srv</span><br><span class="line">#通过给定的CameraInfo相机信息，来对相机进行标定</span><br><span class="line">sensor_msgs/CameraInfo camera_info        #相机信息</span><br><span class="line">---</span><br><span class="line">bool success            #如果调用成功，则返回true</span><br><span class="line">string status_message    #给出调用成功的细节</span><br></pre></td></tr></table></figure><p><strong>SetMap.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#文件位置：nav_msgs/SetMap.srv</span><br><span class="line">#以初始位置为基准，设定新的地图</span><br><span class="line">nav_msgs/OccupancyGrid map</span><br><span class="line">geometry_msgs/PoseWithCovarianceStamped initial_pose</span><br><span class="line">---</span><br><span class="line">bool success</span><br></pre></td></tr></table></figure><p><strong>TalkerListener.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#文件位置: 自定义srv文件</span><br><span class="line">---</span><br><span class="line">bool success   # 标示srv是否成功运行</span><br><span class="line">string message # 信息，如错误信息等</span><br></pre></td></tr></table></figure><p><strong>Trigger.srv</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:std_srvs/Trigger.srv</span><br><span class="line">---</span><br><span class="line">bool success   # 标示srv是否成功运行</span><br><span class="line">string message # 信息，如错误信息等</span><br></pre></td></tr></table></figure><h1 id="14-常见action类型"><a class="markdownIt-Anchor" href="#14-常见action类型"></a> 14. 常见action类型</h1><p>本小节介绍常见的action类型以及其定义</p><p><strong>AddTwoInts.action</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:自定义action文件</span><br><span class="line">#表示将两个整数求和</span><br><span class="line">int64 a</span><br><span class="line">int64 b</span><br><span class="line">---</span><br><span class="line">int64 sum</span><br><span class="line">---</span><br></pre></td></tr></table></figure><p><strong>AutoDocking.action</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:自定义action文件</span><br><span class="line">#goal</span><br><span class="line">---</span><br><span class="line">#result</span><br><span class="line">string text</span><br><span class="line">---</span><br><span class="line">#feedback</span><br><span class="line">string state</span><br><span class="line">string text</span><br></pre></td></tr></table></figure><p><strong>GetMap.action</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:nav_msgs/GetMap.action</span><br><span class="line">#获取地图信息，响应部分为空</span><br><span class="line"></span><br><span class="line">---</span><br><span class="line">nav_msgs/OccupancyGrid map</span><br><span class="line">---</span><br><span class="line">#无返回部分</span><br></pre></td></tr></table></figure><p><strong>MoveBase.action</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">#文件位置:geometry_msgs/MoveBase.action</span><br><span class="line">geometry_msgs/PoseStamped target_pose</span><br><span class="line">---</span><br><span class="line">---</span><br><span class="line">geometry_msgs/PoseStamped base_position</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS-windows安装ROS环境</title>
      <link href="/posts/72d3205.html"/>
      <url>/posts/72d3205.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-windows操作系统"><a class="markdownIt-Anchor" href="#1-windows操作系统"></a> 1. Windows操作系统</h1><ul><li>Windows的ROS需要64位Windows 10桌面或Windows 10 IoT Enterprise。</li><li>请确保已在系统路径中安装了Powershell。</li></ul><h1 id="2-预留安装空间"><a class="markdownIt-Anchor" href="#2-预留安装空间"></a> 2. 预留安装空间</h1><ul><li>在继续操作之前，请清理并备份<code>c：\ opt</code>下的所有现有数据。</li><li><code>c：\ opt</code>是必需的安装位置。当前未启用重定位。</li><li>请确保C：\驱动器上有10 GB的可用空间用于安装和开发。</li></ul><h1 id="3-安装visual-studio-2019"><a class="markdownIt-Anchor" href="#3-安装visual-studio-2019"></a> 3. 安装Visual Studio 2019</h1><p>为Windows生成ROS项目需要Visual Studio和Windows的Microsoft SDK。</p><ul><li><a href="https://docs.microsoft.com/en-us/cpp/build/vscpp-step-0-installation?view=vs-2019">下载Visual Studio 2019</a><ul><li>包括“使用C ++进行桌面开发”工作负载。</li><li>如果要构建WinML，请包括“通用Windows平台开发”工作负载。</li><li>如果已经安装了Visual Studio 2019，则可以<a href="https://docs.microsoft.com/en-us/visualstudio/install/modify-visual-studio?view=vs-2019">修改安装</a></li></ul></li></ul><h1 id="4-安装windows软件包管理器"><a class="markdownIt-Anchor" href="#4-安装windows软件包管理器"></a> 4. 安装Windows软件包管理器</h1><p>Chocolatey是Windows的程序包管理器。它用于简化安装构建和运行ROS项目所需的工具和库的过程。以下说明将Chocolatey安装位置重定向到<code>c：\ opt</code>，以便您可以从该位置清洁或移动ROS环境。</p><ul><li><p>在“开始”菜单中，找到“ VS 2019 x64本机工具命令提示符”项。</p></li><li><p>右键单击，选择“更多”，然后选择“以管理员身份运行”</p></li><li><p>复制以下命令行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">@&quot;%SystemRoot%\System32\WindowsPowerShell\v1.0\powershell.exe&quot; -NoProfile -InputFormat None -ExecutionPolicy Bypass -Command &quot;iex ((New-Object System.Net.WebClient).DownloadString(&#x27;https://chocolatey.org/install.ps1&#x27;))&quot; &amp;&amp; SET &quot;PATH=%PATH%;%ALLUSERSPROFILE%\chocolatey\bin&quot;</span><br></pre></td></tr></table></figure><ul><li><p>将其粘贴到命令窗口中。</p></li><li><p>批准任何提示</p></li><li><p>完成后，关闭命令提示符以完成安装。</p></li></ul></li><li><p>安装Git：</p><ul><li><p>如上所述，重新打开Visual Studio命令窗口。</p></li><li><p>即使您已将其安装为应用程序，也请使用此处的命令安装Git。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">choco upgrade git -y</span><br></pre></td></tr></table></figure></li><li><p>安装Git之后，请确保Git现在在Visual Studio命令窗口中可用。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git --version</span><br></pre></td></tr></table></figure></li><li><p>如上所述，关闭并重新打开Visual Studio命令窗口。</p></li></ul></li></ul><h1 id="5-二进制软件包安装"><a class="markdownIt-Anchor" href="#5-二进制软件包安装"></a> 5. 二进制软件包安装</h1><p>要为Windows设置ROS，请遵循以下建议步骤：</p><h2 id="51-ros-last-known-goodlkg生成安装"><a class="markdownIt-Anchor" href="#51-ros-last-known-goodlkg生成安装"></a> 5.1. ROS Last Known Good（LKG）生成安装</h2><p>要开始使用，请安装推荐的<code>desktop_full</code>元软件包。元软件包是其他软件包的集合。桌面完全元软件包是指构建，运行，调试和可视化机器人所需的许多其他软件包。</p><p>如上所述，以管理员身份打开Visual Studio命令提示符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir c:\opt\chocolatey</span><br><span class="line">set ChocolateyInstall=c:\opt\chocolatey</span><br><span class="line">choco source add -n=ros-win -s=&quot;https://roswin.azurewebsites.net/api/v2&quot; --priority=1</span><br><span class="line">choco upgrade ros-melodic-desktop_full -y --execution-timeout=0</span><br></pre></td></tr></table></figure><h2 id="52-ros-2-nightly-构建安装"><a class="markdownIt-Anchor" href="#52-ros-2-nightly-构建安装"></a> 5.2. ROS 2 Nightly 构建安装</h2><p>要开始使用ROS 2，您也可以按照类似的步骤从同一Chocolatey Feed中安装ROS 2。</p><p>例如，如果你想安装ROS2 <code>口才</code>每日构建，打开ROS命令提示符上面创建和批准的行政海拔如果尚未打开。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">mkdir c:\opt\chocolatey</span><br><span class="line">set ChocolateyInstall=c:\opt\chocolatey</span><br><span class="line">choco source add -n=ros-win -s=&quot;https://roswin.azurewebsites.net/api/v2&quot; --priority=1</span><br><span class="line">choco upgrade ros-eloquent-desktop -y --execution-timeout=0 --pre</span><br></pre></td></tr></table></figure><h1 id="6-创建ros命令窗口快捷方式"><a class="markdownIt-Anchor" href="#6-创建ros命令窗口快捷方式"></a> 6. 创建ROS命令窗口快捷方式</h1><p>为了在Windows上使用ROS，需要在每个命令窗口中调用ROS设置脚本。为了将来不会忘记，使用自动执行此操作的ROS快捷方式将很有帮助。</p><ul><li><p>为Visual Studio创建一个管理命令行快捷方式：</p></li><li><p>右键单击Windows资源管理器文件夹，选择“新建”&gt;“快捷方式”</p></li><li><p>在快捷方式路径中，根据上面安装的Visual Studio，从以下选项中复制突出显示的命令行：</p><ul><li><p>如果您使用社区：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\cmd.exe /k &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Community\Common7\Tools\VsDevCmd.bat&quot; -arch=amd64 -host_arch=amd64&amp;&amp; set ChocolateyInstall=c:\opt\chocolatey&amp;&amp; c:\opt\ros\melodic\x64\setup.bat</span><br></pre></td></tr></table></figure></li><li><p>如果您使用的是Professional：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\cmd.exe /k &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Professional\Common7\Tools\VsDevCmd.bat&quot; -arch=amd64 -host_arch=amd64&amp;&amp; set ChocolateyInstall=c:\opt\chocolatey&amp;&amp; c:\opt\ros\melodic\x64\setup.bat</span><br></pre></td></tr></table></figure></li><li><p>如果您使用的是Enterprise：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">C:\Windows\System32\cmd.exe /k &quot;C:\Program Files (x86)\Microsoft Visual Studio\2019\Enterprise\Common7\Tools\VsDevCmd.bat&quot; -arch=amd64 -host_arch=amd64&amp;&amp; set ChocolateyInstall=c:\opt\chocolatey&amp;&amp; c:\opt\ros\melodic\x64\setup.bat</span><br></pre></td></tr></table></figure></li><li><p>将快捷方式命名为“ ROS”</p></li><li><p>将该快捷方式设置为管理员</p><ul><li>右键单击快捷方式，然后选择“属性”。</li></ul></li></ul></li><li><p>选择“快捷方式”选项卡（如果尚未选择）。</p><ul><li><p>按下[进阶]按钮</p></li><li><p>检查按钮“以管理员身份运行”。</p><ul><li>在“高级属性”对话框上按“确定”。</li></ul></li><li><p>在“ ROS属性”快捷方式对话框上按“确定”。</p></li></ul></li></ul><h2 id="61-可选使用新的windows终端"><a class="markdownIt-Anchor" href="#61-可选使用新的windows终端"></a> 6.1. （可选）使用新的Windows终端</h2><p>微软正在<a href="https://github.com/Microsoft/Terminal">为Windows</a>开发一个新的<a href="https://github.com/Microsoft/Terminal">开源终端</a>，该<a href="https://github.com/Microsoft/Terminal">终端对</a>内置命令行进行了许多改进，包括选项卡和外观自定义。您可以从<a href="https://www.microsoft.com/store/apps/9n0dx20hk701">Microsoft Store</a>安装它。</p><p>为ROS设置终端：</p><ul><li>从开始菜单中找到Windows终端，右键单击并选择“以管理员身份运行”</li><li>从添加选项卡（+）按钮旁边的下拉箭头中选择设置。</li><li>在“配置文件”对象的列表数组中，为ROS添加一个新块。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&quot;profiles&quot; :</span><br><span class="line">&#123;</span><br><span class="line">    list: </span><br><span class="line">    [</span><br><span class="line">    ...</span><br><span class="line">        &#123;</span><br><span class="line">        &quot;commandline&quot; : &quot;C:\\Windows\\System32\\cmd.exe /k \&quot;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\Community\\Common7\\Tools\\VsDevCmd.bat\&quot; -arch=amd64 -host_arch=amd64 &amp;&amp; set ChocolateyInstall=c:\\opt\\chocolatey&amp;&amp; c:\\opt\\ros\\melodic\\x64\\setup.bat&quot;,</span><br><span class="line">        &quot;guid&quot; : &quot;&#123;xxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxx&#125;&quot;,</span><br><span class="line">        &quot;icon&quot; : &quot;ms-appx:///ProfileIcons/&#123;0caa0dad-35be-5f56-a8ff-afceeeaa6101&#125;.png&quot;,</span><br><span class="line">        &quot;name&quot; : &quot;ROS&quot;,</span><br><span class="line">        &quot;startingDirectory&quot; : &quot;c:\\ws&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>从Visual Studio命令窗口中，使用命令<code>uuidgen</code>生成全局唯一标识符（也称为通用唯一标识符）。</li><li>复制GUID（选择文本，然后右键单击以复制）</li><li>用上面复制的文本替换xxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxx。</li><li>（可选）将此guid设置为“ defaultProfile”</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&quot;alwaysShowTabs&quot; : true,</span><br><span class="line">&quot;copyOnSelect&quot; : false,</span><br><span class="line">&quot;defaultProfile&quot; : &quot;&#123;xxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxxxxx&#125;&quot;,</span><br><span class="line">....</span><br></pre></td></tr></table></figure><blockquote><p>启动新的Windows终端时，请记住以“以管理员身份运行”，方法是右键单击Windows终端并选择“以管理员身份运行”。在解除此要求之前，需要实施“ <a href="https://github.com/microsoft/terminal/issues/632">始终运行终端”提升功能请求</a>。</p><p>或者，按Ctrl + Shift +单击开始菜单或任务栏中的终端图标是以管理员身份运行的便捷快捷方式。</p></blockquote><h1 id="7-保持最新"><a class="markdownIt-Anchor" href="#7-保持最新"></a> 7. 保持最新</h1><p>如果要更新ROS安装，请使用Chocolatey的升级功能。</p><p>打开上面创建的ROS命令提示符，并批准管理海拔（如果尚未打开）。</p><p>运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">set ChocolateyInstall=c:\opt\chocolatey</span><br><span class="line">choco upgrade all -y --execution-timeout=0</span><br></pre></td></tr></table></figure><p>建议添加<code>--execution-timeout = 0，</code>以适应由于网络缓慢而导致的巧克力安装失败。</p><h1 id="8-卸载"><a class="markdownIt-Anchor" href="#8-卸载"></a> 8. 卸载</h1><ol><li><p>卸载之前，请确保系统上没有运行ROS系统或程序。</p></li><li><p>在命令提示符下，运行以下命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">rmdir /s /q c:\opt</span><br></pre></td></tr></table></figure></li></ol><h1 id="9-故障排除"><a class="markdownIt-Anchor" href="#9-故障排除"></a> 9. 故障排除</h1><h2 id="91-升级期间未找到vcpkg"><a class="markdownIt-Anchor" href="#91-升级期间未找到vcpkg"></a> 9.1. 升级期间未找到VCPKG</h2><p>vcpkg是用于管理库依赖关系的外部工具。外部工具要求Powershell处于路径中，否则它将无法安装。由于它是desktop_full的依赖项，因此安装可能会失败。</p><p>在安装ROS之前，请验证powershell.exe在您的路径中。</p><p>有关详细信息，请参见https://github.com/ms-iot/ROSOnWindows/issues/203。</p><h2 id="92-该系统找不到指定的路径"><a class="markdownIt-Anchor" href="#92-该系统找不到指定的路径"></a> 9.2. 该系统找不到指定的路径</h2><p><code>注意：</code>一些软件包已从二进制部署更改为目录，这会导致升级问题。如果遇到以下情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ERROR: Can not open output file : The system cannot find the path specified. : c:\opt\ros\melodic\x64\lib\site-packages\gennodejs-2.0.1-py2.7.egg-info\dependency_links.txt</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>请删除每个受影响的文件，然后尝试再次更新。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">del \opt\ros\melodic\x64\lib\site-packages\gennodejs-2.0.1-py2.7.egg-info</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>有关更多信息，请参见https://github.com/ms-iot/ROSOnWindows/issues/207。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS常用工具</title>
      <link href="/posts/59244a47.html"/>
      <url>/posts/59244a47.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note primary flat"><p>📖 ROS开发时常常使用的工具，分别是：</p><ul><li>Gazebo</li><li>RViz</li><li>rqt</li><li>rosbag</li><li>rosbridge</li><li>moveit!</li></ul><p>这六个工具是我们开发常常用到的工具，gazebo是一种最常用的ROS仿真工具，也是目前仿真ROS效果最好的工具；RViz是可视化工具，是将接收到的信息呈现出来；rqt则是非常好用的数据流可视化工具，有了它我们可以直观的看到消息的通信架构和流通路径；rosbag则是对软件包进行操作的一个命令，此外还提供代码API，对包进行操作编写。rosbridge是一个沟通ROS和外界的功能包，moveit!是目前为止应用最广泛的开源操作软件。</p></div><hr /><h1 id="1-gazebo"><a class="markdownIt-Anchor" href="#1-gazebo"></a> 1. Gazebo</h1><h2 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1. 简介</h2><p>ROS中的工具就是帮助我们完成一系列的操作，使得我们的工作更加轻松高效。ROS工具的功能大概有以下几个方向：仿真、调试、可视化。本节课我们要学习的Gazebo就是实现了仿真的功能，而调试与可视化由Rviz、rqt来实现，我们下节再依次介绍。</p><h2 id="12-认识-gazebo"><a class="markdownIt-Anchor" href="#12-认识-gazebo"></a> 1.2. 认识 Gazebo</h2><p>对于Gazebo,大家可能并不陌生，因为我们在前面的学习过程中已经数次用到这个仿真环境，无论是在topic通信还是在service通信中，我们的demo都是在Gazebo中实现。</p><p>Gazebo是一个机器人仿真工具，模拟器，也是一个独立的开源机器人仿真平台。当今市面上还有其他的仿真工具例如V—Rep、Webots等等。但是Gazebo不仅开源，也是是兼容ROS最好的仿真工具。</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/Gazebo.png" alt="img" /></p><p>Gazebo的功能很强大，最大的优点是对ROS的支持很好，因为Gazebo和ROS都由OSRF（Open Source Robotics Foundation）开源机器人组织来维护，Gazebo支持很多开源的物理引擎比如最典型的ODE。可以进行机器人的运动学、动力学仿真，能够模拟机器人常用的传感器（如激光雷达、摄像头、IMU等），也可以加载自定义的环境和场景。</p><h2 id="13-仿真的意义"><a class="markdownIt-Anchor" href="#13-仿真的意义"></a> 1.3. 仿真的意义</h2><p>仿真不仅仅只是做出一个很酷的3D场景，更重要的是给机器人一个逼近现实的虚拟物理环境，比如光照条件、物理距离等等。设定好具体的参数，让机器人完成我们设定的目标任务。比如一些有危险因素的测试，就可以让机器人在仿真的环境中去完成，例如无人车在交通环境复杂的交通要道的效果，我们就可以在仿真的环境下测试各种情况无人车的反应与效果，如车辆的性能、驾驶的策略、车流人流的行为模式等，又或者各种不可控因素如雨雪天气，突发事故，车辆故障等，从而收集结果参数指标信息等等，只有更大程度的逼近现实，才能得出车辆的真实效果。直到无人车在仿真条件下做到万无一失，才能放心的投放到真实环境中去使用，这即避免了危险因素对实验者的威胁，也节约了时间和资源，这就是仿真的意义。</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/baiduAI.jpg" alt="img" /></p><p>通常一些不依赖于具体硬件的算法和场景都可以在Gazebo上仿真，例如图像识别、传感器数据融合处理、路径规划、SLAM等任务完全可以在Gazebo上仿真实现，大大减轻了对硬件的依赖。</p><h2 id="14-演示"><a class="markdownIt-Anchor" href="#14-演示"></a> 1.4. 演示</h2><p>和我们前面的实例测试一样，我们打开教材的模拟场景，输入<code>roslaunch robot_sim_demo robot_spawn_launch</code></p><h2 id="15-操作说明"><a class="markdownIt-Anchor" href="#15-操作说明"></a> 1.5. 操作说明</h2><ul><li>平移：鼠标左键</li><li>旋转：鼠标滚轮中键</li><li>放缩：鼠标滚轮</li><li>界面左侧是控制面板</li><li>导入模型就在控制面板的insert,可以直接拖入模拟空间，也可以按需自制模型拖入。</li></ul><h2 id="16-小结"><a class="markdownIt-Anchor" href="#16-小结"></a> 1.6. 小结</h2><p>虽然Gazebo目前的功能还称不上强大，同时还存在着一些BUG，但是对于我们的入门学习也已经是足够了，随着版本的更新，Gazebo也在越来越强大。</p><h1 id="2-rviz"><a class="markdownIt-Anchor" href="#2-rviz"></a> 2. RViz</h1><h2 id="21-简介"><a class="markdownIt-Anchor" href="#21-简介"></a> 2.1. 简介</h2><p>本节课介绍的是我们在ROS开发中非常常用的一个工具，基本上的调试和开发都离不开这个工具——RViz(the Robit Visualization tool)机器人可视化工具，可视化的作用是直观的，它极大的方便了监控和调试等操作。</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/RViz.png" alt="img" /></p><h2 id="22-演示"><a class="markdownIt-Anchor" href="#22-演示"></a> 2.2. 演示</h2><p>依然打开教材的模拟场景，输入<code>roslaunch robot_sim_demo robot_spawn_launch</code>，之后在命令行打开新的终端直接输入<code>$ rviz</code> 打开工具。</p><p>和Gazebo一样，也会显示出一个3D环境，不过操作上有所不同，具体操作如下：</p><ul><li>平移：鼠标滚轮中键</li><li>旋转：鼠标左键</li><li>放缩：鼠标滚轮</li><li>左侧控制面板，可以添加插件</li></ul><p>RViz的插件种类繁多功能强大，非常适合我们开发调试ROS程序。</p><h2 id="23-差异"><a class="markdownIt-Anchor" href="#23-差异"></a> 2.3. 差异</h2><p>虽然从界面上来看，RViz和Gazebo非常相似，但实际上两者有着很大的不同，Gazebo实现的是仿真，提供一个虚拟的世界，RViz实现的是可视化，呈现接收到的信息。左侧的插件相当于是一个个的subscriber,RViz接收信息，并且显示。所以RViz和Gazebo有本质的差异。</p><h2 id="24-小结"><a class="markdownIt-Anchor" href="#24-小结"></a> 2.4. 小结</h2><p>RViz和Gazebo是我们常用的ROS工具，更好的利用这些工具是我们ROS进阶的基础。具体的操作和使用可以参考我们的官方演示视频，跟着视频去实战演练，熟悉这两个工具。</p><h1 id="3-rqt"><a class="markdownIt-Anchor" href="#3-rqt"></a> 3. rqt</h1><h2 id="31-简介"><a class="markdownIt-Anchor" href="#31-简介"></a> 3.1. 简介</h2><p>rqt是一个基于qt开发的可视化工具，拥有扩展性好、灵活易用、跨平台等特点，主要作用和RViz一致都是可视化，但是和RViz相比，rqt要高级一个层次，。</p><h2 id="32-命令"><a class="markdownIt-Anchor" href="#32-命令"></a> 3.2. 命令</h2><ul><li>rqt_graph :显示通信架构</li><li>rqt_plot ：绘制曲线</li><li>rqt_console ：查看日志</li></ul><h2 id="33-rqt_graph"><a class="markdownIt-Anchor" href="#33-rqt_graph"></a> 3.3. rqt_graph</h2><p>rqt_graph是来显示通信架构，也就是我们上一章所讲的内容节点、主题等等，当前有哪些Node和topic在运行，消息的流向是怎样，都能通过这个语句显示出来。此命令由于能显示系统的全貌，所以非常的常用。</p><h2 id="34-rqt_plot"><a class="markdownIt-Anchor" href="#34-rqt_plot"></a> 3.4. rqt_plot</h2><p>rqt_plot将一些参数，尤其是动态参数以曲线的形式绘制出来。当我们在开发时查看机器人的原始数据，我们就能利用rqt_plot将这些原始数据用曲线绘制出来，非常的直观，利于我们分析数据。</p><h2 id="35-rqt_console"><a class="markdownIt-Anchor" href="#35-rqt_console"></a> 3.5. rqt_console</h2><p>rqt_console里存在一些过滤器，我们可以利用它方便的查到我们需要的日志。</p><h2 id="36-实例测试"><a class="markdownIt-Anchor" href="#36-实例测试"></a> 3.6. 实例测试</h2><ol><li>首先打开我们教材的模拟场景，输入<code>roslaunch robot_sim_demo robot_spawn_launch</code></li><li>输入命令语句<code>rqt_graph</code>,显示出了当前环境下运行的Node和topic，十分直观的看到通信结构以及消息流向。注意在椭圆形的代表节点，矩形代表topic。</li><li>输入命令语句<code>rqt_plot</code>,显示出曲线坐标窗口，在上方输入框里添加或者删除topic，比如我们查看速度，可以在框里设置好topic后，移动机器人，就可以看到自动绘制的线速度或者角速度曲线。</li><li>输入命令语句<code>rqt_console</code>，显示日志的输出，配合<code>rqt_logger_level</code>查看日志的级别。</li></ol><h2 id="37-小结"><a class="markdownIt-Anchor" href="#37-小结"></a> 3.7. 小结</h2><p>rqt_graph这个功能是强大的，它使得我们初学者可以直观的看到ROS的通信架构和信息流，方便我们理解的同时，也使得我们能够最快的纠错等等。rqt_plot绘制数据曲线图，也是极大的帮助我们了解数据的变化态势，理解数据流的作用，用曲线来显示我们的操作，精确直观。rqt_console配合rqt_logger_level，查看日志，对于查找错误和DeBug都有很大帮助。</p><h1 id="4-rosbag"><a class="markdownIt-Anchor" href="#4-rosbag"></a> 4. Rosbag</h1><h2 id="41-简介"><a class="markdownIt-Anchor" href="#41-简介"></a> 4.1. 简介</h2><p>rosbag是一个这是一套用于记录和回放ROS主题的工具。它旨在提高性能，并避免消息的反序列化和重新排序。rosbag package提供了命令行工具和代码API，可以用C++或者python来编写包。而且rosbag命令行工具和代码API是稳定的，始终保持向后的兼容性。</p><h2 id="42-命令"><a class="markdownIt-Anchor" href="#42-命令"></a> 4.2. 命令</h2><p>rosbag对软件包来操作，一个包是ROS用于存储ROS消息数据的文件格式，rosbag命令可以记录、回放和操作包。指令列表如下：</p><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>cheak</code></td><td style="text-align:center">确定一个包是否可以在当前系统中进行，或者是否可以迁移。</td></tr><tr><td style="text-align:center"><code>decompress</code></td><td style="text-align:center">压缩一个或多个包文件。</td></tr><tr><td style="text-align:center"><code>filter</code></td><td style="text-align:center">解压一个或多个包文件。</td></tr><tr><td style="text-align:center"><code>fix</code></td><td style="text-align:center">在包文件中修复消息，以便在当前系统中播放。</td></tr><tr><td style="text-align:center"><code>help</code></td><td style="text-align:center">获取相关命令指示帮助信息</td></tr><tr><td style="text-align:center"><code>info</code></td><td style="text-align:center">总结一个或多个包文件的内容。</td></tr><tr><td style="text-align:center"><code>play</code></td><td style="text-align:center">以一种时间同步的方式回放一个或多个包文件的内容。</td></tr><tr><td style="text-align:center"><code>record</code></td><td style="text-align:center">用指定主题的内容记录一个包文件。</td></tr><tr><td style="text-align:center"><code>reindex</code></td><td style="text-align:center">重新索引一个或多个包文件。</td></tr></tbody></table><ul><li><a href="https://youtu.be/pwlbArh_neU">参考链接</a></li></ul><h2 id="43-小结"><a class="markdownIt-Anchor" href="#43-小结"></a> 4.3. 小结</h2><p>rosbag通过命令行能够对软件包进行很多的操作，更重要的拥有代码API，可以对包进行重新编写。增加一个ROS API，用于通过服务调用与播放和录制节点进行交互。</p><h1 id="5-rosbridge"><a class="markdownIt-Anchor" href="#5-rosbridge"></a> 5. Rosbridge</h1><h2 id="51-简介"><a class="markdownIt-Anchor" href="#51-简介"></a> 5.1. 简介</h2><blockquote><p>Rosbridge是一个用在ROS系统和其他系统之间的一个功能包,就像是它的名字一样,起到一个&quot;桥梁&quot;的作用,使得ros系统和其他系统能够进行交互.Rosbridge为非ROS程序提供了一个JSON API,有许多与Rosbridge进行交互的前端，包括一个用于Web浏览器交互的WebSocket服务器。Rosbridge_suite是一个包含Rosbridge的元程序包，用于Rosbridge的各种前端程序包（如WebSocket程序包）和帮助程序包。</p></blockquote><h2 id="52-协议和实现"><a class="markdownIt-Anchor" href="#52-协议和实现"></a> 5.2. 协议和实现</h2><p>Rosbridge主要包含两部分内容:协议(Potocol)和实现(Implementation)</p><h3 id="521-协议"><a class="markdownIt-Anchor" href="#521-协议"></a> 5.2.1. 协议</h3><p>Ｒosbridge Protocol提供了非ROS程序与ROS通信的具体的格式规范，规范基于JSON格式,包括订阅topic，发布message,调用server，设置参数，压缩消息等等．例如订阅topic的格式规范如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123; &quot;op&quot;: &quot;subscribe&quot;,</span><br><span class="line">    &quot;topic&quot;: &quot;/cmd_vel&quot;,</span><br><span class="line">    &quot;type&quot;: &quot;geometry_msgs/Twist&quot;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>此规范与所用的编程语言和传输方式无关，任何可以发送JSON格式的语音和传输方式都可以Rosbridge protocol进行交流，并且与ROS进行交互．</p><h3 id="522-实现"><a class="markdownIt-Anchor" href="#522-实现"></a> 5.2.2. 实现</h3><p>Rosbridge_suite元程序包是实现Ｒosbridge　Protocol并提供WebSocket传输层的包的集合。</p><p>这些软件包包括：</p><ul><li>Rosbridge_library : 核心rosbridge软件包。Rosbridge_library负责获取JSON字符串并将命令发送到ROS，反过来接收处理ROS发过来的信息，将之转换为JSON字符串，并将结果转交给非ROS程序。</li><li>rosapi : 通过服务调用来访问某些ROS操作，这些服务通常为ROS客户端库保留的服务．这些操作包括获取和设置参数，获取主题列表等等。</li><li>rosbridge_server : 虽然Rosbridge_library提供JSON到ROS转换，但它将传输层留给其他人。Rosbridge_server提供了一个WebSocket连接，所以浏览器可以与ROS“交谈”。Roslibjs是一个浏览器的JavaScript库，可以通过rosbridge_server与ROS进行交流。</li></ul><p><a href="https://github.com/RobotWebTools/rosbridge_suite">源码</a></p><h2 id="53-安装与使用"><a class="markdownIt-Anchor" href="#53-安装与使用"></a> 5.3. 安装与使用</h2><h3 id="531-安装"><a class="markdownIt-Anchor" href="#531-安装"></a> 5.3.1. 安装</h3><p>Rosbridge是基于ROS的，首先要确保自己正确的安装完成了ROS之后可以启动终端执行命令：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install ros-  -rosbridge-server</span><br></pre></td></tr></table></figure><p>中间的为自己的ROS版本，依照自己的版本进行安装．</p><h3 id="532-使用"><a class="markdownIt-Anchor" href="#532-使用"></a> 5.3.2. 使用</h3><p>关于更深入的使用，可以参考本课程的视频课程，简单的入门使用可以参考链接如下：</p><p><a href="http://wiki.ros.org/rosbridge_suite/Tutorials/RunningRosbridge">参考链接</a></p><h1 id="6-moveit"><a class="markdownIt-Anchor" href="#6-moveit"></a> 6. moveit!</h1><h2 id="61-简介"><a class="markdownIt-Anchor" href="#61-简介"></a> 6.1. 简介</h2><p>2012年，一款叫做moveit!的移动操作软件诞生了，moveit！最初在Willow Garage由Sachin Chitta，Ioan Sucan，Gil E. Jones，Acorn Pooley，Suat Gedikli，Dave Hershberger开发，它融合了研究者在运动规划、操纵、3D感知、运动学、控制和导航方面的最新进展，为操作者提供了一个易于使用的平台，使用它可以开发先进的机器人应用，也被广泛应用于工业，商业，研发和其他领域。由于以上特性，moveit！一跃成为在机器人上最广泛使用的开源操作软件，截止2017年，已经被用于超过65台机器人。</p><ul><li><a href="https://youtu.be/0og1SaZYtRc">moveit!视频链接</a></li></ul><h2 id="62-使用"><a class="markdownIt-Anchor" href="#62-使用"></a> 6.2. 使用</h2><p>moveit!的使用通过为用户提供接口来调用它，包括C++、Python、GUI三种接口。ROS中的<code>move_group</code>节点充当整合器，整合多个独立组件，提供ROS风格的Action和service。<code>move_group</code>通过ROS topic和action与机器人通讯，获取机器人的位置、节点等状态，获取数据再传递给机器人的控制器。</p><p><code>move_group</code>节点获取到节点状态信息或者机器人变换信息时候，会通过控制器的接口去处理这些信息，比如进行坐标转换、规划场景、3D感知。另外，<code>move_group</code>的结构比较容易扩展，不仅具有独立的能力如抓放，运动规划，也可扩展自公共类，但实际作为独立的插件运行。moveit!系统结构图如下：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/moveIT.png" alt="img" /></p><h3 id="621-官网链接"><a class="markdownIt-Anchor" href="#621-官网链接"></a> 6.2.1. <a href="http://moveit.ros.org/">官网链接</a></h3>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS-rospy</title>
      <link href="/posts/53197a40.html"/>
      <url>/posts/53197a40.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note primary flat"><p>📖 rospy是Python语言的接口。客户端库（Client Libarary）不仅仅指的是C++、Python语言的接口，其实是各种语言的接口统称。rospy中函数的定义，函数的用法都和roscpp不相同。</p></div><hr /><h1 id="1-rospy与主要接口"><a class="markdownIt-Anchor" href="#1-rospy与主要接口"></a> 1. rospy与主要接口</h1><h2 id="11-rospy-vs-roscpp"><a class="markdownIt-Anchor" href="#11-rospy-vs-roscpp"></a> 1.1. rospy vs roscpp</h2><p>rospy是Python版本的ROS客户端库，提供了Python编程需要的接口，你可以认为rospy就是一个Python的模块(Module)。这个模块位于<code>/opt/ros/kineetic/lib/python2.7/dist-packages/rospy</code>之中。</p><p>rospy包含的功能与roscpp相似，都有关于node、topic、service、param、time相关的操作。但同时rospy和roscpp也有一些区别：</p><ol><li><strong>rospy没有一个NodeHandle，像创建publisher、subscriber等操作都被直接封装成了rospy中的函数或类，调用起来简单直观。</strong></li><li><strong>rospy一些接口的命名和roscpp不一致，有些地方需要开发者注意，避免调用错误。</strong></li></ol><p>相比于C<ins>的开发，用Python来写ROS程序开发效率大大提高，诸如显示、类型转换等细节不再需要我们注意，节省时间。但Python的执行效率较低，同样一个功能用Python运行的耗时会高于C</ins>。因此我们开发SLAM、路径规划、机器视觉等方面的算法时，往往优先选择C++。</p><p>ROS中绝大多数基本指令，例如<code>rostopic</code>,<code>roslaunch</code>都是用python开发的，简单轻巧。</p><h1 id="2-ros中python代码的组织方式"><a class="markdownIt-Anchor" href="#2-ros中python代码的组织方式"></a> 2. ROS中Python代码的组织方式</h1><p>要介绍rospy，就不得不提<strong>Python代码在ROS中的组织方式</strong>。通常来说，Python代码有两种组织方式，一种是单独的一个<strong>Python脚本</strong>，适用于简单的程序，另一种是<strong>Python模块</strong>，适合体量较大的程序。</p><h2 id="21-单独的python脚本"><a class="markdownIt-Anchor" href="#21-单独的python脚本"></a> 2.1. 单独的Python脚本</h2><p>对于一些小体量的ROS程序，一般就是一个Python文件，放在script/路径下，非常简单。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_package</span><br><span class="line">|- script/</span><br><span class="line">|- your_script.py</span><br><span class="line">|-...</span><br></pre></td></tr></table></figure><h2 id="22-python模块"><a class="markdownIt-Anchor" href="#22-python模块"></a> 2.2. Python模块</h2><p>当程序的功能比较复杂，放在一个脚本里搞不定时，就需要把一些功能放到Python Module里，以便其他的脚本来调用。ROS建议我们按照以下规范来建立一个Python的模块：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">your_package</span><br><span class="line">|- src/</span><br><span class="line">|-your_package/</span><br><span class="line">|- _init_.py</span><br><span class="line">|- modulefiles.py</span><br><span class="line">|- scripts/</span><br><span class="line">|- your_script.py</span><br><span class="line">|- setup.py</span><br></pre></td></tr></table></figure><p>在src下建立一个与你的package同名的路径，其中存放<code>_init_.py</code>以及你的模块文件。这样就建立好了ROS规范的Python模块，你可以在你的脚本中调用。 如果你不了解<em>init</em>.py的作用，可以参考这篇博客http://www.cnblogs.com/Lands-ljk/p/5880483.html ROS中的这种Python模块组织规范与标准的Python模块规范并不完全一致，你当然可以按照Python的标准去建立一个模块，然后在你的脚本中调用，但是我们还是建议按照ROS推荐的标准来写，这样方便别人去阅读。</p><p>通常我们常用的ROS命令，大多数其实都是一个个Python模块，源代码存放在ros_comm仓库的tools路径下：<a href="https://github.com/ros/ros_comm/tree/lunar-devel/tools">https://github.com/ros/ros_comm/tree/lunar-devel/tools</a> 你可以看到每一个命令行工具（如rosbag、rosmsg）都是用模块的形式组织核心代码，然后在<code>script/</code>下建立一个脚本来调用模块。</p><h1 id="3-常用rospy的api"><a class="markdownIt-Anchor" href="#3-常用rospy的api"></a> 3. 常用rospy的API</h1><p>这里分类整理了rospy常见的一些用法，请你浏览一遍，建立一个初步的影响。 具体API请查看http://docs.ros.org/api/rospy/html/rospy-module.html</p><h2 id="31-node相关"><a class="markdownIt-Anchor" href="#31-node相关"></a> 3.1. Node相关</h2><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">rospy.init_node(name, argv=None, anonymous=False)</td><td style="text-align:center">注册和初始化node</td></tr><tr><td style="text-align:center">MasterProxy</td><td style="text-align:center">rospy.get_master()</td><td style="text-align:center">获取master的句柄</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">rospy.is_shutdown()</td><td style="text-align:center">节点是否关闭</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">rospy.on_shutdown(fn)</td><td style="text-align:center">在节点关闭时调用fn函数</td></tr><tr><td style="text-align:center">str</td><td style="text-align:center">get_node_uri()</td><td style="text-align:center">返回节点的URI</td></tr><tr><td style="text-align:center">str</td><td style="text-align:center">get_name()</td><td style="text-align:center">返回本节点的全名</td></tr><tr><td style="text-align:center">str</td><td style="text-align:center">get_namespace()</td><td style="text-align:center">返回本节点的名字空间</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h2 id="32-topic相关"><a class="markdownIt-Anchor" href="#32-topic相关"></a> 3.2. Topic相关</h2><p>函数：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">[[str, str]]</td><td style="text-align:center">get_published_topics()</td><td style="text-align:center">返回正在被发布的所有topic名称和类型</td></tr><tr><td style="text-align:center">Message</td><td style="text-align:center">wait_for_message(topic, topic_type, time_out=None)</td><td style="text-align:center">等待某个topic的message</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">spin()</td><td style="text-align:center">触发topic或service的回调/处理函数，会阻塞直到关闭节点</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>Publisher类：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>init</em>(self, name, data_class, queue_size=None)</td><td style="text-align:center">构造函数</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">publish(self, msg)</td><td style="text-align:center">发布消息</td></tr><tr><td style="text-align:center">str</td><td style="text-align:center">unregister(self)</td><td style="text-align:center">停止发布</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>Subscriber类：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>init_</em>(self, name, data_class, call_back=None, queue_size=None)</td><td style="text-align:center">构造函数</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">unregister(self, msg)</td><td style="text-align:center">停止订阅</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h2 id="33-service相关"><a class="markdownIt-Anchor" href="#33-service相关"></a> 3.3. Service相关</h2><p>函数：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center">wait_for_service(service, timeout=None)</td><td style="text-align:center">阻塞直到服务可用</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>Service类(server)：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>init</em>(self, name, service_class, handler)</td><td style="text-align:center">构造函数，handler为处理函数，service_class为srv类型</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">shutdown(self)</td><td style="text-align:center">关闭服务的server</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>ServiceProxy类(client)：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>init</em>(self, name, service_class)</td><td style="text-align:center">构造函数，创建client</td></tr><tr><td style="text-align:center"></td><td style="text-align:center"><em>call</em>(self, *args, **kwds)</td><td style="text-align:center">发起请求</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">call(self, *args, **kwds)</td><td style="text-align:center">同上</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">close(self)</td><td style="text-align:center">关闭服务的client</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h2 id="34-param相关"><a class="markdownIt-Anchor" href="#34-param相关"></a> 3.4. Param相关</h2><p>函数：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">XmlRpcLegalValue</td><td style="text-align:center">get_param(param_name, default=_unspecified)</td><td style="text-align:center">获取参数的值</td></tr><tr><td style="text-align:center">[str]</td><td style="text-align:center">get_param_names()</td><td style="text-align:center">获取参数的名称</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">set_param(param_name, param_value)</td><td style="text-align:center">设置参数的值</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">delete_param(param_name)</td><td style="text-align:center">删除参数</td></tr><tr><td style="text-align:center">bool</td><td style="text-align:center">has_param(param_name)</td><td style="text-align:center">参数是否存在于参数服务器上</td></tr><tr><td style="text-align:center">str</td><td style="text-align:center">search_param()</td><td style="text-align:center">搜索参数</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h2 id="35-时钟相关"><a class="markdownIt-Anchor" href="#35-时钟相关"></a> 3.5. 时钟相关</h2><p>函数：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">Time</td><td style="text-align:center">get_rostime()</td><td style="text-align:center">获取当前时刻的Time对象</td></tr><tr><td style="text-align:center">float</td><td style="text-align:center">get_time()</td><td style="text-align:center">返回当前时间，单位秒</td></tr><tr><td style="text-align:center"></td><td style="text-align:center">sleep(duration)</td><td style="text-align:center">执行挂起</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>Time类：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>init</em>(self, secs=0, nsecs=0)</td><td style="text-align:center">构造函数</td></tr><tr><td style="text-align:center">Time</td><td style="text-align:center">now()</td><td style="text-align:center">静态方法 返回当前时刻的Time对象</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>Duration类：</p><table><thead><tr><th style="text-align:center">返回值</th><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"></td><td style="text-align:center"><em>init</em>(self, secs=0, nsecs=0)</td><td style="text-align:center">构造函数</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><h1 id="4-topic-in-rospy"><a class="markdownIt-Anchor" href="#4-topic-in-rospy"></a> 4. topic in rospy</h1><p>与5.3节类似，我们用python来写一个节点间消息收发的demo，同样还是创建一个自定义的gps类型的消息，一个节点发布模拟的gps信息，另一个接收和计算距离原点的距离。</p><h2 id="41-自定义消息的生成"><a class="markdownIt-Anchor" href="#41-自定义消息的生成"></a> 4.1. 自定义消息的生成</h2><p><code>gps.msg</code>定义如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string state   #工作状态</span><br><span class="line">float32 x      #x坐标</span><br><span class="line">float32 y      #y坐标</span><br></pre></td></tr></table></figure><p>我们需要修改<code>CMakeLists.txt</code>文件，方法见5.3节，这里需要强调一点的就是，对创建的msg进行<code>catkin_make</code>会在<code>~/catkin_ws/devel/lib/python2.7/dist-packages/topic_demo</code>下生成msg模块（module）。 有了这个模块，我们就可以在python程序中<code>from topic_demo.msg import gps</code>,从而进行gps类型消息的读写。</p><h2 id="42-消息发布节点"><a class="markdownIt-Anchor" href="#42-消息发布节点"></a> 4.2. 消息发布节点</h2><p>与C++的写法类似，我们来看topic用Python如何编写程序，见<code>topic_demo/scripts/pytalker.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="comment">#导入自定义的数据类型</span></span><br><span class="line"><span class="keyword">from</span> topic_demo.msg <span class="keyword">import</span> gps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">talker</span>():</span></span><br><span class="line">    <span class="comment">#Publisher 函数第一个参数是话题名称，第二个参数 数据类型，现在就是我们定义的msg 最后一个是缓冲区的大小</span></span><br><span class="line">    <span class="comment">#queue_size: None（不建议）  #这将设置为阻塞式同步收发模式！</span></span><br><span class="line">    <span class="comment">#queue_size: 0（不建议）#这将设置为无限缓冲区模式，很危险！</span></span><br><span class="line">    <span class="comment">#queue_size: 10 or more  #一般情况下，设为10 。queue_size太大了会导致数据延迟不同步。</span></span><br><span class="line">    pub = rospy.Publisher(<span class="string">&#x27;gps_info&#x27;</span>, gps , queue_size=<span class="number">10</span>)</span><br><span class="line">    rospy.init_node(<span class="string">&#x27;pytalker&#x27;</span>, anonymous=<span class="literal">True</span>)</span><br><span class="line">    <span class="comment">#更新频率是1hz</span></span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>) </span><br><span class="line">    x=<span class="number">1.0</span></span><br><span class="line">    y=<span class="number">2.0</span></span><br><span class="line">    state=<span class="string">&#x27;working&#x27;</span></span><br><span class="line">    <span class="keyword">while</span> <span class="keyword">not</span> rospy.is_shutdown():</span><br><span class="line">        <span class="comment">#计算距离</span></span><br><span class="line">        rospy.loginfo(<span class="string">&#x27;Talker: GPS: x=%f ,y= %f&#x27;</span>,x,y)</span><br><span class="line">        pub.publish(gps(state,x,y))</span><br><span class="line">        x=<span class="number">1.03</span>*x</span><br><span class="line">        y=<span class="number">1.01</span>*y</span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    talker()</span><br></pre></td></tr></table></figure><p>以上代码与C++的区别体现在这几个方面：</p><ol><li>rospy创建和初始化一个node，不再需要用NodeHandle。rospy中没有设计NodeHandle这个句柄，我们创建topic、service等等操作都直接用rospy里对应的方法就行。</li><li>rospy中节点的初始化并一定得放在程序的开头，在Publisher建立后再初始化也没问题。</li><li>消息的创建更加简单，比如gps类型的消息可以直接用类似于构造函数的方式<code>gps(state,x,y)</code>来创建。</li><li>日志的输出方式不同，C++中是<code>ROS_INFO()</code>，而Python中是<code>rospy.loginfo()</code></li><li>判断节点是否关闭的函数不同，C++用的是<code>ros::ok()</code>而Python中的接口是<code>rospy.is_shutdown()</code></li></ol><p>通过以上的区别可以看出，roscpp和rospy的接口并不一致，在名称上要尽量避免混用。在实现原理上，两套客户端库也有各自的实现，并没有基于一个统一的核心库来开发。这也是ROS在设计上不足的地方。</p><p>ROS2就解决了这个问题，ROS2中的客户端库包括了<code>rclcpp</code>(ROS Clinet Library C++)、<code>rclpy</code>(ROS Client Library Python),以及其他语言的版本，他们都是基于一个共同的核心ROS客户端库<code>rcl</code>来开发的，这个核心库由C语言实现。</p><h2 id="43-消息订阅节点"><a class="markdownIt-Anchor" href="#43-消息订阅节点"></a> 4.3. 消息订阅节点</h2><p>见<code>topic_demo/scripts/pylistener.py</code>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python</span><br><span class="line"><span class="meta">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">import</span> math</span><br><span class="line">#导入mgs</span><br><span class="line">from topic_demo.msg <span class="keyword">import</span> gps</span><br><span class="line"></span><br><span class="line">#回调函数输入的应该是<span class="function">msg</span></span><br><span class="line"><span class="function">def <span class="title">callback</span><span class="params">(gps)</span>:</span></span><br><span class="line"><span class="function">    distance =</span> math.<span class="built_in">sqrt</span>(math.<span class="built_in">pow</span>(gps.x, <span class="number">2</span>)+math.<span class="built_in">pow</span>(gps.y, <span class="number">2</span>)) </span><br><span class="line">    rospy.<span class="built_in">loginfo</span>(<span class="string">&#x27;Listener: GPS: distance=%f, state=%s&#x27;</span>, distance, gps.state)</span><br><span class="line"></span><br><span class="line"><span class="function">def <span class="title">listener</span><span class="params">()</span>:</span></span><br><span class="line"><span class="function">    rospy.init_node(<span class="string">&#x27;pylistener&#x27;</span>, anonymous=</span>True)</span><br><span class="line">    #Subscriber函数第一个参数是topic的名称，第二个参数是接受的数据类型 第三个参数是回调函数的名称</span><br><span class="line">    rospy.<span class="built_in">Subscriber</span>(<span class="string">&#x27;gps_info&#x27;</span>, gps, callback)</span><br><span class="line">    rospy.<span class="built_in">spin</span>()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&#x27;__main__&#x27;</span>:</span><br><span class="line">    <span class="built_in">listener</span>()</span><br></pre></td></tr></table></figure><p>在订阅节点的代码里，rospy与roscpp有一个不同的地方：rospy里没有<code>spinOnce()</code>，只有<code>spin()</code>。</p><p>建立完talker和listener之后，经过<code>catkin_make</code>，就完成了python版的topic通信模型。</p><h1 id="5-service-in-rospy"><a class="markdownIt-Anchor" href="#5-service-in-rospy"></a> 5. Service in rospy</h1><p>本节用python来写一个节点间，利用Service通信的demo，与5.4类似，创建一个节点，发布模拟的gps信息，另一个接收和计算距离原点的距离。</p><h2 id="51-srv文件"><a class="markdownIt-Anchor" href="#51-srv文件"></a> 5.1. srv文件</h2><p>在5.4节，我们已经说过要建立一个名为<code>Greeting.srv</code>的服务文件，内容如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string name #短横线上边部分是服务请求的数据</span><br><span class="line">int32 age</span><br><span class="line">--- #短横线下面是服务回传的内容</span><br><span class="line">string feedback</span><br></pre></td></tr></table></figure><p>然后修改<code>CMakeLists.txt</code>文件。ROS的catkin编译系统会将你自定义的msg、srv（甚至还有action）文件自动编译构建，生成对应的C++、Python、LISP等语言下可用的库或模块。许多初学者错误地以为，只要建立了一个msg或srv文件，就可以直接在程序中使用，这是不对的，必须在<code>CMakeLists.txt</code>中添加关于消息创建、指定消息/服务文件那几个宏命令。</p><h2 id="52-创建提供服务节点server"><a class="markdownIt-Anchor" href="#52-创建提供服务节点server"></a> 5.2. 创建提供服务节点(server)</h2><p>见<code>service_demo/scripts/server_demo.py</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment">#coding=utf-8</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_demo.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">server_srv</span>():</span></span><br><span class="line">    <span class="comment"># 初始化节点，命名为 &quot;greetings_server&quot;</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;greetings_server&quot;</span>)</span><br><span class="line">    <span class="comment"># 定义service的server端，service名称为&quot;greetings&quot;， service类型为Greeting</span></span><br><span class="line">    <span class="comment"># 收到的request请求信息将作为参数传递给handle_function进行处理</span></span><br><span class="line">    s = rospy.Service(<span class="string">&quot;greetings&quot;</span>, Greeting, handle_function)</span><br><span class="line">    rospy.loginfo(<span class="string">&quot;Ready to handle the request:&quot;</span>)</span><br><span class="line">    <span class="comment"># 阻塞程序结束</span></span><br><span class="line">    rospy.spin()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">handle_function</span>(<span class="params">req</span>):</span></span><br><span class="line">    <span class="comment"># 注意我们是如何调用request请求内容的，是将其认为是一个对象的属性，在我们定义</span></span><br><span class="line">    <span class="comment"># 的Service_demo类型的service中，request部分的内容包含两个变量，一个是字符串类型的name，另外一个是整数类型的age</span></span><br><span class="line">    rospy.loginfo( <span class="string">&#x27;Request from %s with age %d&#x27;</span>, req.name, req.age)</span><br><span class="line">    <span class="comment"># 返回一个Service_demo.Response实例化对象，其实就是返回一个response的对象，其包含的内容为我们在Service_demo.srv中定义的</span></span><br><span class="line">    <span class="comment"># response部分的内容，我们定义了一个string类型的变量feedback，因此，此处实例化时传入字符串即可</span></span><br><span class="line">    <span class="keyword">return</span> GreetingResponse(<span class="string">&quot;Hi %s. I&#x27; server!&quot;</span>%req.name)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果单独运行此文件，则将上面定义的server_srv作为主函数运行</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    server_srv()</span><br></pre></td></tr></table></figure><p>以上代码中可以看出Python和C<ins>在ROS服务通信时，server端的处理函数有区别： C</ins>的handle_function()传入的参数是整个srv对象的request和response两部分，返回值是bool型，显示这次服务是否成功的处理，也就是：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_function</span><span class="params">(service_demo::Greeting::Request &amp;req, service_demo::Greeting::Response &amp;res)</span></span>&#123;</span><br><span class="line">...</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而Python的handle_function()传入的只有request，返回值是response，即：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">def handle_function(req):</span><br><span class="line">    ...</span><br><span class="line">    return GreetingResponse(&quot;Hi %s. I&#x27; server!&quot;%req.name)</span><br></pre></td></tr></table></figure><p>这也是ROS在两种语言编程时的差异之一。相比来说Python的这种思维方式更加简单，符合我们的思维习惯。</p><h2 id="53-创建服务请求节点client"><a class="markdownIt-Anchor" href="#53-创建服务请求节点client"></a> 5.3. 创建服务请求节点(client)</h2><p><code>service_demo/srv/client.cpp</code>内容如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"><span class="keyword">from</span> service_demo.srv <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">client_srv</span>():</span></span><br><span class="line">    rospy.init_node(<span class="string">&#x27;greetings_client&#x27;</span>)</span><br><span class="line">    <span class="comment"># 等待有可用的服务 &quot;greetings&quot;</span></span><br><span class="line">    rospy.wait_for_service(<span class="string">&quot;greetings&quot;</span>)</span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        <span class="comment"># 定义service客户端，service名称为“greetings”，service类型为Greeting</span></span><br><span class="line">        greetings_client = rospy.ServiceProxy(<span class="string">&quot;greetings&quot;</span>,Greeting)</span><br><span class="line"></span><br><span class="line">        <span class="comment"># 向server端发送请求，发送的request内容为name和age,其值分别为&quot;HAN&quot;, 20</span></span><br><span class="line">        <span class="comment"># 此处发送的request内容与srv文件中定义的request部分的属性是一致的</span></span><br><span class="line">        <span class="comment">#resp = greetings_client(&quot;HAN&quot;,20)</span></span><br><span class="line">        resp = greetings_client.call(<span class="string">&quot;HAN&quot;</span>,<span class="number">20</span>)</span><br><span class="line">        rospy.loginfo(<span class="string">&quot;Message From server:%s&quot;</span>%resp.feedback)</span><br><span class="line">    <span class="keyword">except</span> rospy.ServiceException, e:</span><br><span class="line">        rospy.logwarn(<span class="string">&quot;Service call failed: %s&quot;</span>%e)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果单独运行此文件，则将上面函数client_srv()作为主函数运行</span></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    client_srv()</span><br></pre></td></tr></table></figure><p>以上代码中<code>greetings_client.call(&quot;HAN&quot;,20)</code>等同于<code>greetings_client(&quot;HAN&quot;,20)</code>。</p><h1 id="6-param与time"><a class="markdownIt-Anchor" href="#6-param与time"></a> 6. param与time</h1><h2 id="61-param_demo"><a class="markdownIt-Anchor" href="#61-param_demo"></a> 6.1. param_demo</h2><p>相比roscpp中有两套对param操作的API，rospy关于param的函数就显得简单多了，包括了增删查改等用法： <code>rospy.get_param()</code>，<code>rospy.set_param()</code>，<code>rospy.has_param()</code>，<code>rospy.delete_param()</code>，<code>rospy.search_param()</code>，<code>rospy.get_param_names()</code>。</p><p>下面我们来看看param_demo里的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python</span></span><br><span class="line"><span class="comment"># coding:utf-8</span></span><br><span class="line"><span class="keyword">import</span> rospy</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">param_demo</span>():</span></span><br><span class="line">    rospy.init_node(<span class="string">&quot;param_demo&quot;</span>)</span><br><span class="line">    rate = rospy.Rate(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">not</span> rospy.is_shutdown()):</span><br><span class="line">        <span class="comment">#get param</span></span><br><span class="line">        parameter1 = rospy.get_param(<span class="string">&quot;/param1&quot;</span>)</span><br><span class="line">        parameter2 = rospy.get_param(<span class="string">&quot;/param2&quot;</span>, default=<span class="number">222</span>)</span><br><span class="line">        rospy.loginfo(<span class="string">&#x27;Get param1 = %d&#x27;</span>, parameter1)</span><br><span class="line">        rospy.loginfo(<span class="string">&#x27;Get param2 = %d&#x27;</span>, parameter2)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#delete param</span></span><br><span class="line">        rospy.delete_param(<span class="string">&#x27;/param2&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#set param</span></span><br><span class="line">        rospy.set_param(<span class="string">&#x27;/param2&#x27;</span>,<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#check param</span></span><br><span class="line">        ifparam3 = rospy.has_param(<span class="string">&#x27;/param3&#x27;</span>)</span><br><span class="line">        <span class="keyword">if</span>(ifparam3):</span><br><span class="line">            rospy.loginfo(<span class="string">&#x27;/param3 exists&#x27;</span>)</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rospy.loginfo(<span class="string">&#x27;/param3 does not exist&#x27;</span>)</span><br><span class="line"></span><br><span class="line">        <span class="comment">#get all param names</span></span><br><span class="line">        params = rospy.get_param_names()</span><br><span class="line">        rospy.loginfo(<span class="string">&#x27;param list: %s&#x27;</span>, params)</span><br><span class="line"></span><br><span class="line">        rate.sleep()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__==<span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    param_demo()</span><br></pre></td></tr></table></figure><h2 id="62-time_demo"><a class="markdownIt-Anchor" href="#62-time_demo"></a> 6.2. time_demo</h2><h2 id="63-时钟"><a class="markdownIt-Anchor" href="#63-时钟"></a> 6.3. 时钟</h2><p>rospy中的关于时钟的操作和roscpp是一致的，都有Time、Duration和Rate三个类。 首先，Time和Duration前者标识的是某个时刻（例如今天22:00），而Duration表示的是时长(例如一周)。但他们具有相同的结构（秒和纳秒）：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">int32 secs</span><br><span class="line">int32 secs</span><br></pre></td></tr></table></figure><h3 id="631-创建time和duration"><a class="markdownIt-Anchor" href="#631-创建time和duration"></a> 6.3.1. 创建Time和Duration：</h3><p>rospy中的Time和Duration的构造函数类似，都是<code>_init_(self,secs=0, nsecs=0)</code>,指定秒和纳秒(1ns = 10^{-9}s1<em>n**s</em>=10−9<em>s</em>)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">time_now1 = rospy.get_rostime()  <span class="comment">#当前时刻的Time对象 返回Time对象</span></span><br><span class="line">time_now2 = rospy.Time.now() <span class="comment">#同上</span></span><br><span class="line">time_now3 = rospy.get_time() <span class="comment">#得到当前时间，返回float 4单位秒</span></span><br><span class="line">time_4 = rospy.Time(<span class="number">5</span>)  <span class="comment">#创建5s的时刻</span></span><br><span class="line">duration = rospy.Duration(<span class="number">3</span>*<span class="number">60</span>)  <span class="comment">#创建3min时长</span></span><br></pre></td></tr></table></figure><p>关于Time、Duration之间的加减法和类型转换，和roscpp中的完全一致，请参考5.6节，此处不再重复。</p><h3 id="632-sleep"><a class="markdownIt-Anchor" href="#632-sleep"></a> 6.3.2. sleep</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">duration.sleep()  <span class="comment">#挂起</span></span><br><span class="line">rospy.sleep(duration)  <span class="comment">#同上，这两种方式效果完全一致</span></span><br><span class="line"></span><br><span class="line">loop_rate = Rate(<span class="number">5</span>)     <span class="comment">#利用Rate来控制循环频率</span></span><br><span class="line"><span class="keyword">while</span>(rospy.is_shutdown()):</span><br><span class="line">    loop_rate.sleep()   <span class="comment">#挂起，会考虑上次loop_rate.sleep的时间</span></span><br></pre></td></tr></table></figure><p>关于sleep的方法，Rate类中的sleep主要用来保持一个循环按照固定的频率，循环中一般都是发布消息、执行周期性任务的操作。这里的sleep会考虑上次sleep的时间，从而使整个循环严格按照指定的频率。</p><h3 id="633-定时器timer"><a class="markdownIt-Anchor" href="#633-定时器timer"></a> 6.3.3. 定时器Timer</h3><p>rospy里的定时器和roscpp中的也类似，只不过不是用句柄来创建，而是直接<code>rospy.Timer(Duration, callback)</code>，第一个参数是时长，第二个参数是回调函数。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">my_callback</span>(<span class="params">event</span>):</span></span><br><span class="line">    <span class="built_in">print</span> <span class="string">&#x27;Timer called at &#x27;</span> + <span class="built_in">str</span>(event.current_real)</span><br><span class="line"></span><br><span class="line">rospy.Timer(rospy.Duration(<span class="number">2</span>), my_callback)   <span class="comment">#每2s触发一次callback函数</span></span><br><span class="line">rospy.spin()</span><br></pre></td></tr></table></figure><p>同样不要忘了<code>rospy.spin()</code>，只有spin才能触发回调函数。 回调函数的传入值是<code>TimerEvent</code>类型，该类型包括以下几个属性：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">rospy.TimerEvent</span><br><span class="line">    last_expected</span><br><span class="line">    理想情况下为上一次回调应该发生的时间</span><br><span class="line">    last_real</span><br><span class="line">    上次回调实际发生的时间</span><br><span class="line">    current_expected</span><br><span class="line">    本次回调应该发生的时间</span><br><span class="line">    current_real</span><br><span class="line">    本次回调实际发生的时间</span><br><span class="line">    last_duration</span><br><span class="line">    上次回调所用的时间（结束-开始）</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS-roscpp</title>
      <link href="/posts/3b2a603b.html"/>
      <url>/posts/3b2a603b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note primary flat"><p>📖 许多工具本质上都是基于ROS的客户端库（Client Libarary）实现的，所谓客户端库，简单的理解就是一套接口，ROS为我们机器人开发者提供了不同语言的接口，比如roscpp是C++语言ROS接口，rospy是python语言的ROS接口，我们直接调用它所提供的函数就可以实现topic、service等通信功能。</p></div><hr /><h1 id="1-client-library与roscpp"><a class="markdownIt-Anchor" href="#1-client-library与roscpp"></a> 1. Client Library与roscpp</h1><h2 id="11-client-library简介"><a class="markdownIt-Anchor" href="#11-client-library简介"></a> 1.1. Client Library简介</h2><p>ROS为机器人开发者们提供了不同语言的编程接口，比如C++接口叫做roscpp，Python接口叫做rospy，Java接口叫做rosjava。尽管语言不通，但这些接口都可以用来创建topic、service、param，实现ROS的通信功能。Clinet Lirary有点类似开发中的Helper Class，把一些常用的基本功能做了封装。</p><p>目前ROS支持的Clinet Library包括：</p><table><thead><tr><th style="text-align:center">Client Library</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">roscpp</td><td style="text-align:center">ROS的C++库，是目前最广泛应用的ROS客户端库，执行效率高</td></tr><tr><td style="text-align:center">rospy</td><td style="text-align:center">ROS的Python库，开发效率高，通常用在对运行时间没有太大要求的场合，例如配置、初始化等操作</td></tr><tr><td style="text-align:center">roslisp</td><td style="text-align:center">ROS的LISP库</td></tr><tr><td style="text-align:center">roscs</td><td style="text-align:center">Mono/.NET.库，可用任何Mono/.NET语言，包括C#，Iron Python， Iron Ruby等</td></tr><tr><td style="text-align:center">rosgo</td><td style="text-align:center">ROS Go语言库</td></tr><tr><td style="text-align:center">rosjava</td><td style="text-align:center">ROS Java语言库</td></tr><tr><td style="text-align:center">rosnodejs</td><td style="text-align:center">Javascript客户端库</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>目前最常用的只有roscpp和rospy，而其余的语言版本基本都还是测试版。</p><p>从开发客户端库的角度看，一个客户端库，至少需要能够包括master注册、名称管理、消息收发等功能。这样才能给开发者提供对ROS通信架构进行配置的方法。</p><p>整个ROS包括的packages如下，你可以看到roscpp、rospy处于什么位置。</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/ros_pkgs.png" alt="img" /></p><h2 id="12-roscpp"><a class="markdownIt-Anchor" href="#12-roscpp"></a> 1.2. roscpp</h2><p>roscpp位于<code>/opt/ros/kinetic</code>之下，用C<ins>实现了ROS通信。在ROS中，C</ins>的代码是通过catkin这个编译系统（扩展的CMake）来进行编译构建的。所以简单地理解，你也可以把roscpp就当作为一个C++的库，我们创建一个CMake工程，在其中include了roscpp等ROS的libraries，这样就可以在工程中使用ROS提供的函数了。</p><p>通常我们要调用ROS的C++接口，首先就需要<code>#include</code>。</p><p>roscpp的主要部分包括：</p><ul><li>ros::init() : 解析传入的ROS参数，创建node第一步需要用到的函数</li><li>ros::NodeHandle : 和topic、service、param等交互的公共接口</li><li>ros::master : 包含从master查询信息的函数</li><li>ros::this_node：包含查询这个进程(node)的函数</li><li>ros::service：包含查询服务的函数</li><li>ros::param：包含查询参数服务器的函数，而不需要用到NodeHandle</li><li>ros::names：包含处理ROS图资源名称的函数</li></ul><p>具体可见：<a href="http://docs.ros.org/api/roscpp/html/index.html">http://docs.ros.org/api/roscpp/html/index.html</a></p><p>以上功能可以分为以下几类：</p><ul><li>Initialization and Shutdown 初始与关闭</li><li>Topics 话题</li><li>Services 服务</li><li>Parameter Server 参数服务器</li><li>Timers 定时器</li><li>NodeHandles 节点句柄</li><li>Callbacks and Spinning 回调和自旋（或者翻译叫轮询？）</li><li>Logging 日志</li><li>Names and Node Information 名称管理</li><li>Time 时钟</li><li>Exception 异常</li></ul><p>看到这么多接口，千万别觉得复杂，我们日常开发并不会用到所有的功能，你只需对要有一些印象，掌握几个比较常见和重要的用法就足够了。下面我们来介绍关键的用法。</p><h1 id="2-节点初始-关闭以及nodehandle"><a class="markdownIt-Anchor" href="#2-节点初始-关闭以及nodehandle"></a> 2. 节点初始、关闭以及NodeHandle</h1><p>当执行一个ROS程序，就被加载到了内存中，就成为了一个进程，在ROS里叫做节点。每一个ROS的节点尽管功能不同，但都有必不可少的一些步骤，比如初始化、销毁，需要通行的场景通常都还需要节点的句柄。 这一节我们来学习Node最基本的一些操作。</p><h2 id="21-初始化节点"><a class="markdownIt-Anchor" href="#21-初始化节点"></a> 2.1. 初始化节点</h2><p>对于一个C<ins>写的ROS程序，之所以它区别于普通C</ins>程序，是因为代码中做了两层工作：</p><ol><li>调用了<code>ros::init()</code>函数，从而初始化节点的名称和其他信息，一般我们ROS程序一开始都会以这种方式开始。</li><li>创建<code>ros::NodeHandle</code>对象，也就是节点的句柄，它可以用来创建Publisher、Subscriber以及做其他事情。</li></ol><p>句柄(Handle)这个概念可以理解为一个“把手”，你握住了门把手，就可以很容易把整扇门拉开，而不必关心门是什么样子。NodeHandle就是对节点资源的描述，有了它你就可以操作这个节点了，比如为程序提供服务、监听某个topic上的消息、访问和修改param等等。</p><h2 id="22-关闭节点"><a class="markdownIt-Anchor" href="#22-关闭节点"></a> 2.2. 关闭节点</h2><p>通常我们要关闭一个节点可以直接在终端上按<code>Ctrl</code>+<code>C</code>，系统会自动触发SIGINT句柄来关闭这个进程。 你也可以通过调用<code>ros::shutdown()</code>来手动关闭节点，但通常我们很少这样做。</p><p>以下是一个节点初始化、关闭的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;ros/ros.h&gt;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    ros::init(argc, argv, &quot;your_node_name&quot;); </span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    //....节点功能</span><br><span class="line">    //....</span><br><span class="line">    ros::spin();//用于触发topic、service的响应队列</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是最常见的一个ROS程序的执行步骤，通常要启动节点，获取句柄，而关闭的工作系统自动帮我们完成，如果有特殊需要你也可以自定义。你可能很关心句柄可以用来做些什么，接下来我们来看看NodeHandle常用的成员函数。</p><h2 id="23-nodehandle常用成员函数"><a class="markdownIt-Anchor" href="#23-nodehandle常用成员函数"></a> 2.3. NodeHandle常用成员函数</h2><p>NodeHandle是Node的句柄，用来对当前节点进行各种操作。在ROS中，NodeHandle是一个定义好的类，通过<code>include</code>，我们可以创建这个类，以及使用它的成员函数。</p><p>NodeHandle常用成员函数包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建话题的publisher </span></span><br><span class="line"><span class="function">ros::Publisher <span class="title">advertise</span><span class="params">(<span class="keyword">const</span> string &amp;topic, <span class="keyword">uint32_t</span> queue_size, <span class="keyword">bool</span> latch=<span class="literal">false</span>)</span></span>; </span><br><span class="line"><span class="comment">//第一个参数为发布话题的名称</span></span><br><span class="line"><span class="comment">//第二个是消息队列的最大长度，如果发布的消息超过这个长度而没有被接收，那么就的消息就会出队。通常设为一个较小的数即可。</span></span><br><span class="line"><span class="comment">//第三个参数是是否锁存。某些话题并不是会以某个频率发布，比如/map这个topic，只有在初次订阅或者地图更新这两种情况下，/map才会发布消息。这里就用到了锁存。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建话题的subscriber</span></span><br><span class="line"><span class="function">ros::Subscriber <span class="title">subscribe</span><span class="params">(<span class="keyword">const</span> string &amp;topic, <span class="keyword">uint32_t</span> queue_size, <span class="keyword">void</span>(*)(M))</span></span>;</span><br><span class="line"><span class="comment">//第一个参数是订阅话题的名称</span></span><br><span class="line"><span class="comment">//第二个参数是订阅队列的长度，如果受到的消息都没来得及处理，那么新消息入队，就消息就会出队</span></span><br><span class="line"><span class="comment">//第三个参数是回调函数指针，指向回调函数来处理接收到的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务的server，提供服务</span></span><br><span class="line"><span class="function">ros::ServiceServer <span class="title">advertiseService</span><span class="params">(<span class="keyword">const</span> string &amp;service, <span class="keyword">bool</span>(*srv_func)(Mreq &amp;, Mres &amp;))</span></span>; </span><br><span class="line"><span class="comment">//第一个参数是service名称</span></span><br><span class="line"><span class="comment">//第二个参数是服务函数的指针，指向服务函数。指向的函数应该有两个参数，分别接受请求和响应。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务的client</span></span><br><span class="line"><span class="function">ros::ServiceClient <span class="title">serviceClient</span><span class="params">(<span class="keyword">const</span> string &amp;service_name, <span class="keyword">bool</span> persistent=<span class="literal">false</span>)</span></span>; </span><br><span class="line"><span class="comment">//第一个函数式service名称</span></span><br><span class="line"><span class="comment">//第二个参数用于设置服务的连接是否持续，如果为true，client将会保持与远程主机的连接，这样后续的请求会快一些。通常我们设为flase</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个参数的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getParam</span><span class="params">(<span class="keyword">const</span> string &amp;key, std::string &amp;s)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">double</span> &amp;d)</span> <span class="keyword">const</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> &amp;i)</span> <span class="keyword">const</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//从参数服务器上获取key对应的值，已重载了多个类型</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//给参数赋值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">const</span> std::string &amp;s)</span> <span class="keyword">const</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//给key对应的val赋值，重载了多个类型的val</span></span><br></pre></td></tr></table></figure><p>可以看出，NodeHandle对象在ROS C++程序里非常重要，各种类型的通信都需要用NodeHandle来创建完成。 下面我们具体来看topic、service和param这三种基本通信方式的写法。</p><h1 id="3-topic-in-roscpp"><a class="markdownIt-Anchor" href="#3-topic-in-roscpp"></a> 3. topic in roscpp</h1><h2 id="31-topic通信"><a class="markdownIt-Anchor" href="#31-topic通信"></a> 3.1. Topic通信</h2><p>Topic是ROS里一种异步通信的模型，一般是节点间分工明确，有的只负责发送，有的只负责接收处理。对于绝大多数的机器人应用场景，比如传感器数据收发，速度控制指令的收发，Topic模型是最适合的通信方式。</p><p>为了讲明白topic通信的编程思路，我们首先来看<code>topic_demo</code>中的代码,这个程序是一个消息收发的例子：<strong>自定义一个类型为gps的消息（包括位置x，y和工作状态state信息），一个node以一定频率发布模拟的gps消息，另一个node接收并处理，算出到原点的距离。</strong> 源代码见<code>ROS-Academy-for-Beginners/topic_demo</code></p><h2 id="32-创建gps消息"><a class="markdownIt-Anchor" href="#32-创建gps消息"></a> 3.2. 创建gps消息</h2><p>在代码中，我们会用到自定义类型的gps消息，因此就需要来自定义gps消息，在msg路径下创建<code>gps.msg</code>： 见<code>topic_demo/msg/gps.msg</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string state   #工作状态</span><br><span class="line">float32 x      #x坐标</span><br><span class="line">float32 y      #y坐标</span><br></pre></td></tr></table></figure><p>以上就定义了一个gps类型的消息，你可以把它理解成一个C语言中的结构体，类似于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gps</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string state;</span><br><span class="line">    float32 x;</span><br><span class="line">    float32 y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中对一个gps消息进行创建修改的方法和对结构体的操作一样。</p><p>当你创建完了msg文件，记得修改<code>CMakeLists.txt</code>和<code>package.xml</code>，从而让系统能够编译自定义消息。 在<code>CMakeLists.txt</code>中需要改动</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">roscpp</span><br><span class="line">std_msgs</span><br><span class="line">message_generation   <span class="comment">#需要添加的地方</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_message_files(FILES gps.msg)  </span><br><span class="line"><span class="comment">#catkin在cmake之上新增的命令，指定从哪个消息文件生成</span></span><br><span class="line"></span><br><span class="line">generate_messages(DEPENDENCIES std_msgs) </span><br><span class="line"><span class="comment">#catkin新增的命令，用于生成消息</span></span><br><span class="line"><span class="comment">#DEPENDENCIES后面指定生成msg需要依赖其他什么消息，由于gps.msg用到了flaot32这种ROS标准消息，因此需要再把std_msgs作为依赖</span></span><br></pre></td></tr></table></figure><p><code>package.xml</code>中需要的改动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你完成了以上所有工作，就可以回到工作空间，然后编译了。编译完成之后会在<code>devel</code>路径下生成<code>gps.msg</code>对应的头文件，头文件按照C++的语法规则定义了<code>topic_demo::gps</code>类型的数据。</p><p>要在代码中使用自定义消息类型，只要<code>#include</code>，然后声明，按照对结构体操作的方式修改内容即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">topic_demo::gps mygpsmsg;</span><br><span class="line">mygpsmsg.x = <span class="number">1.6</span>;</span><br><span class="line">mygpsmsg.y = <span class="number">5.5</span>;</span><br><span class="line">mygpsmsg.state = <span class="string">&quot;working&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="33-消息发布节点"><a class="markdownIt-Anchor" href="#33-消息发布节点"></a> 3.3. 消息发布节点</h2><p>定义完了消息，就可以开始写ROS代码了。通常我们会把消息收发的两端分成两个节点来写，一个节点就是一个完整的C++程序。</p><p>见<code>topic_demo/src/talker.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;topic_demo/gps.h&gt;</span>  <span class="comment">//自定义msg产生的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);  <span class="comment">//用于解析ROS参数，第三个参数为本节点名</span></span><br><span class="line">  ros::NodeHandle nh;    <span class="comment">//实例化句柄，初始化node</span></span><br><span class="line"></span><br><span class="line">  topic_demo::gps msg;  <span class="comment">//自定义gps消息并初始化 </span></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  ros::Publisher pub = nh.advertise&lt;topic_demo::gps&gt;(<span class="string">&quot;gps_info&quot;</span>, <span class="number">1</span>); <span class="comment">//创建publisher，往&quot;gps_info&quot;话题上发布消息</span></span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1.0</span>)</span></span>;   <span class="comment">//定义发布的频率，1HZ </span></span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())   <span class="comment">//循环发布msg</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...   <span class="comment">//处理msg</span></span><br><span class="line">    pub.<span class="built_in">publish</span>(msg);<span class="comment">//以1Hz的频率发布msg</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();<span class="comment">//根据前面的定义的loop_rate,设置1s的暂停</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>机器人上几乎所有的传感器，几乎都是按照固定频率发布消息这种通信方式来传输数据，只是发布频率和数据类型的区别。</p><h2 id="34-消息接收节点"><a class="markdownIt-Anchor" href="#34-消息接收节点"></a> 3.4. 消息接收节点</h2><p>见<code>topic_demo/src/listener.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;topic_demo/gps.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_msgs/Float32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpsCallback</span><span class="params">(<span class="keyword">const</span> topic_demo::gps::ConstPtr &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    std_msgs::Float32 distance;  <span class="comment">//计算离原点(0,0)的距离</span></span><br><span class="line">    distance.data = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(msg-&gt;x,<span class="number">2</span>)+<span class="built_in">pow</span>(msg-&gt;y,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Listener: Distance to origin = %f, state: %s&quot;</span>,distance.data,msg-&gt;state.<span class="built_in">c_str</span>()); <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;gps_info&quot;</span>, <span class="number">1</span>, gpsCallback);  <span class="comment">//设置回调函数gpsCallback</span></span><br><span class="line">  ros::<span class="built_in">spin</span>(); <span class="comment">//ros::spin()用于调用所有可触发的回调函数，将进入循环，不会返回，类似于在循环里反复调用spinOnce() </span></span><br><span class="line">  <span class="comment">//而ros::spinOnce()只会去触发一次</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在topic接收方，有一个比较重要的概念，就是<strong>回调(CallBack)</strong>，在本例中，回调就是预先给<code>gps_info</code>话题传来的消息准备一个回调函数，你事先定义好回调函数的操作，本例中是计算到原点的距离。只有当有消息来时，回调函数才会被触发执行。具体去触发的命令就是<code>ros::spin()</code>，它会反复的查看有没有消息来，如果有就会让回调函数去处理。</p><p>因此千万不要认为，只要指定了回调函数，系统就回去自动触发，你必须<code>ros::spin()</code>或者<code>ros::spinOnce()</code>才能真正使回调函数生效。</p><h2 id="35-cmakeliststxt文件修改"><a class="markdownIt-Anchor" href="#35-cmakeliststxt文件修改"></a> 3.5. CMakeLists.txt文件修改</h2><p>在<code>CMakeLists.txt</code>添加以下内容，生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(talker src/talker.cpp) <span class="comment">#生成可执行文件talker</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(talker topic_demo_generate_messages_cpp)</span><br><span class="line"><span class="comment">#表明在编译talker前，必须先生编译完成自定义消息</span></span><br><span class="line"><span class="comment">#必须添加add_dependencies，否则找不到自定义的msg产生的头文件</span></span><br><span class="line"><span class="comment">#表明在编译talker前，必须先生编译完成自定义消息</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(talker <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>) <span class="comment">#链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(listener src/listener.cpp ) <span class="comment">#声称可执行文件listener</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(listener topic_demo_generate_messages_cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#链接</span></span><br></pre></td></tr></table></figure><p>以上cmake语句告诉catkin编译系统如何去编译生成我们的程序。这些命令都是标准的cmake命令，如果不理解，请查阅cmake教程。</p><p>之后经过<code>catkin_make</code>，一个自定义消息+发布接收的基本模型就完成了。</p><h2 id="36-扩展回调函数与spin方法"><a class="markdownIt-Anchor" href="#36-扩展回调函数与spin方法"></a> 3.6. 扩展：回调函数与spin()方法</h2><p>回调函数在编程中是一种重要的方法，在维基百科上的解释是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In computer programming, a callback is any executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at a given time.</span><br></pre></td></tr></table></figure><p>回调函数作为参数被传入到了另一个函数中（在本例中传递的是函数指针），在未来某个时刻（当有新的message到达），就会立即执行。Subscriber接收到消息，实际上是先把消息放到一个<strong>队列</strong>中去，如图所示。队列的长度在Subscriber构建的时候设置好了。当有spin函数执行，就会去处理消息队列中队首的消息。</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/cb_queue.png" alt="img" /></p><p>spin具体处理的方法又可分为阻塞/非阻塞,单线程/多线程，在ROS函数接口层面我们有4种spin的方式：</p><table><thead><tr><th style="text-align:center">spin方法</th><th style="text-align:center">阻塞</th><th style="text-align:center">线程</th></tr></thead><tbody><tr><td style="text-align:center"><code>ros::spin()</code></td><td style="text-align:center">阻塞</td><td style="text-align:center">单线程</td></tr><tr><td style="text-align:center"><code>ros::spinOnce()</code></td><td style="text-align:center">非阻塞</td><td style="text-align:center">单线程</td></tr><tr><td style="text-align:center"><code>ros::MultiThreadedSpin()</code></td><td style="text-align:center">阻塞</td><td style="text-align:center">多线程</td></tr><tr><td style="text-align:center"><code>ros::AsyncMultiThreadedSpin()</code></td><td style="text-align:center">非阻塞</td><td style="text-align:center">多线程</td></tr></tbody></table><p>阻塞与非阻塞的区别我们已经讲了，下面来看看单线程与多线程的区别：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/single-multi-spin.png" alt="img" /></p><p>我们常用的<code>spin()</code>、<code>spinOnce()</code>是单个线程逐个处理回调队列里的数据。有些场合需要用到多线程分别处理，则可以用到<code>MultiThreadedSpin()</code>、<code>AsyncMultiThreadedSpin()</code>。</p><h1 id="4-service-in-roscpp"><a class="markdownIt-Anchor" href="#4-service-in-roscpp"></a> 4. service in roscpp</h1><h2 id="41-service通信"><a class="markdownIt-Anchor" href="#41-service通信"></a> 4.1. Service通信</h2><p>Service是一种请求-反馈的通信机制。请求的一方通常被称为客户端，提供服务的一方叫做服务器端。Service机制相比于Topic的不同之处在于：</p><ol><li>消息的传输是双向的，有反馈的，而不是单一的流向。</li><li>消息往往不会以固定频率传输，不连续，而是在需要时才会向服务器发起请求。</li></ol><p>在ROS中如何请求或者提供一个服务，我们来看<code>service_demo</code>的代码：<strong>一个节点发出服务请求（姓名，年龄），另一个节点进行服务响应，答复请求。</strong></p><h2 id="42-创建greeting服务"><a class="markdownIt-Anchor" href="#42-创建greeting服务"></a> 4.2. 创建Greeting服务</h2><p>创建<code>service_demo/Greeting.srv</code>文件，内容包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string name        #短横线上边部分是服务请求的数据</span><br><span class="line">int32 age          </span><br><span class="line">---                #短横线下面是服务回传的内容。</span><br><span class="line">string feedback</span><br></pre></td></tr></table></figure><p>srv格式的文件创建后，也需要修改<code>CMakeLissts.txt</code>,在其中加入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(FILES Greeting.srv)</span><br></pre></td></tr></table></figure><p>其余与添加msg的改动一样。然后进行<code>catkin_make</code>，系统就会生成在代码中可用的Greeting类型。在代码中使用,只需要<code>#include</code>，然后即可创建该类型的srv。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service_demo::Greeting grt;  <span class="comment">//grt分为grt.request和grt.response两部分</span></span><br><span class="line">grt.request.name = <span class="string">&quot;HAN&quot;</span>; <span class="comment">//不能用grt.name或者grt.age来访问  </span></span><br><span class="line">grt.request.age = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>新生成的Greeting类型的服务，其结构体的风格更为明显，可以这么理解，一个Greeting服务结构体中嵌套了两个结构体，分别是请求和响应：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Greeting</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Request</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        string name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    &#125;request;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        string feedback;</span><br><span class="line">    &#125;response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43-创建提供服务节点server"><a class="markdownIt-Anchor" href="#43-创建提供服务节点server"></a> 4.3. 创建提供服务节点(server)</h2><p><code>service_demo/srv/server.cpp</code>内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;service_demo/Greeting.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_function</span><span class="params">(service_demo::Greeting::Request &amp;req, service_demo::Greeting::Response &amp;res)</span></span>&#123;</span><br><span class="line">    <span class="comment">//显示请求信息</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(“Request from %s with age %d”, req.name.<span class="built_in">c_str</span>(), req.age);</span><br><span class="line">    <span class="comment">//处理请求，结果写入response</span></span><br><span class="line">    res.feedback = “Hi ” + req.name + “. I’m server!”;</span><br><span class="line">    <span class="comment">//返回true，正确处理了请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, “greetings_server”);        <span class="comment">//解析参数，命名节点</span></span><br><span class="line">    ros::NodeHandle nh;                       <span class="comment">//创建句柄，实例化node</span></span><br><span class="line">    ros::ServiceServer service = nh.<span class="built_in">advertiseService</span>(“greetings”, handle_function);  <span class="comment">//写明服务的处理函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，服务的处理操作都写在<code>handle_function()</code>中，它的输入参数就是Greeting的Request和Response两部分，而非整个Greeting对象。通常在处理函数中，我们对Requst数据进行需要的操作，将结果写入到Response中。在roscpp中，处理函数返回值是bool型，也就是服务是否成功执行。不要理解成输入Request，返回Response，在rospy中是这样的。</p><h2 id="44-创建服务请求节点client"><a class="markdownIt-Anchor" href="#44-创建服务请求节点client"></a> 4.4. 创建服务请求节点(client)</h2><p><code>service_demo/srv/client.cpp</code>内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;service_demo/Greeting.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;greetings_client&quot;</span>);<span class="comment">// 初始化，节点命名为&quot;greetings_client&quot;</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceClient client = nh.serviceClient&lt;service_demo::Greeting&gt;(<span class="string">&quot;greetings&quot;</span>);</span><br><span class="line">    <span class="comment">// 定义service客户端，service名字为“greetings”，service类型为Service_demo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化srv，设置其request消息的内容，这里request包含两个变量，name和age，见Greeting.srv</span></span><br><span class="line">    service_demo::Greeting srv;</span><br><span class="line">    srv.request.name = <span class="string">&quot;HAN&quot;</span>;</span><br><span class="line">    srv.request.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client.<span class="built_in">call</span>(srv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意我们的response部分中的内容只包含一个变量response，另，注意将其转变成字符串</span></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Response from server: %s&quot;</span>, srv.response.feedback.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service Service_demo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较关键的地方有两处，一个是建立一个ServiceClient，另一个是开始调用服务。建立client需要用<code>nh.serviceClient(&quot;greetings&quot;)</code>，指明服务的类型和服务的名称。而调用时可以直接用<code>client.call(srv)</code>，返回结果不是response，而是是否成功调用远程服务。</p><p><code>CMakeLists.txt</code>和<code>pacakge.xml</code>修改方法和<code>topic_demo</code>修改方法类似，不再赘述。</p><h1 id="5-param-in-roscpp"><a class="markdownIt-Anchor" href="#5-param-in-roscpp"></a> 5. param in roscpp</h1><h2 id="51-parameter-server"><a class="markdownIt-Anchor" href="#51-parameter-server"></a> 5.1. Parameter Server</h2><p>严格来说，param并不能称作一种通信方式，因为它往往只是用来存储一些静态的设置，而不是动态变化的。所以关于param的操作非常轻巧，非常简单。 关于param的API，roscpp为我们提供了两套，一套是放在<code>ros::param</code>namespace下，另一套是在<code>ros::NodeHandle</code>下，这两套API的操作完全一样，用哪一个取决于你的习惯。</p><h2 id="52-param_demo"><a class="markdownIt-Anchor" href="#52-param_demo"></a> 5.2. param_demo</h2><p>我们来看看在C++中如何进行param_demo的操作，<code>param_demo/param.cpp</code>文件，内容包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_demo&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="keyword">int</span> parameter1, parameter2, parameter3, parameter4, parameter5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Get Param的三种方法</span></span><br><span class="line">    <span class="comment">//① ros::param::get()获取参数“param1”的value，写入到parameter1上</span></span><br><span class="line">    <span class="keyword">bool</span> ifget1 = ros::param::<span class="built_in">get</span>(<span class="string">&quot;param1&quot;</span>, parameter1);</span><br><span class="line">    <span class="comment">//② ros::NodeHandle::getParam()获取参数，与①作用相同</span></span><br><span class="line">    <span class="keyword">bool</span> ifget2 = nh.<span class="built_in">getParam</span>(<span class="string">&quot;param2&quot;</span>,parameter2);</span><br><span class="line">    <span class="comment">//③ ros::NodeHandle::param()类似于①和②</span></span><br><span class="line">    <span class="comment">//但如果get不到指定的param，它可以给param指定一个默认值(如33333)</span></span><br><span class="line">        nh.<span class="built_in">param</span>(<span class="string">&quot;param3&quot;</span>, parameter3, <span class="number">33333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ifget1) <span class="comment">//param是否取得</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set Param</span></span><br><span class="line">    <span class="comment">//① ros::param::set()设置参数</span></span><br><span class="line">    parameter4 = <span class="number">4</span>;</span><br><span class="line">    ros::param::<span class="built_in">set</span>(<span class="string">&quot;param4&quot;</span>, parameter4);</span><br><span class="line">    <span class="comment">//② ros::NodeHandle::setParam()设置参数</span></span><br><span class="line">    parameter5 = <span class="number">5</span>;</span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;param5&quot;</span>,parameter5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check Param</span></span><br><span class="line">    <span class="comment">//① ros::NodeHandle::hasParam()</span></span><br><span class="line">    <span class="keyword">bool</span> ifparam5 = nh.<span class="built_in">hasParam</span>(<span class="string">&quot;param5&quot;</span>);</span><br><span class="line">    <span class="comment">//② ros::param::has()</span></span><br><span class="line">    <span class="keyword">bool</span> ifparam6 = ros::param::<span class="built_in">has</span>(<span class="string">&quot;param6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Delete Param</span></span><br><span class="line">    <span class="comment">//① ros::NodeHandle::deleteParam()</span></span><br><span class="line">    <span class="keyword">bool</span> ifdeleted5 = nh.<span class="built_in">deleteParam</span>(<span class="string">&quot;param5&quot;</span>);</span><br><span class="line">    <span class="comment">//② ros::param::del()</span></span><br><span class="line">    <span class="keyword">bool</span> ifdeleted6 = ros::param::<span class="built_in">del</span>(<span class="string">&quot;param6&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是roscpp中对param进行增删改查所有操作的方法，非常直观。</p><h2 id="53-param_demo中的launch文件"><a class="markdownIt-Anchor" href="#53-param_demo中的launch文件"></a> 5.3. param_demo中的launch文件</h2><p>实际项目中我们对参数进行设置，尤其是添加参数，一般都不是在程序中，而是在launch文件中。因为launch文件可以方便的修改参数，而写成代码之后，修改参数必须重新编译。 因此我们会在launch文件中将param都定义好，比如这个demo正确的打开方式应该是<code>roslaunch param_demo param_demo_cpp.launch</code></p><p><code>param_demo/launch/param_demo_cpp.launch</code>内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--param参数配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--rosparam参数配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>&gt;</span>   </span><br><span class="line">        param3: 3</span><br><span class="line">        param4: 4</span><br><span class="line">        param5: 5</span><br><span class="line">       <span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以上写法将参数转成YAML文件加载，注意param前面必须为空格，不能用Tab，否则YAML解析错误--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rosparam file=&quot;$(find robot_sim_demo)/config/xbot2_control.yaml&quot; command=&quot;load&quot; /--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">name</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过和两个标签我们设置好了5个param，从而在之前的代码中进行增删改查的操作。</p><h2 id="54-命名空间对param的影响"><a class="markdownIt-Anchor" href="#54-命名空间对param的影响"></a> 5.4. 命名空间对param的影响</h2><p>在实际的项目中，实例化句柄时，经常会看到两种不同的写法 ros::NodeHandle n; ros::NodeHandle nh(&quot;~&quot;);` 这两种写法有什么不同呢？以本教学报的name_demo为例。在本节launch文件夹的demo.launch定义两个参数，一个全局serial 他的数值是5,一个是局部的serial，他的数值是10.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--全局参数serial--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;name_demo&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;name_demo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;name_demo&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--局部参数serial--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在name_demo.cpp中，我们分别尝试了，利用全局命名空间句柄提取全局的param和局部的param，以及在局部命名空间下的句柄提取全局的param和局部的param，详细的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serial_number = <span class="number">-1</span>;<span class="comment">//serial_number初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;name_demo&quot;</span>);<span class="comment">//node初始化</span></span><br><span class="line">    <span class="comment">/*创建命名空间*/</span></span><br><span class="line">    <span class="comment">//n 是全局命名空间</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="comment">//nh 是局部命名空间</span></span><br><span class="line">    <span class="function">ros::NodeHandle <span class="title">nh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">/*全局命名空间下的Param*/</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;global namespace&quot;</span>);</span><br><span class="line">    <span class="comment">//提取全局命名空间下的参数serial</span></span><br><span class="line">    n.<span class="built_in">getParam</span>(<span class="string">&quot;serial&quot;</span>, serial_number);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;global_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    <span class="comment">//提取局部命名空间下的参数serial</span></span><br><span class="line">    n.<span class="built_in">getParam</span>(<span class="string">&quot;name_demo/serial&quot;</span>, serial_number);<span class="comment">//在全局命名空间下，要提取局部命名空间下的参数，需要添加node name</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;global_to_local_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    <span class="comment">/*局部命名空间下的Param*/</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;local namespace&quot;</span>);</span><br><span class="line">    <span class="comment">//提取局部命名空间下的参数serial</span></span><br><span class="line">    nh.<span class="built_in">getParam</span>(<span class="string">&quot;serial&quot;</span>, serial_number);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;local_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    <span class="comment">//提取全局命名空间下的参数serial</span></span><br><span class="line">    nh.<span class="built_in">getParam</span>(<span class="string">&quot;/serial&quot;</span>, serial_number);<span class="comment">//在局部命名空间下，要提取全局命名空间下的参数，需要添加“/”</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;local_to_global_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ INFO] [1525095241.802257811]: global namespace</span><br><span class="line">[ INFO] [1525095241.803512501]: global_Serial was 5</span><br><span class="line">[ INFO] [1525095241.804515959]: global_to_local_Serial was 10</span><br><span class="line">[ INFO] [1525095241.804550167]: local namespace</span><br><span class="line">[ INFO] [1525095241.805126562]: local_Serial was 10</span><br><span class="line">[ INFO] [1525095241.806137701]: local_to_global_Serial was 5</span><br></pre></td></tr></table></figure><h1 id="6-时钟"><a class="markdownIt-Anchor" href="#6-时钟"></a> 6. 时钟</h1><h2 id="61-time-与-duration"><a class="markdownIt-Anchor" href="#61-time-与-duration"></a> 6.1. Time 与 Duration</h2><p>ROS里经常用到的一个功能就是时钟，比如计算机器人移动距离、设定一些程序的等待时间、设定计时器等等。roscpp同样给我们提供了时钟方面的操作。<br />具体来说，roscpp里有两种时间的表示方法，一种是时刻（ros::Time），一种是时长（ros::Duration）。无论是Time还是Duration都具有相同的表示方法：<br />···<br />int32 sec<br />int32 nsec<br />···<br />Time/Duration都由秒和纳秒组成。 要使用Time和Duration，需要<code>#include</code>和<code>#include</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ros::Time begin = ros::Time::<span class="built_in">now</span>(); <span class="comment">//获取当前时间</span></span><br><span class="line"><span class="function">ros::Time <span class="title">at_some_time1</span><span class="params">(<span class="number">5</span>,<span class="number">20000000</span>)</span></span>;  <span class="comment">//5.2s</span></span><br><span class="line"><span class="function">ros::Time <span class="title">at_some_time2</span><span class="params">(<span class="number">5.2</span>)</span> <span class="comment">//同上，重载了float类型和两个uint类型的构造函数</span></span></span><br><span class="line"><span class="function">ros::Duration <span class="title">one_hour</span><span class="params">(<span class="number">60</span>*<span class="number">60</span>,<span class="number">0</span>)</span></span>; <span class="comment">//1h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> secs1 = at_some_time1.<span class="built_in">toSec</span>();<span class="comment">//将Time转为double型时间</span></span><br><span class="line"><span class="keyword">double</span> secs2 = one_hour.<span class="built_in">toSec</span>();<span class="comment">//将Duration转为double型时间</span></span><br></pre></td></tr></table></figure><p>Time和Duration表示的概念并不相同，Time指的是某个时刻，而Duration指的是某个时段，尽管他们的数据结构都相同，但是用在不同的场景下。 ROS为我们重载了Time、Duration类型之间的加减运算，比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ros::Time t1 = ros::Time::<span class="built_in">now</span>() - ros::<span class="built_in">Duration</span>(<span class="number">5.5</span>); <span class="comment">//t1是5.5s前的时刻，Time加减Duration返回都是Time</span></span><br><span class="line">ros::Time t2 = ros::Time::<span class="built_in">now</span>() + ros::<span class="built_in">Duration</span>(<span class="number">3.3</span>);<span class="comment">//t2是当前时刻往后推3.3s的时刻</span></span><br><span class="line">ros::Duration d1 = t2 - t1;<span class="comment">//从t1到t2的时长，两个Time相减返回Duration类型</span></span><br><span class="line">ros::Duration d2 = d1 -ros::<span class="built_in">Duration</span>(<span class="number">0</span>,<span class="number">300</span>);<span class="comment">//两个Duration相减，还是Duration</span></span><br></pre></td></tr></table></figure><p>以上是Time、Duration之间的加减运算，要注意没有Time+Time的做法。</p><h2 id="62-sleep"><a class="markdownIt-Anchor" href="#62-sleep"></a> 6.2. sleep</h2><p>通常在机器人任务执行中可能有需要等待的场景，这时就要用到sleep功能，roscpp中提供了两种sleep的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>).<span class="built_in">sleep</span>(); <span class="comment">//用Duration对象的sleep方法休眠</span></span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//10HZ</span></span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    r.<span class="built_in">sleep</span>();     </span><br><span class="line">    <span class="comment">//定义好sleep的频率，Rate对象会自动让整个循环以10hz休眠，即使有任务执行占用了时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="63-timer"><a class="markdownIt-Anchor" href="#63-timer"></a> 6.3. Timer</h2><p>Rate的功能是指定一个频率，让某些动作按照这个频率来循环执行。与之类似的是ROS中的定时器Timer，它是通过设定回调函数和触发时间来实现某些动作的反复执行，创建方法和topic中的subscriber很像。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback1</span><span class="params">(<span class="keyword">const</span> ros::TimerEvent&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Callback 1 triggered&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback2</span><span class="params">(<span class="keyword">const</span> ros::TimerEvent&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Callback 2 triggered&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  ros::Timer timer1 = n.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">0.1</span>), callback1);  <span class="comment">//timer1每0.1s触发一次callback1函数</span></span><br><span class="line">  ros::Timer timer2 = n.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>), callback2);  <span class="comment">//timer2每1.0s触发一次callback2函数</span></span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();  <span class="comment">//千万别忘了spin，只有spin了才能真正去触发回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS-TF与URDF</title>
      <link href="/posts/28077269.html"/>
      <url>/posts/28077269.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note primary flat"><p>📖 机器人的坐标变换一直以来是机器人学的一个难点，我们人类在进行一个简单的动作时，从思考到实施行动再到完成动作可能仅仅需要几秒钟，但是机器人来讲就需要大量的计算和坐标转换。</p></div><hr /><h1 id="1-认识tf"><a class="markdownIt-Anchor" href="#1-认识tf"></a> 1. 认识TF</h1><h2 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1. 简介</h2><p>TF是一个ROS世界里的一个基本的也是很重要的概念，所谓TF(TransForm)，就是坐标转换．在现实生活中，我们做出各种行为模式都可以在很短的时间里完成，比如拿起身边的物品，但是在机器人的世界里，则远远没有那么简单．观察下图，我们来分析机器人拿起身边的物品需要做到什么，而TF又起到什么样的作用．</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/pr2_tf.png" alt="img" /></p><p>观察这个机器人，我们直观上不认为拿起物品会又什么难度，站在人类的立场上，我们也许会想到手向前伸，抓住，手收回．就完成了这整个一系列的动作．但是如今的机器人远远没有这么智能，它能得到的只是各种传感器发送回来的数据，然后它再处理各种数据进行操作，比如手臂弯曲45度，再向前移动２０cm等这样的各种十分精确的数据，尽管如此，机器人依然没法做到像人类一样自如的进行各种行为操作．那么在这个过程中，TF又扮演着什么样的角色呢？还拿该图来说，当机器人的＂眼睛＂获取一组数据，关于物体的坐标方位，但是相对于机器人手臂来说，<strong>这个坐标只是相对于机器人头部的传感器，并不直接适用于机器人手臂执行，那么物体相对于头部和手臂之间的坐标转换，就是TF.</strong></p><p>坐标变换包括了位置和姿态两个方面的变换，ROS中的tf是一个可以让用户随时记录多个坐标系的软件包。tf保持缓存的树形结构中的坐标系之间的关系，并且允许用户在任何期望的时间点在任何两个坐标系之间转换点，矢量等．</p><h2 id="12-ros中的tf"><a class="markdownIt-Anchor" href="#12-ros中的tf"></a> 1.2. ROS中的TF</h2><p>tf的定义不是那么的死板，它可以被当做是一种标准规范，这套标准定义了坐标转换的数据格式和数据结构．tf本质是树状的数据结构，所以我们通常称之为**“tf tree”**,tf也可以看成是一个topic:<code>/tf</code>，话题中的message保存的就是tf tree的数据结构格式．维护了整个机器人的甚至是地图的坐标转换关系．tf还可以看成是一个package,它当中包含了很多的工具．比如可视化，查看关节间的tf,debug tf等等．tf含有一部分的接口，就是我们前面章节介绍的roscpp和rospy里关于tf的API．所以可以看成是话题转换的标准，工具，接口．</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/tf_wiki.png" alt="img" /></p><p>观察上图，我们可以看到ROS数据结构的一个抽象图，ROS中机器人模型包含大量的部件，这些部件统称之为<strong>link</strong>,每一个link上面对应着一个<strong>frame</strong>, 即一个坐标系．<strong>link和frame概念是绑定在一起的</strong>．像上图pr2模型中我们可以看到又很多的frame,错综复杂的铺置在机器人的各个link上，维护各个坐标系之间的关系，就要靠着<strong>tf tree</strong>来处理，维护着各个坐标系之间的联通．如下图：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/tf_tree_pr2.png" alt="img" /></p><p>上图是我们常用的robot_sim_demo运行起来的tf　tree结构，每一个圆圈代表一个frame,对应着机器人上的一个link，<strong>任意的两个frame之间都必须是联通的</strong>，如果出现某一环节的断裂，<strong>就会引发error系统报错</strong>．<strong>所以完整的tf tree不能有任何断层的地方</strong>，这样我们才能查清楚任意两个frame之间的关系．仔细观察上图，我们发现每两个frame之间都有一个<strong>broadcaster</strong>,这就是为了使得两个frame之间能够正确连通，中间都会有一个Node来发布消息来broadcaster.如果缺少Node来发布消息维护连通，那么这两个frame之间的连接就会断掉．<strong>broadcaster就是一个publisher,如果两个frame之间发生了相对运动</strong>，broadcaster就会发布相关消息．</p><h1 id="2-tf消息"><a class="markdownIt-Anchor" href="#2-tf消息"></a> 2. TF消息</h1><h2 id="21-transformstampedmsg"><a class="markdownIt-Anchor" href="#21-transformstampedmsg"></a> 2.1. TransformStamped.msg</h2><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/tf_tree_pr2.png" alt="img" /></p><p>上一节在介绍ROS中的TF时候我们已经初步的认识了TF和TF树，<strong>了解了在每个frame之间都会有broadcaster来发布消息维系坐标转换</strong>．那么这个消息到底是什么样子的呢？这个消息TransformStampde.msg,它就是处理两个frame之间一小段tf的数据格式．</p><h2 id="22-格式规范"><a class="markdownIt-Anchor" href="#22-格式规范"></a> 2.2. 格式规范</h2><p>TransformStamped.msg的格式规范如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">std_mags/Header header</span><br><span class="line">        uint32 seq</span><br><span class="line">        time stamp</span><br><span class="line">        string frame_id</span><br><span class="line">string child_frame_id</span><br><span class="line">geometry_msgs/Transform transform</span><br><span class="line">        geometry_msgs/Vector3 translation</span><br><span class="line">                float64 x</span><br><span class="line">                float64 y</span><br><span class="line">                float64 z</span><br><span class="line">        geometry_msgs/Quaternion rotation</span><br><span class="line">                float64 x</span><br><span class="line">                float64 y</span><br><span class="line">                flaot64 z</span><br><span class="line">                float64 w</span><br></pre></td></tr></table></figure><p>观察标准的格式规范，首先header定义了序号，时间以及frame的名称．接着还写了child_frame，这两个frame之间要做那种变换就是由geometry_msgs/Transform来定义．Vector3三维向量表示平移，Quaternion四元数表示旋转．像下图TF树中的两个frame之间的消息，就是由这种格式来定义的．odom就是frame_id,baselink_footprint就是child_frame_id.我们知道，一个topic上面可能会有很多个node向上面发送消息。如图所示，不仅有我们看到的frame发送坐标变换个tf，还有别的frame也在同样的向它发送消息。最终，许多的TransformStamped.msg发向tf，形成了TF树。</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/tf_tree.jpg" alt="img" /></p><h2 id="23-tf树的数据类型"><a class="markdownIt-Anchor" href="#23-tf树的数据类型"></a> 2.3. TF树的数据类型</h2><p>上面我们讲了，TF tree是由很多的frame之间TF拼接而成。那么TF tree是什么类型呢？如下：</p><ul><li>tf/tfMessage.msg</li><li>tf2_msgs/TFMessage.msg</li></ul><p>这里TF的数据类型有两个，主要的原因是版本的迭代。自ROS Hydro以来，tf第一代已被“弃用”，转而支持tf2。tf2相比tf更加简单高效。此外也添加了一些新的功能。</p><p>由于tf2是一个重大的变化，tf API一直保持现有的形式。由于tf2具有tf特性的超集和一部分依赖关系，所以tf实现已经被移除，并被引用到tf2下。这意味着所有用户都将与tf2兼容。官网建议新工作直接使用tf2，因为它有一个更清洁的界面，和更好的使用体验。</p><p>如何查看自己使用的TF是哪一个版本，使用命令<code>rostopic info /tf</code>即可。</p><h2 id="24-格式定义"><a class="markdownIt-Anchor" href="#24-格式定义"></a> 2.4. 格式定义</h2><p>tf/tfMessage.msg或tf2_msgs/TFMessage标准格式规范如下:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">geometry_msgs/TransformStamped[] transforms</span><br><span class="line">        std_msgs/Header header</span><br><span class="line">                uint32 seq</span><br><span class="line">                time stamp</span><br><span class="line">                string frame_id</span><br><span class="line">        string child_frame_id</span><br><span class="line">        geometry_msgs/Transform transform</span><br><span class="line">                geometry_msgs/Vector3 translation</span><br><span class="line">                        float64 x</span><br><span class="line">                        float64 y</span><br><span class="line">                        float64 z</span><br><span class="line">                geometry_msgs/Quaternion rotation</span><br><span class="line">                        float64 x</span><br><span class="line">                        float64 y</span><br><span class="line">                        flaot64 z</span><br><span class="line">                        float64 w</span><br></pre></td></tr></table></figure><p>如上，一个TransformStamped数组就是一个TF tree。</p><h1 id="3-tf-in-c"><a class="markdownIt-Anchor" href="#3-tf-in-c"></a> 3. tf in c++</h1><h2 id="31-简介"><a class="markdownIt-Anchor" href="#31-简介"></a> 3.1. 简介</h2><p>前面内容我们介绍了TF的基本的概念和TF树消息的格式类型，我们知道，TF不仅仅是一个标准、话题，它还是一个接口。本节课我们就介绍c++中TF的一些函数和写法。</p><h2 id="32-数据类型"><a class="markdownIt-Anchor" href="#32-数据类型"></a> 3.2. 数据类型</h2><p>C++中给我们提供了很多TF的数据类型，如下表：</p><table><thead><tr><th style="text-align:center">名称</th><th style="text-align:center">数据类型</th></tr></thead><tbody><tr><td style="text-align:center">向量</td><td style="text-align:center">tf::Vector3</td></tr><tr><td style="text-align:center">点</td><td style="text-align:center">tf::Point</td></tr><tr><td style="text-align:center">四元数</td><td style="text-align:center">tf::Quaternion</td></tr><tr><td style="text-align:center">3*3矩阵（旋转矩阵）</td><td style="text-align:center">tf::Matrix3x3</td></tr><tr><td style="text-align:center">位姿</td><td style="text-align:center">tf::pose</td></tr><tr><td style="text-align:center">变换</td><td style="text-align:center">tf::Transform</td></tr><tr><td style="text-align:center">带时间戳的以上类型</td><td style="text-align:center">tf::Stamped</td></tr><tr><td style="text-align:center">带时间戳的变换</td><td style="text-align:center">tf::StampedTransform</td></tr></tbody></table><p>**易混注意：**虽然此表的最后带时间戳的变换数据类型为tf::StampedTransform,和上节我们所讲的geometry_msgs/TransformStamped.msg看起来很相似，但是其实数据类型完全不一样，tf::StampedTransform只能用在C<ins>里，只是C</ins>的一个类，一种数据格式，并不是一个消息。而geometry_msgs/TransformStamped.msg是一个message,它依赖于ROS，与语言无关，也即是无论何种语言，C++、Python、Java等等，都可以发送该消息。</p><h2 id="33-数据转换"><a class="markdownIt-Anchor" href="#33-数据转换"></a> 3.3. 数据转换</h2><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/tf_translate.png" alt="img" /></p><p>在TF里有可能会遇到各种各样数据的转换，例如常见的四元数、旋转矩阵、欧拉角这三种数据之间的转换。tf in roscpp给了我们解决该问题的函数。详细源码在我们教学课程的代码包中。 首先在tf中与数据转化的数据都类型都包含在<code>#include</code>头文件中，我们将与数据转换相关API都存在tf_demo中的coordinate_transformation.cpp当中，其中列表如下：</p><h2 id="34-第1部分定义空间点和空间向量"><a class="markdownIt-Anchor" href="#34-第1部分定义空间点和空间向量"></a> 3.4. 第1部分定义空间点和空间向量</h2><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">1.1</td><td style="text-align:center">tfScalar::tfDot(const Vector3 &amp;v1, const Vector3 &amp;v2)</td><td style="text-align:center">计算两个向量的点积</td></tr><tr><td style="text-align:center">1.2</td><td style="text-align:center">tfScalar length()</td><td style="text-align:center">计算向量的模</td></tr><tr><td style="text-align:center">1.3</td><td style="text-align:center">Vector3 &amp;normalize()</td><td style="text-align:center">求与已知向量同方向的单位向量</td></tr><tr><td style="text-align:center">1.4</td><td style="text-align:center">tfScalar::tfAngle(const Vector3 &amp;v1, const Vector3 &amp;v2)</td><td style="text-align:center">计算两个向量的夹角</td></tr><tr><td style="text-align:center">1.5</td><td style="text-align:center">tfScale::tfDistance(const Vector3 &amp;v1, const Vector3 &amp;v2)</td><td style="text-align:center">计算两个向量的距离</td></tr><tr><td style="text-align:center">1.6</td><td style="text-align:center">tfScale::tfCross(const Vector3 &amp;v1,const Vector3 &amp;v2)</td><td style="text-align:center">计算两个向量的乘积</td></tr></tbody></table><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;tf/tf.h&gt;</span><br><span class="line">//退出用：ctrl+z</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">//初始化</span><br><span class="line">ros::init(argc, argv, &quot;coordinate_transformation&quot;);</span><br><span class="line">ros::NodeHandle node;</span><br><span class="line">tf::Vector3 v1(1,1,1);</span><br><span class="line">tf::Vector3 v2(1,0,1);</span><br><span class="line">//第1部分，定义空间点和空间向量</span><br><span class="line">std::cout&lt;&lt;&quot;第1部分，定义空间点和空间向量&quot;&lt;&lt;std::endl;</span><br><span class="line">//1.1 计算两个向量的点积</span><br><span class="line">std::cout&lt;&lt;&quot;向量v1:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;v1[0]&lt;&lt;&quot;,&quot;&lt;&lt;v1[1]&lt;&lt;&quot;,&quot;&lt;&lt;v1[2]&lt;&lt;&quot;),&quot;;</span><br><span class="line">std::cout&lt;&lt;&quot;向量v2:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;v2[0]&lt;&lt;&quot;,&quot;&lt;&lt;v2[1]&lt;&lt;&quot;,&quot;&lt;&lt;v2[2]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;&quot;两个向量的点积：&quot;&lt;&lt;tfDot(v1,v2)&lt;&lt;std::endl;</span><br><span class="line">//1.2 计算向量的模</span><br><span class="line">std::cout&lt;&lt;&quot;向量v2的模值:&quot;&lt;&lt;v2.length()&lt;&lt;std::endl;</span><br><span class="line">//1.3 求与已知向量同方向的单位向量</span><br><span class="line">tf::Vector3 v3;</span><br><span class="line">v3=v2.normalize();</span><br><span class="line">std::cout&lt;&lt;&quot;与向量v2的同方向的单位向量v3:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;v3[0]&lt;&lt;&quot;,&quot;&lt;&lt;v3[1]&lt;&lt;&quot;,&quot;&lt;&lt;v3[2]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span><br><span class="line">//1.4 计算两个向量的夹角</span><br><span class="line">std::cout&lt;&lt;&quot;两个向量的夹角(弧度):&quot;&lt;&lt;tfAngle(v1,v2)&lt;&lt;std::endl;</span><br><span class="line">//1.5 计算两个向量的距离</span><br><span class="line">std::cout&lt;&lt;&quot;两个向量的距离:&quot;&lt;&lt;tfDistance2(v1,v2)&lt;&lt;std::endl;</span><br><span class="line">//1.6 计算两个向量的乘积</span><br><span class="line">tf::Vector3 v4;</span><br><span class="line">v4=tfCross(v1,v2);</span><br><span class="line">std::cout&lt;&lt;&quot;两个向量的乘积v4:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;v4[0]&lt;&lt;&quot;,&quot;&lt;&lt;v4[1]&lt;&lt;&quot;,&quot;&lt;&lt;v4[2]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="35-第2部分定义四元数"><a class="markdownIt-Anchor" href="#35-第2部分定义四元数"></a> 3.5. 第2部分定义四元数</h2><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">2.1</td><td style="text-align:center">setRPY(const tfScalar&amp; yaw, const stScalar &amp;pitch, const tfScalar &amp;roll)</td><td style="text-align:center">由欧拉角计算四元数</td></tr><tr><td style="text-align:center">2.2</td><td style="text-align:center">Vector3 getAxis()</td><td style="text-align:center">由四元数得到旋转轴</td></tr><tr><td style="text-align:center">2.3</td><td style="text-align:center">setRotation(const Vector3 &amp;axis, const tfScalar&amp; angle)</td><td style="text-align:center">已知旋转轴和旋转角估计四元数</td></tr></tbody></table><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;tf/tf.h&gt;</span><br><span class="line">//退出用：ctrl+z</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">//初始化</span><br><span class="line">ros::init(argc, argv, &quot;coordinate_transformation&quot;);</span><br><span class="line">ros::NodeHandle node;</span><br><span class="line">std::cout&lt;&lt;&quot;第2部分，定义四元数&quot;&lt;&lt;std::endl;</span><br><span class="line">//2.1 由欧拉角计算四元数</span><br><span class="line">tfScalar yaw,pitch,roll;</span><br><span class="line">yaw=0;pitch=0;roll=0;</span><br><span class="line">std::cout&lt;&lt;&quot;欧拉角rpy(&quot;&lt;&lt;roll&lt;&lt;&quot;,&quot;&lt;&lt;pitch&lt;&lt;&quot;,&quot;&lt;&lt;yaw&lt;&lt;&quot;)&quot;;</span><br><span class="line">tf::Quaternion q;</span><br><span class="line">q.setRPY(yaw,pitch,roll);</span><br><span class="line">std::cout&lt;&lt;&quot;，转化到四元数q:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;q[3]&lt;&lt;&quot;,&quot;&lt;&lt;q[0]&lt;&lt;&quot;,&quot;&lt;&lt;q[1]&lt;&lt;&quot;,&quot;&lt;&lt;q[2]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span><br><span class="line">//2.2 由四元数得到旋转轴</span><br><span class="line">tf::Vector3 v5;</span><br><span class="line">v5=q.getAxis();</span><br><span class="line">std::cout&lt;&lt;&quot;四元数q的旋转轴v5&quot;&lt;&lt;&quot;(&quot;&lt;&lt;v5[0]&lt;&lt;&quot;,&quot;&lt;&lt;v5[1]&lt;&lt;&quot;,&quot;&lt;&lt;v5[2]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span><br><span class="line">//2.3 由旋转轴和旋转角来估计四元数</span><br><span class="line">tf::Quaternion q2;</span><br><span class="line">q2.setRotation(v5,1.570796);</span><br><span class="line">std::cout&lt;&lt;&quot;旋转轴v5和旋转角度90度，转化到四元数q2:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;q2[3]&lt;&lt;&quot;,&quot;&lt;&lt;q2[0]&lt;&lt;&quot;,&quot;&lt;&lt;q2[1]&lt;&lt;&quot;,&quot;&lt;&lt;q2[2]&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="36-第3部分定义旋转矩阵"><a class="markdownIt-Anchor" href="#36-第3部分定义旋转矩阵"></a> 3.6. 第3部分定义旋转矩阵</h2><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">3.1</td><td style="text-align:center">setRotaion(const Quaternion &amp;q)</td><td style="text-align:center">通过四元数得到旋转矩阵</td></tr><tr><td style="text-align:center">3.2</td><td style="text-align:center">getEulerYPR(tfScalar &amp;yaw, tfScalar &amp;pitch, tfScalar &amp;roll )</td><td style="text-align:center">由旋转矩阵求欧拉角</td></tr></tbody></table><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;tf/tf.h&gt;</span><br><span class="line">//退出用：ctrl+z</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">//初始化</span><br><span class="line">ros::init(argc, argv, &quot;coordinate_transformation&quot;);</span><br><span class="line">ros::NodeHandle node;</span><br><span class="line">//第3部分，定义旋转矩阵</span><br><span class="line">std::cout&lt;&lt;&quot;第3部分，定义旋转矩阵&quot;&lt;&lt;std::endl;</span><br><span class="line">//3.1 由旋转轴和旋转角来估计四元数</span><br><span class="line">tf::Quaternion q2(1,0，0,0）;</span><br><span class="line">tf::Matrix3x3 Matrix;</span><br><span class="line">tf::Vector3 v6,v7,v8;</span><br><span class="line">Matrix.setRotation(q2);</span><br><span class="line">v6=Matrix[0];</span><br><span class="line">v7=Matrix[1];</span><br><span class="line">v8=Matrix[2];</span><br><span class="line">std::cout&lt;&lt;&quot;四元数q2对应的旋转矩阵M:&quot;&lt;&lt;v6[0]&lt;&lt;&quot;,&quot;&lt;&lt;v6[1]&lt;&lt;&quot;,&quot;&lt;&lt;v6[2]&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;&quot;                       &quot;&lt;&lt;v7[0]&lt;&lt;&quot;,&quot;&lt;&lt;v7[1]&lt;&lt;&quot;,&quot;&lt;&lt;v7[2]&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;&quot;                       &quot;&lt;&lt;v8[0]&lt;&lt;&quot;,&quot;&lt;&lt;v8[1]&lt;&lt;&quot;,&quot;&lt;&lt;v8[2]&lt;&lt;std::endl;</span><br><span class="line">//3.2 通过旋转矩阵求欧拉角</span><br><span class="line">tfScalar m_yaw,m_pitch,m_roll;</span><br><span class="line">Matrix.getEulerYPR(m_yaw,m_pitch,m_roll);</span><br><span class="line">std::cout&lt;&lt;&quot;由旋转矩阵M,得到欧拉角rpy(&quot;&lt;&lt;m_roll&lt;&lt;&quot;,&quot;&lt;&lt;m_pitch&lt;&lt;&quot;,&quot;&lt;&lt;m_yaw&lt;&lt;&quot;)&quot;&lt;&lt;std::endl;</span><br><span class="line">return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>此外，在tf_demo的教学包中，我们还提供常见的欧拉角与四元数的互换，详见Euler2Quaternion.cpp与Quaternion2Euler.cpp Euler2Quaternion.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;tf/tf.h&gt;</span><br><span class="line">//退出用：ctrl+z</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">//初始化</span><br><span class="line">  ros::init(argc, argv, &quot;Euler2Quaternion&quot;);</span><br><span class="line">  ros::NodeHandle node;</span><br><span class="line">  geometry_msgs::Quaternion q;</span><br><span class="line">  double roll,pitch,yaw;</span><br><span class="line">  while(ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">  //输入一个相对原点的位置</span><br><span class="line">  std::cout&lt;&lt;&quot;输入的欧拉角：roll,pitch,yaw:&quot;;</span><br><span class="line">  std::cin&gt;&gt;roll&gt;&gt;pitch&gt;&gt;yaw;</span><br><span class="line">  //输入欧拉角，转化成四元数在终端输出</span><br><span class="line"> q=tf::createQuaternionMsgFromRollPitchYaw(roll,pitch,yaw);</span><br><span class="line">  //ROS_INFO(&quot;输出的四元数为：w=%d,x=%d,y=%d,z=%d&quot;，q.w,q.x,q.y,q.z);</span><br><span class="line">  std::cout&lt;&lt;&quot;输出的四元数为：w=&quot;&lt;&lt;q.w&lt;&lt;&quot;,x=&quot;&lt;&lt;q.x&lt;&lt;&quot;,y=&quot;&lt;&lt;q.y&lt;&lt;&quot;,z=&quot;&lt;&lt;q.z&lt;&lt;std::endl;</span><br><span class="line">  ros::spinOnce();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>Quaternion2Euler.cpp</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &quot;nav_msgs/Odometry.h&quot;</span><br><span class="line">#include &lt;tf/tf.h&gt;</span><br><span class="line">//退出用：ctrl+z</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">//初始化</span><br><span class="line">  ros::init(argc, argv, &quot;Quaternion2Euler&quot;);</span><br><span class="line">  ros::NodeHandle node;</span><br><span class="line">  nav_msgs::Odometry position;</span><br><span class="line">  tf::Quaternion RQ2;  </span><br><span class="line">  double roll,pitch,yaw;</span><br><span class="line">  while(ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">  //输入一个相对原点的位置</span><br><span class="line">  std::cout&lt;&lt;&quot;输入的四元数：w,x,y,z:&quot;;</span><br><span class="line">  std::cin&gt;&gt;position.pose.pose.orientation.w&gt;&gt;position.pose.pose.orientation.x&gt;&gt;position.pose.pose.orientation.y&gt;&gt;position.pose.pose.orientation.z;</span><br><span class="line">  //输入四元数，转化成欧拉角数在终端输出</span><br><span class="line">  tf::quaternionMsgToTF(position.pose.pose.orientation,RQ2);  </span><br><span class="line"> // tf::Vector3 m_vector3; 方法2</span><br><span class="line"> // m_vector3=RQ2.getAxis();</span><br><span class="line">  tf::Matrix3x3(RQ2).getRPY(roll,pitch,yaw);  </span><br><span class="line">  std::cout&lt;&lt;&quot;输出的欧拉角为：roll=&quot;&lt;&lt;roll&lt;&lt;&quot;,pitch=&quot;&lt;&lt;pitch&lt;&lt;&quot;,yaw=&quot;&lt;&lt;yaw&lt;&lt;std::endl;</span><br><span class="line">  //std::cout&lt;&lt;&quot;输出欧拉角为：roll=&quot;&lt;&lt;m_vector3[0]&lt;&lt;&quot;,pitch=&quot;&lt;&lt;m_vector3[1]&lt;&lt;&quot;,yaw=&quot;&lt;&lt;m_vector3[2]&lt;&lt;std::endl;</span><br><span class="line">  ros::spinOnce();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;    </span><br></pre></td></tr></table></figure><h2 id="37-tf类"><a class="markdownIt-Anchor" href="#37-tf类"></a> 3.7. TF类</h2><h2 id="38-tftransformbroadcaster类"><a class="markdownIt-Anchor" href="#38-tftransformbroadcaster类"></a> 3.8. tf::TransformBroadcaster类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">transformBroadcaster()</span><br><span class="line">void sendTransform(const StampedTransform &amp;transform)</span><br><span class="line">void sendTransform(const std::vector&lt;StampedTransform&gt; &amp;transforms)</span><br><span class="line">void sendTransform(const geometry_msgs::TransformStamped &amp;transform)</span><br><span class="line">void sendTransform(const std::vector&lt;geometry_msgs::TransformStamped&gt; &amp;transforms)</span><br></pre></td></tr></table></figure><p>这个类在前面讲TF树的时候提到过，这个broadcaster就是一个publisher,而sendTransform的作用是来封装publish的函数。在实际的使用中，我们需要在某个Node中构建tf::TransformBroadcaster类，然后调用sendTransform(),将transform发布到<code>/tf</code>的一段transform上。<code>/tf</code>里的transform为我们重载了多种不同的函数类型。在我们的tf_demo教学包当中提供了相关的示例代码tf.broadcaster.cpp，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;tf/transform_broadcaster.h&gt;</span><br><span class="line">#include &lt;tf/tf.h&gt;</span><br><span class="line">//退出用：ctrl+z</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">//初始化</span><br><span class="line">  ros::init(argc, argv, &quot;tf_broadcaster&quot;);</span><br><span class="line">  ros::NodeHandle node;</span><br><span class="line">  static tf::TransformBroadcaster br;</span><br><span class="line">  tf::Transform transform;</span><br><span class="line">  //geometry_msgs::Quaternion qw;</span><br><span class="line">  tf::Quaternion q;</span><br><span class="line">  //定义初始坐标和角度</span><br><span class="line">  double roll=0,pitch=0,yaw=0,x=1.0,y=2.0,z=3.0;</span><br><span class="line">  ros::Rate rate(1);</span><br><span class="line">  while(ros::ok())</span><br><span class="line">  &#123;</span><br><span class="line">  yaw+=0.1;//每经过一秒开始一次变换</span><br><span class="line">  //输入欧拉角，转化成四元数在终端输出</span><br><span class="line">  q.setRPY(roll,pitch,yaw);</span><br><span class="line">      //qw=tf::createQuaternionMsgFromRollPitchYaw(roll,pitch,yaw);方法2</span><br><span class="line">  transform.setOrigin(tf::Vector3(x,y,z));</span><br><span class="line">  transform.setRotation(q);</span><br><span class="line">  std::cout&lt;&lt;&quot;发布tf变换：sendTransform函数&quot;&lt;&lt;std::endl;</span><br><span class="line">  br.sendTransform(tf::StampedTransform(transform,ros::Time::now(),&quot;base_link&quot;,&quot;link1&quot;));</span><br><span class="line">  std::cout&lt;&lt;&quot;输出的四元数为：w=&quot;&lt;&lt;q[3]&lt;&lt;&quot;,x=&quot;&lt;&lt;q[0]&lt;&lt;&quot;,y=&quot;&lt;&lt;q[1]&lt;&lt;&quot;,z=&quot;&lt;&lt;q[2]&lt;&lt;std::endl;</span><br><span class="line">  //  std::cout&lt;&lt;&quot;输出的四元数为：w=&quot;&lt;&lt;qw.w&lt;&lt;&quot;,x=&quot;&lt;&lt;qw.x&lt;&lt;&quot;,y=&quot;&lt;&lt;qw.y&lt;&lt;&quot;,z=&quot;&lt;&lt;qw.z&lt;&lt;std::endl;</span><br><span class="line">  rate.sleep();</span><br><span class="line">  ros::spinOnce();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="39-tftransformlistener类"><a class="markdownIt-Anchor" href="#39-tftransformlistener类"></a> 3.9. tf::TransformListener类</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">void lookupTranform(const std::string &amp;target_frame,const std::string &amp;source_frame,const ros::Time &amp;time,StampedTransform &amp;transform)const</span><br><span class="line">bool canTransform()</span><br><span class="line">bool waitForTransform()const</span><br></pre></td></tr></table></figure><p>上一个类是向<code>/tf</code>上发的类，那么这一个就是从<code>/tf</code>上接收的类。首先看lookuptransform()函数，第一个参数是目标坐标系，第二个参数为源坐标系，也即是得到从源坐标系到目标坐标系之间的转换关系，第三个参数为查询时刻，第四个参数为存储转换关系的位置。值得注意，第三个参数通常用<code>ros::Time（0）</code>,这个表示为最新的坐标转换关系，而<code>ros::time::now</code>则会因为收发延迟的原因，而不能正确获取当前最新的坐标转换关系。canTransform()是用来判断两个transform之间是否连通，waitForTransform()const是用来等待某两个transform之间的连通，在我们的tf_demo教学包当中提供了相关的示例代码tf_listerner.cpp，具体如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;ros/ros.h&gt;</span><br><span class="line">#include &lt;tf/transform_listener.h&gt;</span><br><span class="line">#include &lt;geometry_msgs/Twist.h&gt;</span><br><span class="line">int main(int argc, char** argv)&#123;</span><br><span class="line">  ros::init(argc, argv, &quot;tf_listener&quot;);</span><br><span class="line">  ros::NodeHandle node;</span><br><span class="line">  tf::TransformListener listener;</span><br><span class="line">  //1. 阻塞直到frame相通</span><br><span class="line">  std::cout&lt;&lt;&quot;1. 阻塞直到frame相通&quot;&lt;&lt;std::endl;</span><br><span class="line">  listener.waitForTransform(&quot;/base_link&quot;,&quot;link1&quot;,ros::Time(0),ros::Duration(4.0));</span><br><span class="line">  ros::Rate rate(1);</span><br><span class="line">  while (node.ok())&#123;</span><br><span class="line">tf::StampedTransform transform;</span><br><span class="line">try&#123;</span><br><span class="line">  //2. 监听对应的tf,返回平移和旋转</span><br><span class="line"> std::cout&lt;&lt;&quot;2. 监听对应的tf,返回平移和旋转&quot;&lt;&lt;std::endl;</span><br><span class="line">  listener.lookupTransform(&quot;/base_link&quot;, &quot;/link1&quot;,</span><br><span class="line">                           ros::Time(0), transform);</span><br><span class="line">                           //ros::Time(0)表示最近的一帧坐标变换，不能写成ros::Time::now()</span><br><span class="line">&#125;</span><br><span class="line">catch (tf::TransformException &amp;ex) &#123;</span><br><span class="line">  ROS_ERROR(&quot;%s&quot;,ex.what());</span><br><span class="line">  ros::Duration(1.0).sleep();</span><br><span class="line">  continue;</span><br><span class="line">&#125;</span><br><span class="line">std::cout&lt;&lt;&quot;输出的位置坐标：x=&quot;&lt;&lt;transform.getOrigin().x()&lt;&lt;&quot;,y=&quot;&lt;&lt;transform.getOrigin().y()&lt;&lt;&quot;,z=&quot;&lt;&lt;transform.getOrigin().z()&lt;&lt;std::endl;</span><br><span class="line">std::cout&lt;&lt;&quot;输出的旋转四元数：w=&quot;&lt;&lt;transform.getRotation().getW()&lt;&lt;&quot;,x=&quot;&lt;&lt;transform.getRotation().getX()&lt;&lt;</span><br><span class="line">&quot;,y=&quot;&lt;&lt;transform.getRotation().getY()&lt;&lt;&quot;,z=&quot;&lt;&lt;transform.getRotation().getZ()&lt;&lt;std::endl;</span><br><span class="line">rate.sleep();</span><br><span class="line">  &#125;</span><br><span class="line">  return 0;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h1 id="4-tf-in-python"><a class="markdownIt-Anchor" href="#4-tf-in-python"></a> 4. tf in python</h1><h2 id="41-简介"><a class="markdownIt-Anchor" href="#41-简介"></a> 4.1. 简介</h2><p>我们知道tf中不仅有C<ins>的接口，也有Python的接口。相比C</ins>，tf在Python中的具体实现相对简单好用。</p><h2 id="42-数据类型"><a class="markdownIt-Anchor" href="#42-数据类型"></a> 4.2. 数据类型</h2><p>TF的相关数据类型，<strong>向量</strong>、<strong>点</strong>、<strong>四元数</strong>、<strong>矩阵</strong>都可以表示成类似数组形式，就是它们都可以用<strong>Tuple</strong>，<strong>List</strong>，<strong>Numpy</strong>,  <strong>Array</strong>来表示。<br />例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (1.0,1.5,0) #平移</span><br><span class="line">q = [1,0,0,0] #四元数</span><br><span class="line">m = numpy.identity(3) #旋转矩阵</span><br></pre></td></tr></table></figure><p>第一个平移数据使用Tuple表示的，同时也可以用List表示成t=[1.0,1.5,0],也能用numpy.array(1.0,1.5,0)来表示都是可以的。<strong>这些数据类型没有特殊对应，全部是通用的，所以这里也就没有了各种数据类型的转换的麻烦。</strong></p><h2 id="43-库"><a class="markdownIt-Anchor" href="#43-库"></a> 4.3. 库</h2><h2 id="44-tftransformations"><a class="markdownIt-Anchor" href="#44-tftransformations"></a> 4.4. tf.transformations</h2><p>基本数学运算函数</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">注释</th></tr></thead><tbody><tr><td style="text-align:center">euler_matrix(ai,aj,ak,axes=‘sxyz’)</td><td style="text-align:center">欧拉角到矩阵</td></tr><tr><td style="text-align:center">eulaer_form_matrix(matrix,axes=‘sxyz’)</td><td style="text-align:center">矩阵到欧拉角</td></tr><tr><td style="text-align:center">eular_from_quaternion(quaternion,axes=‘sxyz’)</td><td style="text-align:center">四元数到欧拉角</td></tr><tr><td style="text-align:center">quaternion_form_euler(ai,aj,ak,axes=‘sxyz’)</td><td style="text-align:center">欧拉角到四元数</td></tr><tr><td style="text-align:center">quaternion_matrix(quaternion)</td><td style="text-align:center">四元数到矩阵</td></tr><tr><td style="text-align:center">quaternion_form_matrix(matrix)</td><td style="text-align:center">矩阵到四元数</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>使用该函数库时候，首先<code>import tf</code>，tf.transformations给我们提供了<strong>一些基本的数学运算函数</strong>如上，使用起来非常方便。在tf_demo中教学包当中，我们列举了一些tf.transformations常见的API和示例代码，具详见下表。</p><h3 id="441-第1部分定义空间点和空间向量"><a class="markdownIt-Anchor" href="#441-第1部分定义空间点和空间向量"></a> 4.4.1. 第1部分，定义空间点和空间向量</h3><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">1.1</td><td style="text-align:center">tf.transformations.random_quaternion(rand=None)</td><td style="text-align:center">返回均匀随机单位四元数</td></tr><tr><td style="text-align:center">1.2</td><td style="text-align:center">tf.transformations.random_rotation_matrix(rand=None)</td><td style="text-align:center">返回均匀随机单位旋转矩阵</td></tr><tr><td style="text-align:center">1.3</td><td style="text-align:center">tf.transformations.random_vector(size)</td><td style="text-align:center">返回均匀随机单位向量</td></tr><tr><td style="text-align:center">1.4</td><td style="text-align:center">tf.transformations.translation_matrix(v)</td><td style="text-align:center">通过向量来求旋转矩阵</td></tr><tr><td style="text-align:center">1.5</td><td style="text-align:center">tf.transformations.translation_from_matrix(m)</td><td style="text-align:center">通过旋转矩阵来求向量</td></tr></tbody></table><h3 id="442-第2部分定义四元数"><a class="markdownIt-Anchor" href="#442-第2部分定义四元数"></a> 4.4.2. 第2部分，定义四元数</h3><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">2.1</td><td style="text-align:center">tf.transformations.quaternion_about_axis(angle axis)</td><td style="text-align:center">通过旋转轴和旋转角返回四元数</td></tr><tr><td style="text-align:center">2.2</td><td style="text-align:center">tf.transformations.quaternion_conjugate(quaternion)</td><td style="text-align:center">返回四元数的共轭</td></tr><tr><td style="text-align:center">2.3</td><td style="text-align:center">tf.transformations.quaternion_from_euler(ai,aj,ak, axes’ryxz’)</td><td style="text-align:center">从欧拉角和旋转轴，求四元数</td></tr><tr><td style="text-align:center">2.4</td><td style="text-align:center">tf.transformations.quaternion_from_matrix(matrix)</td><td style="text-align:center">从旋转矩阵中，返回四元数</td></tr><tr><td style="text-align:center">2.5</td><td style="text-align:center">tf.transformations.quaternion_multiply(quaternion1,quaternion2)</td><td style="text-align:center">两个四元数相乘</td></tr></tbody></table><h3 id="443-第3部分定义四元数"><a class="markdownIt-Anchor" href="#443-第3部分定义四元数"></a> 4.4.3. 第3部分，定义四元数</h3><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">3.1</td><td style="text-align:center">tf.transformations.euler_matrix(ai,aj,ak,axes=‘xyz’)</td><td style="text-align:center">由欧拉角和旋转轴返回旋转矩阵</td></tr><tr><td style="text-align:center">3.2</td><td style="text-align:center">tf.transformations.euler_from_matrix(matrix)</td><td style="text-align:center">由旋转矩阵和特定的旋转轴返回欧拉角</td></tr><tr><td style="text-align:center">3.3</td><td style="text-align:center">tf.transformations.euler_from_quaternion(quaternion)</td><td style="text-align:center">由四元数和特定的轴得到欧拉角</td></tr></tbody></table><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line">import rospy  </span><br><span class="line">import math  </span><br><span class="line">import tf  </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_coordinate_transformation&#x27;)</span><br><span class="line">#第1部分，定义空间点和空间向量</span><br><span class="line">    print &#x27;第1部分，定义空间点和空间向量&#x27;</span><br><span class="line">#1.1 返回均匀随机单位四元数</span><br><span class="line">    q=tf.transformations.random_quaternion(rand=None)</span><br><span class="line">    print &#x27;定义均匀随机四元数：&#x27;</span><br><span class="line">    print q</span><br><span class="line">#1.2 返回均匀随机单位旋转矩阵</span><br><span class="line">    m=tf.transformations.random_rotation_matrix(rand=None)</span><br><span class="line">    print &#x27;定义均匀随机单位旋转矩阵：&#x27;</span><br><span class="line">    print m</span><br><span class="line">#1.3 返回均匀随机单位向量</span><br><span class="line">    v=tf.transformations.random_vector(3)</span><br><span class="line">    print &#x27;定义均匀随机单位向量：&#x27;</span><br><span class="line">    print v</span><br><span class="line">#1.4 通过向量来求旋转矩阵</span><br><span class="line">    v_m=tf.transformations.translation_matrix(v)</span><br><span class="line">    print &#x27;通过向量来求旋转矩阵：&#x27;</span><br><span class="line">    print v_m</span><br><span class="line">#1.5 通过旋转矩阵来求向量</span><br><span class="line">    m_v=tf.transformations.translation_from_matrix(m)</span><br><span class="line">    print &#x27;通过旋转矩阵来求向量：&#x27;</span><br><span class="line">    print  m_v</span><br><span class="line">#第2部分，定义四元数</span><br><span class="line">    print &#x27;第2部分，定义四元数&#x27;</span><br><span class="line">#2.1 通过旋转轴和旋转角返回四元数</span><br><span class="line">    axis_q=tf.transformations.quaternion_about_axis(0.123, (1, 0, 0))</span><br><span class="line">    print &#x27;通过旋转轴和旋转角返回四元数：&#x27;</span><br><span class="line">    print  axis_q</span><br><span class="line">#2.2 返回四元数的共轭</span><br><span class="line">    n_q=tf.transformations.quaternion_conjugate(q)</span><br><span class="line">    print &#x27;返回四元数q的共轭：&#x27;</span><br><span class="line">    print  n_q</span><br><span class="line">#2.3 从欧拉角和旋转轴，求四元数</span><br><span class="line">    o_q=tf.transformations.quaternion_from_euler(1, 2, 3, &#x27;ryxz&#x27;)</span><br><span class="line">    print &#x27;从欧拉角和旋转轴，求四元数：&#x27;</span><br><span class="line">    print  o_q    </span><br><span class="line">#2.4 从旋转矩阵中，返回四元数</span><br><span class="line">    m_q=tf.transformations.quaternion_from_matrix(m)</span><br><span class="line">    print &#x27;从旋转矩阵中，返回四元数：&#x27;</span><br><span class="line">    print  m_q </span><br><span class="line">#2.5 两个四元数相乘</span><br><span class="line">    qxq=tf.transformations.quaternion_multiply(q,n_q)</span><br><span class="line">    print &#x27;两个四元数相乘&#x27;</span><br><span class="line">    print  qxq   </span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="45-tf类"><a class="markdownIt-Anchor" href="#45-tf类"></a> 4.5. TF类</h2><h3 id="451-tftransformlistener类"><a class="markdownIt-Anchor" href="#451-tftransformlistener类"></a> 4.5.1. tf.TransformListener类</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">canTransform(self,target_frame,source_frame,time)</td><td style="text-align:center">frame是否相通</td></tr><tr><td style="text-align:center">waitForTransform(self,target_frame,source_frame,time,timeout)</td><td style="text-align:center">阻塞直到frame相通</td></tr><tr><td style="text-align:center">lookup Transform(self,target_frame,source_frame,time)</td><td style="text-align:center">查看相对的tf，返回（trans，quat）</td></tr></tbody></table><p>tf.TransformListener类中主要包含以上三种方法，它的构造函数不需要填值。注意这里的time参数，依然是使用<code>rospy.Time(0)</code>而不是<code>rospy.Time.now()</code>.具体原因上节已经介绍，这里不再赘述。除了上述三种重要的方法，这个类中还有一些辅助用的方法如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">chain(target_frame,target_time,source_frame,source_time,fixed_frame)</td><td style="text-align:center">frame的连接关系</td></tr><tr><td style="text-align:center">frameExists(self,frame_id)</td><td style="text-align:center">frame是否存在</td></tr><tr><td style="text-align:center">getFrameStrings(self)</td><td style="text-align:center">返回所有tf的名称</td></tr><tr><td style="text-align:center">fromTranslationRotation(translation,rotation)</td><td style="text-align:center">根据平移和旋转返回4X4矩阵</td></tr><tr><td style="text-align:center">transformPoint(target_frame,point_msg)</td><td style="text-align:center">将PointStamped消息转换到新frame下</td></tr><tr><td style="text-align:center">transformPose(target_frame,pose_msg)</td><td style="text-align:center">将PoseStamped消息转换到新frame下</td></tr><tr><td style="text-align:center">transformQuaternion(target_frame,quat_msg)</td><td style="text-align:center">将QuaternionStamped…返回相同类型</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>在<code>tf_demo</code>教学包当中的<code>scripts/py_tf_listerner.py</code>给出了示例程序，详见如下。</p><p>py_tf_listerner.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line">import rospy  </span><br><span class="line">import math  </span><br><span class="line">import tf   </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_tf_turtle&#x27;)</span><br><span class="line">    listener = tf.TransformListener() #TransformListener创建后就开始接受tf广播信息，最多可以缓存10s  目前存在的问题，是四个数值的顺序我还有点问题</span><br><span class="line">    rate = rospy.Rate(1.0)  </span><br><span class="line">    #1. 阻塞直到frame相通</span><br><span class="line">    print &#x27;1. 阻塞直到frame相通&#x27;  </span><br><span class="line">    listener.waitForTransform(&quot;/base_link&quot;, &quot;/link1&quot;, rospy.Time(), rospy.Duration(4.0))</span><br><span class="line">    while not rospy.is_shutdown():  </span><br><span class="line">        try:  </span><br><span class="line">        #2. 监听对应的tf,返回平移和旋转</span><br><span class="line">            print &#x27;2. 监听对应的tf,返回平移和旋转&#x27;  </span><br><span class="line">            (trans,rot) = listener.lookupTransform(&#x27;/base_link&#x27;, &#x27;/link1&#x27;, rospy.Time(0)) #rospy.Time(0)不表示0时刻的tf，而是指最近一帧tf </span><br><span class="line">        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):  </span><br><span class="line">            continue    </span><br><span class="line">        rospy.loginfo(&#x27;距离原点的位置: x=%f ,y= %f，z=%f \n 旋转四元数: w=%f ,x= %f，y=%f z=%f &#x27;,trans[0],trans[1],trans[2],rot[0],rot[1],rot[2],rot[3])</span><br><span class="line">        #3. 判断两个frame是否相通</span><br><span class="line">        print &#x27;3. 判断两个frame是否相通&#x27;</span><br><span class="line">        if listener.canTransform(&#x27;/link1&#x27;,&#x27;/base_link&#x27;,rospy.Time(0)) :</span><br><span class="line">            print &#x27;true&#x27;</span><br><span class="line">        else :</span><br><span class="line">            print &#x27;false&#x27;</span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><h3 id="452"><a class="markdownIt-Anchor" href="#452"></a> 4.5.2.</h3><h3 id="453-tftransformbroadcaster类"><a class="markdownIt-Anchor" href="#453-tftransformbroadcaster类"></a> 4.5.3. tf.TransformBroadcaster类</h3><p>类似的，我们介绍的是发布方，tf.TransformBroadcaster类。该类的构造函数也是不需要填值，成员函数有两个如下：</p><ul><li>sendTransform(translation,rotation,time,child,parent)#向/tf发布消息</li><li>sendTransformMessage(transform)#向/tf发布消息</li></ul><p>第一个sendTransform()把transform的平移和旋转填好，打上时间戳，然后表示出从父到子的frame流，然后发向<code>/tf</code>的topic。第二种是发送transform已经封装好的Message给<code>/tf</code>，这两种不同的发送方式，功能是一致的。在<code>tf_demo</code>教学包当中的<code>scripts/py_tf_broadcaster.py</code>和<code>scripts/py_tf_broadcaster02.py</code>给出了示例程序，详见如下。</p><p>py_tf_broadcaster.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line"></span><br><span class="line">import rospy  </span><br><span class="line">import math  </span><br><span class="line">import tf    </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_tf_broadcaster&#x27;)</span><br><span class="line">    print &#x27;讲解tf.transformBroadcaster类&#x27;</span><br><span class="line">    print &#x27;第1种发布方式：sendTransform(translation,rotation,time,child,parent)&#x27;</span><br><span class="line">#第一部分，发布sendTransform(translation,rotation,time,child,parent)</span><br><span class="line">    br = tf.TransformBroadcaster()</span><br><span class="line">#输入相对原点的值和欧拉角</span><br><span class="line">    x=1.0 </span><br><span class="line">    y=2.0</span><br><span class="line">    z=3.0  </span><br><span class="line">    roll=0 </span><br><span class="line">    pitch=0</span><br><span class="line">    yaw=1.57 </span><br><span class="line">    rate = rospy.Rate(1)</span><br><span class="line">    while not rospy.is_shutdown(): </span><br><span class="line">        yaw=yaw+0.1   </span><br><span class="line">        br.sendTransform((x,y,z),  </span><br><span class="line">                     tf.transformations.quaternion_from_euler(roll,pitch,yaw),  </span><br><span class="line">                     rospy.Time.now(),  </span><br><span class="line">                     &quot;base_link&quot;,  </span><br><span class="line">                     &quot;link1&quot;)  #发布base_link到link1的平移和翻转   </span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><p>py_tf_broadcaster02.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line"></span><br><span class="line">import rospy </span><br><span class="line">import geometry_msgs.msg</span><br><span class="line">import tf2_ros.transform_broadcaster</span><br><span class="line">import math  </span><br><span class="line">import tf   </span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_tf_broadcaster&#x27;)</span><br><span class="line">    print &#x27;讲解tf.transformBroadcaster类&#x27;</span><br><span class="line">    print &#x27;第2种发布方式：sendTransformMessage(transform)&#x27;</span><br><span class="line">#第二部分，发布sendTransformMessage(transform)</span><br><span class="line">    m=tf.TransformBroadcaster()</span><br><span class="line">    t = geometry_msgs.msg.TransformStamped()</span><br><span class="line">    t.header.frame_id = &#x27;base_link&#x27;</span><br><span class="line">    t.header.stamp = rospy.Time(0)</span><br><span class="line">    t.child_frame_id = &#x27;link1&#x27;</span><br><span class="line">    t.transform.translation.x = 1</span><br><span class="line">    t.transform.translation.y = 2</span><br><span class="line">    t.transform.translation.z = 3</span><br><span class="line">    t.transform.rotation.w=1</span><br><span class="line">    t.transform.rotation.x=0</span><br><span class="line">    t.transform.rotation.y=0</span><br><span class="line">    t.transform.rotation.z=0</span><br><span class="line">#输入相对原点的值和欧拉角</span><br><span class="line">    rate = rospy.Rate(1)</span><br><span class="line">    while not rospy.is_shutdown():</span><br><span class="line">        m.sendTransformMessage(t)</span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><h2 id="46-tf相关工具命令"><a class="markdownIt-Anchor" href="#46-tf相关工具命令"></a> 4.6. TF相关工具命令</h2><ol><li><p>根据当前的tf树创建一个pdf图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun tf view_frames</span><br></pre></td></tr></table></figure><p>这个工具首先订阅<code>/tf</code>，订阅5秒钟，根据这段时间接受到的tf信息，绘制成一张tf tree，然后创建成一个pdf图。</p></li><li><p>查看当前的tf树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun rqt_tf_tree rqt_tf_tree</span><br></pre></td></tr></table></figure><p>该命令同样是查询tf tree的，但是与第一个命令的区别是该命令是动态的查询当前的tf tree,当前的任何变化都能当即看到，例如何时断开何时连接，捕捉到这些然后通过rqt插件显示出来。</p></li><li><p>查看两个frame之间的变换关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun tf tf_echo[reference_frame][target_frame]</span><br></pre></td></tr></table></figure></li></ol><h1 id="5-tf-in-python"><a class="markdownIt-Anchor" href="#5-tf-in-python"></a> 5. tf in python</h1><h2 id="51-简介"><a class="markdownIt-Anchor" href="#51-简介"></a> 5.1. 简介</h2><p>我们知道tf中不仅有C<ins>的接口，也有Python的接口。相比C</ins>，tf在Python中的具体实现相对简单好用。</p><h2 id="52-数据类型"><a class="markdownIt-Anchor" href="#52-数据类型"></a> 5.2. 数据类型</h2><p>TF的相关数据类型，向量、点、四元数、矩阵都可以表示成类似数组形式，就是它们都可以用Tuple，List，Numpy Array来表示。<br />例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">t = (1.0,1.5,0) #平移</span><br><span class="line">q = [1,0,0,0] #四元数</span><br><span class="line">m = numpy.identity(3) #旋转矩阵</span><br></pre></td></tr></table></figure><p>第一个平移数据使用Tuple表示的，同时也可以用List表示成t=[1.0,1.5,0],也能用numpy.array(1.0,1.5,0)来表示都是可以的。这些数据类型没有特殊对应，全部是通用的，所以这里也就没有了各种数据类型的转换的麻烦。</p><h2 id="53-tf库"><a class="markdownIt-Anchor" href="#53-tf库"></a> 5.3. TF库</h2><h3 id="531-tftransformations"><a class="markdownIt-Anchor" href="#531-tftransformations"></a> 5.3.1. tf.transformations</h3><p>基本数学运算函数</p><table><thead><tr><th style="text-align:center">函数</th><th style="text-align:center">注释</th></tr></thead><tbody><tr><td style="text-align:center">euler_matrix(ai,aj,ak,axes=‘sxyz’)</td><td style="text-align:center">欧拉角到矩阵</td></tr><tr><td style="text-align:center">eulaer_form_matrix(matrix,axes=‘sxyz’)</td><td style="text-align:center">矩阵到欧拉角</td></tr><tr><td style="text-align:center">eular_from_quaternion(quaternion,axes=‘sxyz’)</td><td style="text-align:center">四元数到欧拉角</td></tr><tr><td style="text-align:center">quaternion_form_euler(ai,aj,ak,axes=‘sxyz’)</td><td style="text-align:center">欧拉角到四元数</td></tr><tr><td style="text-align:center">quaternion_matrix(quaternion)</td><td style="text-align:center">四元数到矩阵</td></tr><tr><td style="text-align:center">quaternion_form_matrix(matrix)</td><td style="text-align:center">矩阵到四元数</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>使用该函数库时候，首先<code>import tf</code>，tf.transformations给我们提供了一些基本的数学运算函数如上，使用起来非常方便。在tf_demo中教学包当中，我们列举了一些tf.transformations常见的API和示例代码，具详见下表。</p><h3 id="532-第1部分定义空间点和空间向量"><a class="markdownIt-Anchor" href="#532-第1部分定义空间点和空间向量"></a> 5.3.2. 第1部分，定义空间点和空间向量</h3><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">1.1</td><td style="text-align:center">tf.transformations.random_quaternion(rand=None)</td><td style="text-align:center">返回均匀随机单位四元数</td></tr><tr><td style="text-align:center">1.2</td><td style="text-align:center">tf.transformations.random_rotation_matrix(rand=None)</td><td style="text-align:center">返回均匀随机单位旋转矩阵</td></tr><tr><td style="text-align:center">1.3</td><td style="text-align:center">tf.transformations.random_vector(size)</td><td style="text-align:center">返回均匀随机单位向量</td></tr><tr><td style="text-align:center">1.4</td><td style="text-align:center">tf.transformations.translation_matrix(v)</td><td style="text-align:center">通过向量来求旋转矩阵</td></tr><tr><td style="text-align:center">1.5</td><td style="text-align:center">tf.transformations.translation_from_matrix(m)</td><td style="text-align:center">通过旋转矩阵来求向量</td></tr></tbody></table><h3 id="533-第2部分定义四元数"><a class="markdownIt-Anchor" href="#533-第2部分定义四元数"></a> 5.3.3. 第2部分，定义四元数</h3><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">2.1</td><td style="text-align:center">tf.transformations.quaternion_about_axis(angle axis)</td><td style="text-align:center">通过旋转轴和旋转角返回四元数</td></tr><tr><td style="text-align:center">2.2</td><td style="text-align:center">tf.transformations.quaternion_conjugate(quaternion)</td><td style="text-align:center">返回四元数的共轭</td></tr><tr><td style="text-align:center">2.3</td><td style="text-align:center">tf.transformations.quaternion_from_euler(ai,aj,ak, axes’ryxz’)</td><td style="text-align:center">从欧拉角和旋转轴，求四元数</td></tr><tr><td style="text-align:center">2.4</td><td style="text-align:center">tf.transformations.quaternion_from_matrix(matrix)</td><td style="text-align:center">从旋转矩阵中，返回四元数</td></tr><tr><td style="text-align:center">2.5</td><td style="text-align:center">tf.transformations.quaternion_multiply(quaternion1,quaternion2)</td><td style="text-align:center">两个四元数相乘</td></tr></tbody></table><h3 id="534-第3部分定义四元数"><a class="markdownIt-Anchor" href="#534-第3部分定义四元数"></a> 5.3.4. 第3部分，定义四元数</h3><table><thead><tr><th style="text-align:center">编号</th><th style="text-align:center">函数名称</th><th style="text-align:center">函数功能</th></tr></thead><tbody><tr><td style="text-align:center">3.1</td><td style="text-align:center">tf.transformations.euler_matrix(ai,aj,ak,axes=‘xyz’)</td><td style="text-align:center">由欧拉角和旋转轴返回旋转矩阵</td></tr><tr><td style="text-align:center">3.2</td><td style="text-align:center">tf.transformations.euler_from_matrix(matrix)</td><td style="text-align:center">由旋转矩阵和特定的旋转轴返回欧拉角</td></tr><tr><td style="text-align:center">3.3</td><td style="text-align:center">tf.transformations.euler_from_quaternion(quaternion)</td><td style="text-align:center">由四元数和特定的轴得到欧拉角</td></tr></tbody></table><p>示例代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line">import rospy  </span><br><span class="line">import math  </span><br><span class="line">import tf  </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_coordinate_transformation&#x27;)</span><br><span class="line">#第1部分，定义空间点和空间向量</span><br><span class="line">    print &#x27;第1部分，定义空间点和空间向量&#x27;</span><br><span class="line">#1.1 返回均匀随机单位四元数</span><br><span class="line">    q=tf.transformations.random_quaternion(rand=None)</span><br><span class="line">    print &#x27;定义均匀随机四元数：&#x27;</span><br><span class="line">    print q</span><br><span class="line">#1.2 返回均匀随机单位旋转矩阵</span><br><span class="line">    m=tf.transformations.random_rotation_matrix(rand=None)</span><br><span class="line">    print &#x27;定义均匀随机单位旋转矩阵：&#x27;</span><br><span class="line">    print m</span><br><span class="line">#1.3 返回均匀随机单位向量</span><br><span class="line">    v=tf.transformations.random_vector(3)</span><br><span class="line">    print &#x27;定义均匀随机单位向量：&#x27;</span><br><span class="line">    print v</span><br><span class="line">#1.4 通过向量来求旋转矩阵</span><br><span class="line">    v_m=tf.transformations.translation_matrix(v)</span><br><span class="line">    print &#x27;通过向量来求旋转矩阵：&#x27;</span><br><span class="line">    print v_m</span><br><span class="line">#1.5 通过旋转矩阵来求向量</span><br><span class="line">    m_v=tf.transformations.translation_from_matrix(m)</span><br><span class="line">    print &#x27;通过旋转矩阵来求向量：&#x27;</span><br><span class="line">    print  m_v</span><br><span class="line">#第2部分，定义四元数</span><br><span class="line">    print &#x27;第2部分，定义四元数&#x27;</span><br><span class="line">#2.1 通过旋转轴和旋转角返回四元数</span><br><span class="line">    axis_q=tf.transformations.quaternion_about_axis(0.123, (1, 0, 0))</span><br><span class="line">    print &#x27;通过旋转轴和旋转角返回四元数：&#x27;</span><br><span class="line">    print  axis_q</span><br><span class="line">#2.2 返回四元数的共轭</span><br><span class="line">    n_q=tf.transformations.quaternion_conjugate(q)</span><br><span class="line">    print &#x27;返回四元数q的共轭：&#x27;</span><br><span class="line">    print  n_q</span><br><span class="line">#2.3 从欧拉角和旋转轴，求四元数</span><br><span class="line">    o_q=tf.transformations.quaternion_from_euler(1, 2, 3, &#x27;ryxz&#x27;)</span><br><span class="line">    print &#x27;从欧拉角和旋转轴，求四元数：&#x27;</span><br><span class="line">    print  o_q    </span><br><span class="line">#2.4 从旋转矩阵中，返回四元数</span><br><span class="line">    m_q=tf.transformations.quaternion_from_matrix(m)</span><br><span class="line">    print &#x27;从旋转矩阵中，返回四元数：&#x27;</span><br><span class="line">    print  m_q </span><br><span class="line">#2.5 两个四元数相乘</span><br><span class="line">    qxq=tf.transformations.quaternion_multiply(q,n_q)</span><br><span class="line">    print &#x27;两个四元数相乘&#x27;</span><br><span class="line">    print  qxq   </span><br><span class="line">`</span><br></pre></td></tr></table></figure><h2 id="54-tf类"><a class="markdownIt-Anchor" href="#54-tf类"></a> 5.4. TF类</h2><h3 id="541-tftransformlistener类"><a class="markdownIt-Anchor" href="#541-tftransformlistener类"></a> 5.4.1. tf.TransformListener类</h3><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">canTransform(self,target_frame,source_frame,time)</td><td style="text-align:center">frame是否相通</td></tr><tr><td style="text-align:center">waitForTransform(self,target_frame,source_frame,time,timeout)</td><td style="text-align:center">阻塞直到frame相通</td></tr><tr><td style="text-align:center">lookup Transform(self,target_frame,source_frame,time)</td><td style="text-align:center">查看相对的tf，返回（trans，quat）</td></tr></tbody></table><p>tf.TransformListener类中主要包含以上三种方法，它的构造函数不需要填值。注意这里的time参数，依然是使用<code>rospy.Time(0)</code>而不是<code>rospy.Time.now()</code>.具体原因上节已经介绍，这里不再赘述。除了上述三种重要的方法，这个类中还有一些辅助用的方法如下：</p><table><thead><tr><th style="text-align:center">方法</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center">chain(target_frame,target_time,source_frame,source_time,fixed_frame)</td><td style="text-align:center">frame的连接关系</td></tr><tr><td style="text-align:center">frameExists(self,frame_id)</td><td style="text-align:center">frame是否存在</td></tr><tr><td style="text-align:center">getFrameStrings(self)</td><td style="text-align:center">返回所有tf的名称</td></tr><tr><td style="text-align:center">fromTranslationRotation(translation,rotation)</td><td style="text-align:center">根据平移和旋转返回4X4矩阵</td></tr><tr><td style="text-align:center">transformPoint(target_frame,point_msg)</td><td style="text-align:center">将PointStamped消息转换到新frame下</td></tr><tr><td style="text-align:center">transformPose(target_frame,pose_msg)</td><td style="text-align:center">将PoseStamped消息转换到新frame下</td></tr><tr><td style="text-align:center">transformQuaternion(target_frame,quat_msg)</td><td style="text-align:center">将QuaternionStamped…返回相同类型</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>在<code>tf_demo</code>教学包当中的<code>scripts/py_tf_listerner.py</code>给出了示例程序，详见如下。</p><p>py_tf_listerner.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line">import rospy  </span><br><span class="line">import math  </span><br><span class="line">import tf   </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_tf_turtle&#x27;)</span><br><span class="line">    listener = tf.TransformListener() #TransformListener创建后就开始接受tf广播信息，最多可以缓存10s  目前存在的问题，是四个数值的顺序我还有点问题</span><br><span class="line">    rate = rospy.Rate(1.0)  </span><br><span class="line">    #1. 阻塞直到frame相通</span><br><span class="line">    print &#x27;1. 阻塞直到frame相通&#x27;  </span><br><span class="line">    listener.waitForTransform(&quot;/base_link&quot;, &quot;/link1&quot;, rospy.Time(), rospy.Duration(4.0))</span><br><span class="line">    while not rospy.is_shutdown():  </span><br><span class="line">        try:  </span><br><span class="line">        #2. 监听对应的tf,返回平移和旋转</span><br><span class="line">            print &#x27;2. 监听对应的tf,返回平移和旋转&#x27;  </span><br><span class="line">            (trans,rot) = listener.lookupTransform(&#x27;/base_link&#x27;, &#x27;/link1&#x27;, rospy.Time(0)) #rospy.Time(0)不表示0时刻的tf，而是指最近一帧tf </span><br><span class="line">        except (tf.LookupException, tf.ConnectivityException, tf.ExtrapolationException):  </span><br><span class="line">            continue    </span><br><span class="line">        rospy.loginfo(&#x27;距离原点的位置: x=%f ,y= %f，z=%f \n 旋转四元数: w=%f ,x= %f，y=%f z=%f &#x27;,trans[0],trans[1],trans[2],rot[0],rot[1],rot[2],rot[3])</span><br><span class="line">        #3. 判断两个frame是否相通</span><br><span class="line">        print &#x27;3. 判断两个frame是否相通&#x27;</span><br><span class="line">        if listener.canTransform(&#x27;/link1&#x27;,&#x27;/base_link&#x27;,rospy.Time(0)) :</span><br><span class="line">            print &#x27;true&#x27;</span><br><span class="line">        else :</span><br><span class="line">            print &#x27;false&#x27;</span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><h3 id="542"><a class="markdownIt-Anchor" href="#542"></a> 5.4.2.</h3><h3 id="543-tftransformbroadcaster类"><a class="markdownIt-Anchor" href="#543-tftransformbroadcaster类"></a> 5.4.3. tf.TransformBroadcaster类</h3><p>类似的，我们介绍的是发布方，tf.TransformBroadcaster类。该类的构造函数也是不需要填值，成员函数有两个如下：</p><ul><li>sendTransform(translation,rotation,time,child,parent)#向/tf发布消息</li><li>sendTransformMessage(transform)#向/tf发布消息</li></ul><p>第一个sendTransform()把transform的平移和旋转填好，打上时间戳，然后表示出从父到子的frame流，然后发向<code>/tf</code>的topic。第二种是发送transform已经封装好的Message给<code>/tf</code>，这两种不同的发送方式，功能是一致的。在<code>tf_demo</code>教学包当中的<code>scripts/py_tf_broadcaster.py</code>和<code>scripts/py_tf_broadcaster02.py</code>给出了示例程序，详见如下。</p><p>py_tf_broadcaster.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line"></span><br><span class="line">import rospy  </span><br><span class="line">import math  </span><br><span class="line">import tf    </span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_tf_broadcaster&#x27;)</span><br><span class="line">    print &#x27;讲解tf.transformBroadcaster类&#x27;</span><br><span class="line">    print &#x27;第1种发布方式：sendTransform(translation,rotation,time,child,parent)&#x27;</span><br><span class="line">#第一部分，发布sendTransform(translation,rotation,time,child,parent)</span><br><span class="line">    br = tf.TransformBroadcaster()</span><br><span class="line">#输入相对原点的值和欧拉角</span><br><span class="line">    x=1.0 </span><br><span class="line">    y=2.0</span><br><span class="line">    z=3.0  </span><br><span class="line">    roll=0 </span><br><span class="line">    pitch=0</span><br><span class="line">    yaw=1.57 </span><br><span class="line">    rate = rospy.Rate(1)</span><br><span class="line">    while not rospy.is_shutdown(): </span><br><span class="line">        yaw=yaw+0.1   </span><br><span class="line">        br.sendTransform((x,y,z),  </span><br><span class="line">                     tf.transformations.quaternion_from_euler(roll,pitch,yaw),  </span><br><span class="line">                     rospy.Time.now(),  </span><br><span class="line">                     &quot;base_link&quot;,  </span><br><span class="line">                     &quot;link1&quot;)  #发布base_link到link1的平移和翻转   </span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><p>py_tf_broadcaster02.py</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#!/usr/bin/env python  </span><br><span class="line"># -*- coding:utf-8 -*-  </span><br><span class="line"></span><br><span class="line">import rospy </span><br><span class="line">import geometry_msgs.msg</span><br><span class="line">import tf2_ros.transform_broadcaster</span><br><span class="line">import math  </span><br><span class="line">import tf   </span><br><span class="line"></span><br><span class="line">if __name__ == &#x27;__main__&#x27;:  </span><br><span class="line">    rospy.init_node(&#x27;py_tf_broadcaster&#x27;)</span><br><span class="line">    print &#x27;讲解tf.transformBroadcaster类&#x27;</span><br><span class="line">    print &#x27;第2种发布方式：sendTransformMessage(transform)&#x27;</span><br><span class="line">#第二部分，发布sendTransformMessage(transform)</span><br><span class="line">    m=tf.TransformBroadcaster()</span><br><span class="line">    t = geometry_msgs.msg.TransformStamped()</span><br><span class="line">    t.header.frame_id = &#x27;base_link&#x27;</span><br><span class="line">    t.header.stamp = rospy.Time(0)</span><br><span class="line">    t.child_frame_id = &#x27;link1&#x27;</span><br><span class="line">    t.transform.translation.x = 1</span><br><span class="line">    t.transform.translation.y = 2</span><br><span class="line">    t.transform.translation.z = 3</span><br><span class="line">    t.transform.rotation.w=1</span><br><span class="line">    t.transform.rotation.x=0</span><br><span class="line">    t.transform.rotation.y=0</span><br><span class="line">    t.transform.rotation.z=0</span><br><span class="line">#输入相对原点的值和欧拉角</span><br><span class="line">    rate = rospy.Rate(1)</span><br><span class="line">    while not rospy.is_shutdown():</span><br><span class="line">        m.sendTransformMessage(t)</span><br><span class="line">        rate.sleep()</span><br></pre></td></tr></table></figure><h2 id="55-tf相关工具命令"><a class="markdownIt-Anchor" href="#55-tf相关工具命令"></a> 5.5. TF相关工具命令</h2><ol><li><p>根据当前的tf树创建一个pdf图：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun tf view_frames</span><br></pre></td></tr></table></figure><p>这个工具首先订阅<code>/tf</code>，订阅5秒钟，根据这段时间接受到的tf信息，绘制成一张tf tree，然后创建成一个pdf图。</p></li><li><p>查看当前的tf树：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun rqt_tf_tree rqt_tf_tree</span><br></pre></td></tr></table></figure><p>该命令同样是查询tf tree的，但是与第一个命令的区别是该命令是动态的查询当前的tf tree,当前的任何变化都能当即看到，例如何时断开何时连接，捕捉到这些然后通过rqt插件显示出来。</p></li><li><p>查看两个frame之间的变换关系：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ rosrun tf tf_echo[reference_frame][target_frame]</span><br></pre></td></tr></table></figure></li></ol>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo官方标签插件使用</title>
      <link href="/posts/ac1d9abb.html"/>
      <url>/posts/ac1d9abb.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-标签插件tag-plugins"><a class="markdownIt-Anchor" href="#1-标签插件tag-plugins"></a> 1. 标签插件（Tag Plugins）</h1><p>标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。</p><h2 id="11-引用块"><a class="markdownIt-Anchor" href="#11-引用块"></a> 1.1. 引用块</h2><p>在文章中插入引言，可包含作者、来源和标题。</p><p><strong>别号：</strong> quote</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote [author[, source]] [link] [source<span class="emphasis">_link_</span>title] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><h3 id="111-样例"><a class="markdownIt-Anchor" href="#111-样例"></a> 1.1.1. 样例</h3><p><strong>没有提供参数，则只输出普通的 blockquote</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote %&#125;</span><br><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem.</p></blockquote><p><strong>引用书上的句子</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote David Levithan, Wide Awake %&#125;</span><br><span class="line">Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy.</p><footer><strong>David Levithan</strong><cite>Wide Awake</cite></footer></blockquote><p><strong>引用 Twitter</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %&#125;</span><br><span class="line">NEW: DevDocs now comes with syntax highlighting. http://devdocs.io</span><br><span class="line">&#123;% endblockquote %&#125;</span><br></pre></td></tr></table></figure><blockquote><p>NEW: DevDocs now comes with syntax highlighting. <a href="http://devdocs.io">http://devdocs.io</a></p><footer><strong>@DevDocs</strong><cite><a href="https://twitter.com/devdocs/status/356095192085962752">twitter.com/devdocs/status/356095192085962752</a></cite></footer></blockquote><p><strong>引用网络上的文章</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% blockquote Seth Godin http://sethgodin.typepad.com/seths<span class="emphasis">_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %&#125;</span></span><br><span class="line"><span class="emphasis">Every interaction is both precious and an opportunity to delight.</span></span><br><span class="line"><span class="emphasis">&#123;% endblockquote %&#125;</span></span><br></pre></td></tr></table></figure><blockquote><p>Every interaction is both precious and an opportunity to delight.</p><footer><strong>Seth Godin</strong><cite><a href="http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html">Welcome to Island Marketing</a></cite></footer></blockquote><h2 id="12-代码块"><a class="markdownIt-Anchor" href="#12-代码块"></a> 1.2. 代码块</h2><p>在文章中插入代码。</p><p><strong>别名：</strong> code</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock [title] [lang:language] [url] [link text] [additional options] %&#125;</span><br><span class="line">code snippet</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><p>Specify additional options in <code>option:value</code> format, e.g. <code>line_number:false first_line:5</code>.</p><table><thead><tr><th style="text-align:left">Extra Options</th><th style="text-align:left">Description</th><th style="text-align:left">Default</th></tr></thead><tbody><tr><td style="text-align:left"><code>line_number</code></td><td style="text-align:left">Show line number</td><td style="text-align:left"><code>true</code></td></tr><tr><td style="text-align:left"><code>highlight</code></td><td style="text-align:left">Enable code highlighting</td><td style="text-align:left"><code>true</code></td></tr><tr><td style="text-align:left"><code>first_line</code></td><td style="text-align:left">Specify the first line number</td><td style="text-align:left"><code>1</code></td></tr><tr><td style="text-align:left"><code>mark</code></td><td style="text-align:left">Line highlight specific line(s), each value separated by a comma. Specify number range using a dash Example: <code>mark:1,4-7,10</code> will mark line 1, 4 to 7 and 10.</td><td style="text-align:left"></td></tr><tr><td style="text-align:left"><code>wrap</code></td><td style="text-align:left">Wrap the code block in <a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element/table">``</a></td><td style="text-align:left"><code>true</code></td></tr></tbody></table><h3 id="121-样例"><a class="markdownIt-Anchor" href="#121-样例"></a> 1.2.1. 样例</h3><p><strong>普通的代码块</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock %&#125;</span><br><span class="line">alert(&#x27;Hello World!&#x27;);</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alert(&#x27;Hello World!&#x27;);</span><br></pre></td></tr></table></figure><p><strong>指定语言</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock lang:objc %&#125;</span><br><span class="line">[rectangle setX: 10 y: 10 width: 20 height: 20];</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[rectangle setX: <span class="number">10</span> y: <span class="number">10</span> width: <span class="number">20</span> height: <span class="number">20</span>];</span><br></pre></td></tr></table></figure><p><strong>附加说明</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock Array.map %&#125;</span><br><span class="line">array.map(callback[, thisArg])</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>Array.map</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array.map(callback[, thisArg])</span><br></pre></td></tr></table></figure><p><strong>附加说明和网址</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% codeblock <span class="emphasis">_.compact http://underscorejs.org/#compact Underscore.js %&#125;</span></span><br><span class="line"><span class="emphasis">_</span>.compact([0, 1, false, 2, &#x27;&#x27;, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br><span class="line">&#123;% endcodeblock %&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><figcaption><span>_.compact</span><a href="http://underscorejs.org/#compact">Underscore.js</a></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">_.compact([0, 1, false, 2, &#x27;&#x27;, 3]);</span><br><span class="line">=&gt; [1, 2, 3]</span><br></pre></td></tr></table></figure><h2 id="13-反引号代码块"><a class="markdownIt-Anchor" href="#13-反引号代码块"></a> 1.3. 反引号代码块</h2><p>另一种形式的代码块，不同的是它使用三个反引号来包裹。</p><p>``` [language] [title] [url] [link text] code snippet ```</p><h2 id="14-pull-quote"><a class="markdownIt-Anchor" href="#14-pull-quote"></a> 1.4. Pull Quote</h2><p>在文章中插入 Pull quote。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% pullquote [class] %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endpullquote %&#125;</span><br></pre></td></tr></table></figure><h2 id="15-jsfiddle"><a class="markdownIt-Anchor" href="#15-jsfiddle"></a> 1.5. jsFiddle</h2><p>在文章中嵌入 jsFiddle。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% jsfiddle shorttag [tabs] [skin] [width] [height] %&#125;</span><br></pre></td></tr></table></figure><h2 id="16-gist"><a class="markdownIt-Anchor" href="#16-gist"></a> 1.6. Gist</h2><p>在文章中嵌入 Gist。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gist gist<span class="emphasis">_id [filename] %&#125;</span></span><br></pre></td></tr></table></figure><h2 id="17-iframe"><a class="markdownIt-Anchor" href="#17-iframe"></a> 1.7. iframe</h2><p>在文章中插入 iframe。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% iframe url [width] [height] %&#125;</span><br></pre></td></tr></table></figure><h2 id="18-image"><a class="markdownIt-Anchor" href="#18-image"></a> 1.8. Image</h2><p>在文章中插入指定大小的图片。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% img [class names] /path/to/image [width] [height] &#x27;&quot;title text&quot; &quot;alt text&quot;&#x27; %&#125;</span><br></pre></td></tr></table></figure><h2 id="19-link"><a class="markdownIt-Anchor" href="#19-link"></a> 1.9. Link</h2><p>在文章中插入链接，并自动给外部链接添加 <code>target=&quot;_blank&quot;</code> 属性。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% link text url [external] [title] %&#125;</span><br></pre></td></tr></table></figure><h2 id="110-include-code"><a class="markdownIt-Anchor" href="#110-include-code"></a> 1.10. Include Code</h2><p>插入 <code>source/downloads/code</code> 文件夹内的代码文件。<code>source/downloads/code</code> 不是固定的，取决于你在配置文件中 <code>code_dir</code> 的配置。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include<span class="emphasis">_code [title] [lang:language] [from:line] [to:line] path/to/file %&#125;</span></span><br></pre></td></tr></table></figure><h3 id="1101-样例"><a class="markdownIt-Anchor" href="#1101-样例"></a> 1.10.1. 样例</h3><p><strong>嵌入 test.js 文件全文</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include<span class="emphasis">_code lang:javascript test.js %&#125;</span></span><br></pre></td></tr></table></figure><p><strong>只嵌入第 3 行</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include<span class="emphasis">_code lang:javascript from:3 to:3 test.js %&#125;</span></span><br></pre></td></tr></table></figure><p><strong>嵌入第 5 行至第 8 行</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include<span class="emphasis">_code lang:javascript from:5 to:8 test.js %&#125;</span></span><br></pre></td></tr></table></figure><p><strong>嵌入第 5 行至文件结束</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include<span class="emphasis">_code lang:javascript from:5 test.js %&#125;</span></span><br></pre></td></tr></table></figure><p><strong>嵌入第 1 行至第 8 行</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include<span class="emphasis">_code lang:javascript to:8 test.js %&#125;</span></span><br></pre></td></tr></table></figure><h2 id="111-youtube"><a class="markdownIt-Anchor" href="#111-youtube"></a> 1.11. Youtube</h2><p>在文章中插入 Youtube 视频。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% youtube video<span class="emphasis">_id %&#125;</span></span><br></pre></td></tr></table></figure><h2 id="112-vimeo"><a class="markdownIt-Anchor" href="#112-vimeo"></a> 1.12. Vimeo</h2><p>在文章中插入 Vimeo 视频。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% vimeo video<span class="emphasis">_id %&#125;</span></span><br></pre></td></tr></table></figure><h2 id="113-引用文章"><a class="markdownIt-Anchor" href="#113-引用文章"></a> 1.13. 引用文章</h2><p>引用其他文章的链接。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_path filename %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% post_</span>link filename [title] [escape] %&#125;</span><br></pre></td></tr></table></figure><p>在使用此标签时可以忽略文章文件所在的路径或者文章的永久链接信息、如语言、日期。</p><p>例如，在文章中使用 <code>&#123;% post_link how-to-bake-a-cake %&#125;</code> 时，只需有一个名为 <code>how-to-bake-a-cake.md</code> 的文章文件即可。即使这个文件位于站点文件夹的 <code>source/posts/2015-02-my-family-holiday</code> 目录下、或者文章的永久链接是 <code>2018/en/how-to-bake-a-cake</code>，都没有影响。</p><p>默认链接文字是文章的标题，你也可以自定义要显示的文本。此时不应该使用 Markdown 语法 <code>[]()</code>。</p><p>默认对文章的标题和自定义标题里的特殊字符进行转义。可以使用<code>escape</code>选项，禁止对特殊字符进行转义。</p><p><strong>链接使用文章的标题</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link hexo-3-8-released %&#125;</span></span><br></pre></td></tr></table></figure><a href="#">Post not found: hexo-3-8-released</a><p><strong>链接使用自定义文字</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link hexo-3-8-released &#x27;通往文章的链接&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><a href="#">Post not found: hexo-3-8-released 通往文章的链接</a><p><strong>对标题的特殊字符进行转义</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link hexo-4-released &#x27;How to use <span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span> tag in title&#x27; %&#125;</span></span><br></pre></td></tr></table></figure><a href="#">Post not found: hexo-4-released How to use <b> tag in title</a><p><strong>禁止对标题的特殊字符进行转义</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% post<span class="emphasis">_link hexo-4-released &#x27;<span class="xml"><span class="tag">&lt;<span class="name">b</span>&gt;</span></span>bold<span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span> custom title&#x27; false %&#125;</span></span><br></pre></td></tr></table></figure><a href="#">Post not found: hexo-4-released <b>bold</b> custom title false</a><h2 id="114-引用资源"><a class="markdownIt-Anchor" href="#114-引用资源"></a> 1.14. 引用资源</h2><p>引用文章的资源。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% asset<span class="emphasis">_path filename %&#125;</span></span><br><span class="line"><span class="emphasis">&#123;% asset_</span>img filename [title] %&#125;</span><br><span class="line">&#123;% asset<span class="emphasis">_link filename [title] [escape] %&#125;</span></span><br></pre></td></tr></table></figure><h2 id="115-raw"><a class="markdownIt-Anchor" href="#115-raw"></a> 1.15. Raw</h2><p>如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% raw %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endraw %&#125;</span><br></pre></td></tr></table></figure><h2 id="116-文章摘要和截断"><a class="markdownIt-Anchor" href="#116-文章摘要和截断"></a> 1.16. 文章摘要和截断</h2><p>在文章中使用 <code>，那么</code> 之前的文字将会被视为摘要。首页中将只出现这部分文字，同时这部分文字也会出现在正文之中。</p><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line">&lt;!-- more --&gt;</span><br><span class="line">Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure><p>首页中将只会出现</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br></pre></td></tr></table></figure><p>正文中则会出现</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Lorem ipsum dolor sit amet, consectetur adipiscing elit, sed do eiusmod tempor incididunt ut labore et dolore magna aliqua.</span><br><span class="line"></span><br><span class="line">Ut enim ad minim veniam, quis nostrud exercitation ullamco laboris nisi ut aliquip ex ea commodo consequat. Duis aute irure dolor in reprehenderit in voluptate velit esse cillum dolore eu fugiat nulla pariatur. Excepteur sint occaecat cupidatat non proident, sunt in culpa qui officia deserunt mollit anim id est laborum.</span><br></pre></td></tr></table></figure><p>注意，摘要可能会被 Front Matter 中的 <code>excerpt</code> 覆盖。</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo主题使用笔记</title>
      <link href="/posts/7d372036.html"/>
      <url>/posts/7d372036.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-mermaid图表插件基本使用格式"><a class="markdownIt-Anchor" href="#1-mermaid图表插件基本使用格式"></a> 1. Mermaid图表插件基本使用格式</h1><blockquote><p>详情参考Mermaid<a href="https://mermaid-js.github.io/mermaid/#/">官方文档</a>和官方<a href="https://github.com/mermaid-js/mermaid">Github</a>,还有可以实时在线编辑预览的<a href="https://mermaid-js.github.io/mermaid-live-editor/">mermaid在线编辑器</a></p></blockquote><blockquote><blockquote><p>小技巧,如果不想Markdown渲染加载图表太久,我们可以直接调用在线编辑器生成的图片链接,通过我们生成的图表链接显示图片达到显示图表的目的!Enjoy it!</p><p>例如调用下超链接</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[![](https://mermaid.ink/img/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5DbGFzczAxIDx8LS0gQXZlcnlMb25nQ2xhc3MgOiBDb29sXG48PGludGVyZmFjZT4-IENsYXNzMDFcbkNsYXNzMDkgLS0-IEMyIDogV2hlcmUgYW0gaT9cbkNsYXNzMDkgLS0qIEMzXG5DbGFzczA5IC0tfD4gQ2xhc3MwN1xuQ2xhc3MwNyA6IGVxdWFscygpXG5DbGFzczA3IDogT2JqZWN0W10gZWxlbWVudERhdGFcbkNsYXNzMDEgOiBzaXplKClcbkNsYXNzMDEgOiBpbnQgY2hpbXBcbkNsYXNzMDEgOiBpbnQgZ29yaWxsYVxuY2xhc3MgQ2xhc3MxMCB7XG4gID4-c2VydmljZT4-XG4gIGludCBpZFxuICBzaXplKClcbn0iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ)](https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5DbGFzczAxIDx8LS0gQXZlcnlMb25nQ2xhc3MgOiBDb29sXG48PGludGVyZmFjZT4-IENsYXNzMDFcbkNsYXNzMDkgLS0-IEMyIDogV2hlcmUgYW0gaT9cbkNsYXNzMDkgLS0qIEMzXG5DbGFzczA5IC0tfD4gQ2xhc3MwN1xuQ2xhc3MwNyA6IGVxdWFscygpXG5DbGFzczA3IDogT2JqZWN0W10gZWxlbWVudERhdGFcbkNsYXNzMDEgOiBzaXplKClcbkNsYXNzMDEgOiBpbnQgY2hpbXBcbkNsYXNzMDEgOiBpbnQgZ29yaWxsYVxuY2xhc3MgQ2xhc3MxMCB7XG4gID4-c2VydmljZT4-XG4gIGludCBpZFxuICBzaXplKClcbn0iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ)</span><br></pre></td></tr></table></figure><p>显示效果:</p><p><a href="https://mermaid-js.github.io/mermaid-live-editor/#/edit/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5DbGFzczAxIDx8LS0gQXZlcnlMb25nQ2xhc3MgOiBDb29sXG48PGludGVyZmFjZT4-IENsYXNzMDFcbkNsYXNzMDkgLS0-IEMyIDogV2hlcmUgYW0gaT9cbkNsYXNzMDkgLS0qIEMzXG5DbGFzczA5IC0tfD4gQ2xhc3MwN1xuQ2xhc3MwNyA6IGVxdWFscygpXG5DbGFzczA3IDogT2JqZWN0W10gZWxlbWVudERhdGFcbkNsYXNzMDEgOiBzaXplKClcbkNsYXNzMDEgOiBpbnQgY2hpbXBcbkNsYXNzMDEgOiBpbnQgZ29yaWxsYVxuY2xhc3MgQ2xhc3MxMCB7XG4gID4-c2VydmljZT4-XG4gIGludCBpZFxuICBzaXplKClcbn0iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ"><img src="https://mermaid.ink/img/eyJjb2RlIjoiY2xhc3NEaWFncmFtXG5DbGFzczAxIDx8LS0gQXZlcnlMb25nQ2xhc3MgOiBDb29sXG48PGludGVyZmFjZT4-IENsYXNzMDFcbkNsYXNzMDkgLS0-IEMyIDogV2hlcmUgYW0gaT9cbkNsYXNzMDkgLS0qIEMzXG5DbGFzczA5IC0tfD4gQ2xhc3MwN1xuQ2xhc3MwNyA6IGVxdWFscygpXG5DbGFzczA3IDogT2JqZWN0W10gZWxlbWVudERhdGFcbkNsYXNzMDEgOiBzaXplKClcbkNsYXNzMDEgOiBpbnQgY2hpbXBcbkNsYXNzMDEgOiBpbnQgZ29yaWxsYVxuY2xhc3MgQ2xhc3MxMCB7XG4gID4-c2VydmljZT4-XG4gIGludCBpZFxuICBzaXplKClcbn0iLCJtZXJtYWlkIjp7InRoZW1lIjoiZGVmYXVsdCJ9fQ" alt="" /></a></p></blockquote></blockquote><h2 id="流程图"><a class="markdownIt-Anchor" href="#流程图"></a> 流程图</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">graph TD</span><br><span class="line"><span class="code">    A[Hard] --&gt;|Text| B(Round)</span></span><br><span class="line"><span class="code">    B --&gt; C&#123;Decision&#125;</span></span><br><span class="line"><span class="code">    C --&gt;|One| D[Result 1]</span></span><br><span class="line"><span class="code">    C --&gt;|Two| E[Result 2]</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  graph TD    A[Hard] --&gt;|Text| B(Round)    B --&gt; C{Decision}    C --&gt;|One| D[Result 1]    C --&gt;|Two| E[Result 2]  </pre></div><h2 id="顺序图"><a class="markdownIt-Anchor" href="#顺序图"></a> 顺序图</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">sequenceDiagram</span><br><span class="line"><span class="code">    Alice-&gt;&gt;John: Hello John, how are you?</span></span><br><span class="line"><span class="code">    loop Healthcheck</span></span><br><span class="line"><span class="code">        John-&gt;&gt;John: Fight against hypochondria</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code">    Note right of John: Rational thoughts!</span></span><br><span class="line"><span class="code">    John--&gt;&gt;Alice: Great!</span></span><br><span class="line"><span class="code">    John-&gt;&gt;Bob: How about you?</span></span><br><span class="line"><span class="code">    Bob--&gt;&gt;John: Jolly good!</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  sequenceDiagram    Alice-&gt;&gt;John: Hello John, how are you?    loop Healthcheck        John-&gt;&gt;John: Fight against hypochondria    end    Note right of John: Rational thoughts!    John--&gt;&gt;Alice: Great!    John-&gt;&gt;Bob: How about you?    Bob--&gt;&gt;John: Jolly good!  </pre></div><h2 id="甘特图"><a class="markdownIt-Anchor" href="#甘特图"></a> 甘特图</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">gantt</span><br><span class="line"><span class="code">    section Section</span></span><br><span class="line"><span class="code">    Completed :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class="line"><span class="code">    Active        :active,  des2, 2014-01-07, 3d</span></span><br><span class="line"><span class="code">    Parallel 1   :         des3, after des1, 1d</span></span><br><span class="line"><span class="code">    Parallel 2   :         des4, after des1, 1d</span></span><br><span class="line"><span class="code">    Parallel 3   :         des5, after des3, 1d</span></span><br><span class="line"><span class="code">    Parallel 4   :         des6, after des4, 1d</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  gantt    section Section    Completed :done,    des1, 2014-01-06,2014-01-08    Active        :active,  des2, 2014-01-07, 3d    Parallel 1   :         des3, after des1, 1d    Parallel 2   :         des4, after des1, 1d    Parallel 3   :         des5, after des3, 1d    Parallel 4   :         des6, after des4, 1d  </pre></div><h2 id="类图"><a class="markdownIt-Anchor" href="#类图"></a> 类图</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line"> classDiagram</span><br><span class="line"><span class="code">      Animal &lt;|-- Duck</span></span><br><span class="line"><span class="code">      Animal &lt;|-- Fish</span></span><br><span class="line"><span class="code">      Animal &lt;|-- Zebra</span></span><br><span class="line"><span class="code">      Animal : +int age</span></span><br><span class="line"><span class="code">      Animal : +String gender</span></span><br><span class="line"><span class="code">      Animal: +isMammal()</span></span><br><span class="line"><span class="code">      Animal: +mate()</span></span><br><span class="line"><span class="code">      class Duck&#123;</span></span><br><span class="line"><span class="code">          +String beakColor</span></span><br><span class="line"><span class="code">          +swim()</span></span><br><span class="line"><span class="code">          +quack()</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">      class Fish&#123;</span></span><br><span class="line"><span class="code">          -int sizeInFeet</span></span><br><span class="line"><span class="code">          -canEat()</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">      class Zebra&#123;</span></span><br><span class="line"><span class="code">          +bool is_wild</span></span><br><span class="line"><span class="code">          +run()</span></span><br><span class="line"><span class="code">      &#125;</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  classDiagram     Animal &lt;|-- Duck     Animal &lt;|-- Fish     Animal &lt;|-- Zebra     Animal : +int age     Animal : +String gender     Animal: +isMammal()     Animal: +mate()     class Duck{         +String beakColor         +swim()         +quack()     }     class Fish{         -int sizeInFeet         -canEat()     }     class Zebra{         +bool is_wild         +run()     }  </pre></div><h2 id="状态图"><a class="markdownIt-Anchor" href="#状态图"></a> 状态图</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">stateDiagram</span><br><span class="line"><span class="code">    [*] --&gt; Still</span></span><br><span class="line"><span class="code">    Still --&gt; [*]</span></span><br><span class="line"><span class="code">    Still --&gt; Moving</span></span><br><span class="line"><span class="code">    Moving --&gt; Still</span></span><br><span class="line"><span class="code">    Moving --&gt; Crash</span></span><br><span class="line"><span class="code">    Crash --&gt; [*]</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  stateDiagram    [*] --&gt; Still    Still --&gt; [*]    Still --&gt; Moving    Moving --&gt; Still    Moving --&gt; Crash    Crash --&gt; [*]  </pre></div><h2 id="饼状图"><a class="markdownIt-Anchor" href="#饼状图"></a> 饼状图</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% mermaid %&#125;</span><br><span class="line">pie</span><br><span class="line"><span class="code">    title Key elements in Product X</span></span><br><span class="line"><span class="code">    &quot;Calcium&quot; : 42.96</span></span><br><span class="line"><span class="code">    &quot;Potassium&quot; : 50.05</span></span><br><span class="line"><span class="code">    &quot;Magnesium&quot; : 10.01</span></span><br><span class="line"><span class="code">    &quot;Iron&quot; :  5</span></span><br><span class="line"><span class="code">&#123;% endmermaid %&#125;</span></span><br></pre></td></tr></table></figure><div class="mermaid-wrap"><pre class="mermaid-src" hidden>  pie    title Key elements in Product X    &quot;Calcium&quot; : 42.96    &quot;Potassium&quot; : 50.05    &quot;Magnesium&quot; : 10.01    &quot;Iron&quot; :  5  </pre></div><h1 id="2-标签外挂tag-plugins"><a class="markdownIt-Anchor" href="#2-标签外挂tag-plugins"></a> 2. 标签外挂（Tag Plugins）</h1><p><strong>用法</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note [class] [no-icon] %&#125;</span><br><span class="line">Any content (support inline tags too.io).</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">[class]   : default | primary | success | info | warning | danger.</span><br><span class="line">[no-icon] : Disable icon in note.</span><br><span class="line"></span><br><span class="line">All parameters are optional.</span><br></pre></td></tr></table></figure><p><strong>例如：</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">&#123;% note default %&#125;</span><br><span class="line">default 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note primary %&#125;</span><br><span class="line">primary 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note success %&#125;</span><br><span class="line">success 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note info %&#125;</span><br><span class="line">info 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note warning %&#125;</span><br><span class="line">warning 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br><span class="line"></span><br><span class="line">&#123;% note danger %&#125;</span><br><span class="line">danger 提示块标签</span><br><span class="line">&#123;% endnote %&#125;</span><br></pre></td></tr></table></figure><p><strong>显示效果:</strong></p><blockquote><p>可在配置里自行设置风格:style: simple / modern / disabled</p></blockquote><div class="note default flat"><p>default 提示块标签</p></div><div class="note primary flat"><p>primary 提示块标签</p></div><div class="note success flat"><p>success 提示块标签</p></div><div class="note info flat"><p>info 提示块标签</p></div><div class="note warning flat"><p>warning 提示块标签</p></div><div class="note danger flat"><p>danger 提示块标签</p></div><h1 id="3-gallery相册图库"><a class="markdownIt-Anchor" href="#3-gallery相册图库"></a> 3. Gallery相册图库</h1><p>一个图库集合。</p><p>写法</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line">&#123;% galleryGroup name description link img-url %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><ul><li>name：图库名字</li><li>description：图库描述</li><li>link：连接到对应相册的地址</li><li>img-url：图库封面的地址</li></ul><p>例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">&quot;gallery-group-main&quot;</span>&gt;</span></span></span><br><span class="line">&#123;% galleryGroup &#x27;壁纸&#x27; &#x27;收藏的一些壁纸&#x27; &#x27;/Gallery/wallpaper&#x27; https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;漫威&#x27; &#x27;关于漫威的图片&#x27; &#x27;/Gallery/marvel&#x27; https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg %&#125;</span><br><span class="line">&#123;% galleryGroup &#x27;OH MY GIRL&#x27; &#x27;关于OH MY GIRL的图片&#x27; &#x27;/Gallery/ohmygirl&#x27; https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg %&#125;</span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br></pre></td></tr></table></figure><p><strong>显示效果:</strong></p><div class="gallery-group-main">  <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://i.loli.net/2019/11/10/T7Mu8Aod3egmC4Q.png' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">壁纸</div>  <p>收藏的一些壁纸</p>  <a href='/Gallery/wallpaper'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://i.loli.net/2019/12/25/8t97aVlp4hgyBGu.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">漫威</div>  <p>关于漫威的图片</p>  <a href='/Gallery/marvel'></a>  </figcaption>  </figure>    <figure class="gallery-group">  <img class="gallery-group-img no-lightbox" src='https://i.loli.net/2019/12/25/hOqbQ3BIwa6KWpo.jpg' alt="Group Image Gallery">  <figcaption>  <div class="gallery-group-name">OH MY GIRL</div>  <p>关于OH MY GIRL的图片</p>  <a href='/Gallery/ohmygirl'></a>  </figcaption>  </figure>  </div><h1 id="4-gallery相册"><a class="markdownIt-Anchor" href="#4-gallery相册"></a> 4. Gallery相册</h1><p>写法:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">markdown 图片格式</span><br><span class="line">&#123;% endgallery %&#125;</span><br></pre></td></tr></table></figure><p>例如</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-scary-pumpkin-hand-900x600.jpg)</span><br><span class="line">![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-fresh-fish-dinner-900x600.jpg)</span><br><span class="line">![](https://gratisography.com/wp-content/uploads/2019/10/gratisography-mountain-cloud-landscape-900x600.jpg)</span><br><span class="line">![](https://picjumbo.com/wp-content/uploads/iphone-free-stock-photos-2210x3315.jpg)</span><br><span class="line">![](https://picjumbo.com/wp-content/uploads/young-millennial-girl-drinking-lemonade-and-overlooking-the-city-2210x1473.jpg)</span><br><span class="line">![](https://picjumbo.com/wp-content/uploads/modern-graphic-designer-essentials<span class="emphasis">_free_</span>stock<span class="emphasis">_photos_</span>picjumbo<span class="emphasis">_HNCK4919-2210x1474.jpg)</span></span><br><span class="line"><span class="emphasis">&#123;% endgallery %&#125;</span></span><br></pre></td></tr></table></figure><h1 id="5-tag-hide"><a class="markdownIt-Anchor" href="#5-tag-hide"></a> 5.  tag-hide</h1><p>写法：</p><p><code>inline</code> 在文本里面添加按钮隐藏内容，只限文字</p><p>( content不能包含当引号，可用<code>'</code>)</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideInline content,display,bg,color %&#125;</span><br></pre></td></tr></table></figure><ul><li>content: 文本内容</li><li>display: 按钮显示的文字(可选)</li><li>bg: 按钮的背景颜色(可选)</li><li>color: 按钮文字的颜色(可选)</li></ul><p><code>block</code>独立的block隐藏内容，可以隐藏很多内容，包括图片，代码块等等</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock display,bg,color %&#125;</span><br><span class="line">content</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><ul><li>content: 文本内容</li><li>display: 按钮显示的文字(可选)</li><li>bg: 按钮的背景颜色(可选)</li><li>color: 按钮文字的颜色(可选)</li></ul><p>例如：</p><blockquote><p>inline</p></blockquote><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">哪个英文字母最酷？ &#123;% hideInline 因为西装裤(C装酷),查看答案,#FF7242,#fff %&#125;</span><br><span class="line"></span><br><span class="line">门里站着一个人? &#123;% hideInline 闪 %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-docs-tag-hide-inline.gif" alt="img" /></p><blockquote><p>block</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&#123;% hideBlock 查看答案 %&#125;</span><br><span class="line">&#123;% gallery %&#125;</span><br><span class="line">![](https://i.loli.net/2019/12/25/Fze9jchtnyJXMHN.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/ryLVePaqkYm4TEK.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/gEy5Zc1Ai6VuO4N.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/d6QHbytlSYO4FBG.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/6nepIJ1xTgufatZ.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/E7Jvr4eIPwUNmzq.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/mh19anwBSWIkGlH.jpg)</span><br><span class="line">![](https://i.loli.net/2019/12/25/2tu9JC8ewpBFagv.jpg)</span><br><span class="line">&#123;% endgallery %&#125;</span><br><span class="line">&#123;% endhideBlock %&#125;</span><br></pre></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/jerryc127/CDN/img/hexo-theme-butterfly-tag-hide-block.gif" alt="img" /></p><h1 id="6-自定义字体"><a class="markdownIt-Anchor" href="#6-自定义字体"></a> 6. 自定义字体</h1><p>可自行设置字体的<code>font-family</code></p><p>配置配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">font-family:</span> <span class="string">Lato,</span> <span class="string">Helvetica</span> <span class="string">Neue</span> <span class="string">For</span> <span class="string">Number,</span> <span class="string">-apple-system,</span> <span class="string">BlinkMacSystemFont,</span> <span class="string">Segoe</span> <span class="string">UI,</span> <span class="string">Roboto,</span> <span class="string">PingFang</span> <span class="string">SC,</span> <span class="string">Hiragino</span> <span class="string">Sans</span> <span class="string">GB,&quot;Microsoft</span> <span class="string">JhengHei&quot;,</span> <span class="string">&quot;MicrMicrosoft YaHei&quot;</span><span class="string">,</span> <span class="string">Helvetica</span> <span class="string">Neue,</span> <span class="string">Helvetica,</span> <span class="string">Arial,</span> <span class="string">sans-serif</span></span><br><span class="line">  <span class="attr">code-font:</span> <span class="string">consolas,</span> <span class="string">Menlo,</span> <span class="string">&quot;PingFang SC&quot;</span><span class="string">,</span> <span class="string">&quot;Microsoft JhengHei&quot;</span><span class="string">,&quot;Micro</span></span><br></pre></td></tr></table></figure><h1 id="7-katex"><a class="markdownIt-Anchor" href="#7-katex"></a> 7. Katex</h1><blockquote><p>参考<a href="https://github.com/yzhang-gh/markdown-it-katex">官方文档</a></p></blockquote><p><strong>示例</strong></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># Maxwell&#x27;s Equations</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line">equation | description</span><br><span class="line">----------|------------</span><br><span class="line">$\nabla \cdot \vec&#123;\mathbf&#123;B&#125;&#125;  = 0$ | divergence of $\vec&#123;\mathbf&#123;B&#125;&#125;$ is zero</span><br><span class="line">$\nabla \times \vec&#123;\mathbf&#123;E&#125;&#125;\, +\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;B&#125;&#125;&#125;&#123;\partial t&#125;  = \vec&#123;\mathbf&#123;0&#125;&#125;$ |  curl of $\vec&#123;\mathbf&#123;E&#125;&#125;$ is proportional to the rate of change of $\vec&#123;\mathbf&#123;B&#125;&#125;$</span><br><span class="line">$\nabla \times \vec&#123;\mathbf&#123;B&#125;&#125; -\, \frac1c\, \frac&#123;\partial\vec&#123;\mathbf&#123;E&#125;&#125;&#125;&#123;\partial t&#125; = \frac&#123;4\pi&#125;&#123;c&#125;\vec&#123;\mathbf&#123;j&#125;&#125;    \nabla \cdot \vec&#123;\mathbf&#123;E&#125;&#125; = 4 \pi \rho$ | <span class="emphasis">_wha?_</span></span><br></pre></td></tr></table></figure><p><strong>Maxwell’s Equations</strong></p><table><thead><tr><th>equation</th><th>description</th></tr></thead><tbody><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∇</mi><mo>⋅</mo><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover><mo>=</mo><mn>0</mn></mrow><annotation encoding="application/x-tex">\nabla \cdot \vec{\mathbf{B}}  = 0</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.68333em;vertical-align:0em;"></span><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9691099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">B</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.64444em;vertical-align:0em;"></span><span class="mord">0</span></span></span></span></td><td>divergence of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\mathbf{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9691099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">B</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> is zero</td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∇</mi><mo>×</mo><mover accent="true"><mi mathvariant="bold">E</mi><mo>⃗</mo></mover><mtext> </mtext><mo>+</mo><mtext> </mtext><mfrac><mn>1</mn><mi>c</mi></mfrac><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mover accent="true"><mn mathvariant="bold">0</mn><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\nabla \times \vec{\mathbf{E}}\, +\, \frac1c\, \frac{\partial\vec{\mathbf{B}}}{\partial t}  = \vec{\mathbf{0}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0524399999999998em;vertical-align:-0.08333em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">E</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mbin">+</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1.4173769999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.072377em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight">B</span></span></span></span><span style="top:-2.96911em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.92744em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.92744em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">0</span></span></span></span><span style="top:-3.21344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span></td><td>curl of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi mathvariant="bold">E</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\mathbf{E}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9691099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">E</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span> is proportional to the rate of change of <span class="katex"><span class="katex-mathml"><math><semantics><mrow><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover></mrow><annotation encoding="application/x-tex">\vec{\mathbf{B}}</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9691099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">B</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span></td></tr><tr><td><span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi mathvariant="normal">∇</mi><mo>×</mo><mover accent="true"><mi mathvariant="bold">B</mi><mo>⃗</mo></mover><mo>−</mo><mtext> </mtext><mfrac><mn>1</mn><mi>c</mi></mfrac><mtext> </mtext><mfrac><mrow><mi mathvariant="normal">∂</mi><mover accent="true"><mi mathvariant="bold">E</mi><mo>⃗</mo></mover></mrow><mrow><mi mathvariant="normal">∂</mi><mi>t</mi></mrow></mfrac><mo>=</mo><mfrac><mrow><mn>4</mn><mi>π</mi></mrow><mi>c</mi></mfrac><mover accent="true"><mi mathvariant="bold">j</mi><mo>⃗</mo></mover><mi mathvariant="normal">∇</mi><mo>⋅</mo><mover accent="true"><mi mathvariant="bold">E</mi><mo>⃗</mo></mover><mo>=</mo><mn>4</mn><mi>π</mi><mi>ρ</mi></mrow><annotation encoding="application/x-tex">\nabla \times \vec{\mathbf{B}} -\, \frac1c\, \frac{\partial\vec{\mathbf{E}}}{\partial t} = \frac{4\pi}{c}\vec{\mathbf{j}}    \nabla \cdot \vec{\mathbf{E}} = 4 \pi \rho</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.76666em;vertical-align:-0.08333em;"></span><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">×</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:1.0524399999999998em;vertical-align:-0.08333em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">B</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">−</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span></span><span class="base"><span class="strut" style="height:1.4173769999999999em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathdefault mtight">c</span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.16666666666666666em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:1.072377em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord mathdefault mtight">t</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight" style="margin-right:0.05556em;">∂</span><span class="mord accent mtight"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-2.714em;"><span class="pstrut" style="height:2.714em;"></span><span class="mord mtight"><span class="mord mtight"><span class="mord mathbf mtight">E</span></span></span></span><span style="top:-2.96911em;"><span class="pstrut" style="height:2.714em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay mtight" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:1.3224399999999998em;vertical-align:-0.345em;"></span><span class="mord"><span class="mopen nulldelimiter"></span><span class="mfrac"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.845108em;"><span style="top:-2.6550000000000002em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mathdefault mtight">c</span></span></span></span><span style="top:-3.23em;"><span class="pstrut" style="height:3em;"></span><span class="frac-line" style="border-bottom-width:0.04em;"></span></span><span style="top:-3.394em;"><span class="pstrut" style="height:3em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight"><span class="mord mtight">4</span><span class="mord mathdefault mtight" style="margin-right:0.03588em;">π</span></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.345em;"><span></span></span></span></span></span><span class="mclose nulldelimiter"></span></span><span class="mord accent"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.9774399999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">j</span></span></span></span><span style="top:-3.26344em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.2355em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.19444em;"><span></span></span></span></span></span><span class="mord">∇</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span><span class="mbin">⋅</span><span class="mspace" style="margin-right:0.2222222222222222em;"></span></span><span class="base"><span class="strut" style="height:0.9691099999999999em;vertical-align:0em;"></span><span class="mord accent"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.9691099999999999em;"><span style="top:-3em;"><span class="pstrut" style="height:3em;"></span><span class="mord"><span class="mord"><span class="mord mathbf">E</span></span></span></span><span style="top:-3.25511em;"><span class="pstrut" style="height:3em;"></span><span class="accent-body" style="left:-0.15216em;"><span class="overlay" style="height:0.714em;width:0.471em;"><svg width='0.471em' height='0.714em' style='width:0.471em' viewBox='0 0 471 714' preserveAspectRatio='xMinYMin'><path d='M377 20c0-5.333 1.833-10 5.5-14S391 0 397 0c4.667 0 8.667 1.667 12 53.333 2.667 6.667 9 10 19 6.667 24.667 20.333 43.667 41 57 7.333 4.667 1110.667 11 18 0 6-1 10-3 12s-6.667 5-14 9c-28.667 14.667-53.667 35.667-75 63-1.333 1.333-3.167 3.5-5.5 6.5s-4 4.833-5 5.5c-1 .667-2.5 1.333-4.5 2s-4.333 1-7 1c-4.667 0-9.167-1.833-13.5-5.5S337 184 337 178c0-12.667 15.667-32.333 47-59H213l-171-1c-8.667-6-13-12.333-13-19 0-4.667 4.333-11.333 13-20h359c-16-25.333-24-45-24-59z'/></svg></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span></span><span class="base"><span class="strut" style="height:0.8388800000000001em;vertical-align:-0.19444em;"></span><span class="mord">4</span><span class="mord mathdefault" style="margin-right:0.03588em;">π</span><span class="mord mathdefault">ρ</span></span></span></span></td><td><em>wha?</em></td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git上传的文件应用失败找不到该文件</title>
      <link href="/posts/ab7f85.html"/>
      <url>/posts/ab7f85.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note warning flat"><p>这其实全是git默认配置惹得祸,是不是感觉很坑,明明上传成功了为什么还是找不到该文件,下面详述产生的原因</p></div><h2 id="11-git-忽略文件名大小写"><a class="markdownIt-Anchor" href="#11-git-忽略文件名大小写"></a> 1.1. Git 忽略文件名大小写🙈</h2><p>在Git的配置有一个配置是配置忽略文件名大小写的，以前你上传的文件可能是<strong>File</strong>名称，但是在这期间你可能因为同一格式的问题把它在本地的名称改为了<strong>file</strong>，但是过了一段时间你再去使用的时候,你就会发现用<strong>file</strong>名称去引用 的时候会出错提示找不到这个文件,再去Git远程仓库看看文件名还是<strong>File</strong>，但是里面的文件都更新了，你说气不气🙊，不用着急，我们现在就去马上解决这个烦人的&quot;bug&quot;，毕竟这个配置对于我们这群仔细认真的攻城狮来说，这样的配置简直就是&quot;bug&quot;般的存在💀</p><h2 id="12-step-1-清空仓库"><a class="markdownIt-Anchor" href="#12-step-1-清空仓库"></a> 1.2. Step 1. 清空仓库</h2><p>先把本地仓库的文件转移出去,再进行一次put操作,这就相当于清空我们在远程仓库的文件</p><h2 id="13-step-2-配置git"><a class="markdownIt-Anchor" href="#13-step-2-配置git"></a> 1.3. Step 2. 配置git</h2><p>然后再去修改.git文件夹内的config配置文件,我们去将<code>[core]</code>下的<code>ignorecase = true</code>修改为<code>ignorecase = false</code>,这样大小写忽略就关闭了</p><p>我们也可以只在当前仓库根目录用命令进行配置:</p><p><code>git congfig --get core.ignorecase</code> 查看本地仓库git忽略大小写是打开还是关闭。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git config --get core.ignorecase</span><br><span class="line"></span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure><p>true 则会忽略文件名的大小写<br />可以将之设置为false</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git config core.ignorecase false</span><br></pre></td></tr></table></figure><p>到这配置就结束了</p><h2 id="14-step-3-重新上传"><a class="markdownIt-Anchor" href="#14-step-3-重新上传"></a> 1.4. Step 3. 重新上传</h2><p>接下来我们把文件转移回来,在进行一次push操作,远程仓库的文件都会按照严格按照你命名的名称大小规则上传覆盖了!👞</p><h2 id="15-推荐操作"><a class="markdownIt-Anchor" href="#15-推荐操作"></a> 1.5. 推荐操作</h2><p>将忽略大小写设为默认值 $ git config core.ignorecase true 以免之后合并分支等操作 因为大小写引起的冲突</p><p>如果你只能在bash操作那你就使用mv命令进行名称修改</p><p>$ git mv a A 将a更名为A</p><p>运行 $ git mv 就相当于运行如下指令<br />$ mv <a href="http://README.md">README.md</a> README<br />$ git rm <a href="http://README.md">README.md</a><br />$ git add README</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo使用Markdown出现标题错位,降级等异常情况</title>
      <link href="/posts/13477882.html"/>
      <url>/posts/13477882.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-hexo使用markdown生成目录出现标题错位降级等异常情况"><a class="markdownIt-Anchor" href="#1-hexo使用markdown生成目录出现标题错位降级等异常情况"></a> 1. hexo使用Markdown生成目录出现标题错位,降级等异常情况</h1><p>hexo的markdown文章渲染引擎不会像Typora那么实时智能，它按照严格的Markdown标准执行渲染生成HTML网页,当出现</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">#</span></span><br><span class="line"><span class="section">###</span></span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">##</span></span><br><span class="line"><span class="section">####</span></span><br></pre></td></tr></table></figure><p>出现类似这种找不到上一级母标题时,就会使得这区块的内容在目录显示错位或者整体标题降级的情况,使用时要注意!</p>]]></content>
      
      
      <categories>
          
          <category> Hexo </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hexo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Shell笔记</title>
      <link href="/posts/45ed956e.html"/>
      <url>/posts/45ed956e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-shell-简介"><a class="markdownIt-Anchor" href="#1-shell-简介"></a> 1. Shell 简介📯</h1><p>Shell 是一个用 C 语言编写的程序，它是用户使用 Linux 的桥梁。Shell 既是一种命令语言，又是一种程序设计语言。</p><p>Shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。</p><p>Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><p>菜鸟网站官方的调试在线工具<a href="https://www.runoob.com/try/showbash.php?filename=helloworld"><strong>Shell 在线工具</strong></a></p><h2 id="1-shell-脚本"><a class="markdownIt-Anchor" href="#1-shell-脚本"></a> 1. Shell 脚本</h2><p>Shell 脚本（shell script），是一种为 shell 编写的脚本程序。</p><p>业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。</p><p>由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身。</p><h2 id="2-shell-环境"><a class="markdownIt-Anchor" href="#2-shell-环境"></a> 2. Shell 环境</h2><p>Shell 编程跟 JavaScript、php 编程一样，只要有一个能编写代码的文本编辑器和一个能解释执行的脚本解释器就可以了。</p><p>Linux 的 Shell 种类众多，常见的有：</p><ul><li>Bourne Shell（/usr/bin/sh或/bin/sh）</li><li>Bourne Again Shell（/bin/bash）</li><li>C Shell（/usr/bin/csh）</li><li>K Shell（/usr/bin/ksh）</li><li>Shell for Root（/sbin/sh）</li><li>……</li></ul><p>本文关注的是 Bash，也就是 Bourne Again Shell，由于易用和免费，Bash 在日常工作中被广泛使用。同时，Bash 也是大多数Linux 系统默认的 Shell。</p><p>在一般情况下，人们并不区分 Bourne Shell 和 Bourne Again Shell，所以，像 <strong>#!/bin/sh</strong>，它同样也可以改为 <strong>#!/bin/bash</strong>。</p><p><strong><code>#!</code></strong> 告诉系统其后路径所指定的程序即是解释此脚本文件的 Shell 程序。</p><h2 id="3-第一个shell脚本"><a class="markdownIt-Anchor" href="#3-第一个shell脚本"></a> 3. 第一个shell脚本</h2><p>打开文本编辑器(可以使用 vi/vim 命令来创建文件)，新建一个文件 <a href="http://test.sh">test.sh</a>，扩展名为 sh（sh代表shell），扩展名并不影响脚本执行，见名知意就好，如果你用 php 写 shell 脚本，扩展名就用 php 好了。</p><p>输入一些代码，第一行一般是这样：</p><p><strong>实例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">echo &quot;Hello World !&quot;</span><br></pre></td></tr></table></figure><p><strong>#!</strong> 是一个约定的标记，它告诉系统这个脚本需要什么解释器来执行，即使用哪一种 Shell。</p><p>echo 命令用于向窗口输出文本。</p><h3 id="运行-shell-脚本有两种方法"><a class="markdownIt-Anchor" href="#运行-shell-脚本有两种方法"></a> 运行 Shell 脚本有两种方法：</h3><p><strong>1、作为可执行程序</strong></p><p>将上面的代码保存为 <a href="http://test.sh">test.sh</a>，并 cd 到相应目录：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">chmod +x ./test.sh  #使脚本具有执行权限</span><br><span class="line">./test.sh  #执行脚本</span><br></pre></td></tr></table></figure><p>注意，一定要写成 <strong>./test.sh</strong>，而不是 <strong><a href="http://test.sh">test.sh</a></strong>，运行其它二进制的程序也一样，直接写 <a href="http://test.sh">test.sh</a>，linux 系统会去 PATH 里寻找有没有叫 <a href="http://test.sh">test.sh</a> 的，而只有 /bin, /sbin, /usr/bin，/usr/sbin 等在 PATH 里，你的当前目录通常不在 PATH 里，所以写成 <a href="http://test.sh">test.sh</a> 是会找不到命令的，要用 ./test.sh 告诉系统说，就在当前目录找。</p><p><strong>2、作为解释器参数</strong></p><p>这种运行方式是，直接运行解释器，其参数就是 shell 脚本的文件名，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh test.sh</span><br><span class="line">/bin/php test.php</span><br></pre></td></tr></table></figure><p>这种方式运行的脚本，不需要在第一行指定解释器信息，写了也没用。</p><h2 id="4-note"><a class="markdownIt-Anchor" href="#4-note"></a> 4. Note</h2><h3 id="1-shbashcshtcshkshpdksh等shell的区别"><a class="markdownIt-Anchor" href="#1-shbashcshtcshkshpdksh等shell的区别"></a> 1. sh/bash/csh/Tcsh/ksh/pdksh等shell的区别</h3><ul><li><p>sh(全称 Bourne Shell): 是UNIX最初使用的 shell，而且在每种 UNIX 上都可以使用。<br />Bourne Shell 在 shell 编程方面相当优秀，但在处理与用户的交互方面做得不如其他几种 shell。</p></li><li><p><strong>bash（全称 Bourne Again Shell）</strong>: LinuxOS 默认的，它是 Bourne Shell 的扩展。 与 Bourne Shell 完全兼容，并且在 Bourne Shell 的基础上增加了很多特性。可以提供命令补全，命令编辑和命令历史等功能。它还包含了很多 C Shell 和 Korn Shell 中的优点，有灵活和强大的编辑接口，同时又很友好的用户界面。</p></li><li><p><strong>csh(全称 C Shell)</strong>: 是一种比 Bourne Shell更适合的变种 Shell，它的语法与 C 语言很相似。</p></li><li><p><strong>Tcsh</strong>: 是 Linux 提供的 C Shell 的一个扩展版本。<br />Tcsh 包括命令行编辑，可编程单词补全，拼写校正，历史命令替换，作业控制和类似 C 语言的语法，他不仅和 Bash Shell 提示符兼容，而且还提供比 Bash Shell 更多的提示符参数。</p></li><li><p><strong>ksh (全称 Korn Shell)</strong>: 集合了 C Shell 和 Bourne Shell 的优点并且和 Bourne Shell 完全兼容。</p></li><li><p><strong>pdksh</strong>: 是 Linux 系统提供的 ksh 的扩展。<br />pdksh 支持人物控制，可以在命令行上挂起，后台执行，唤醒或终止程序。</p></li></ul><h3 id="2-如果不好理解的话shell-个人感觉可以对应成-win-中的-bat通过代码来实现一些自动定时任务自动备份或者执行的任务"><a class="markdownIt-Anchor" href="#2-如果不好理解的话shell-个人感觉可以对应成-win-中的-bat通过代码来实现一些自动定时任务自动备份或者执行的任务"></a> 2. 如果不好理解的话，Shell 个人感觉可以对应成 win 中的 bat，通过代码来实现一些自动定时任务，自动备份或者执行的任务。</h3><ul><li><strong>chmod +x file</strong> 加上执行权限，否则会提示无执行权限。</li><li>注意执行脚本时候或者全目录，或者 <strong>./file.sh</strong> ，如果不加的话，linux 默认会从PATH 里去找该 <a href="http://file.sh">file.sh</a>。</li><li>看了这篇教程，发现脚本后缀名可以任意修改，仍然可以正常运行。</li><li>语法类PHP，方便学习。</li></ul><h3 id="3-首先什么是脚本语言"><a class="markdownIt-Anchor" href="#3-首先什么是脚本语言"></a> 3.  首先，什么是脚本语言？</h3><p>脚本语言是像剧本一样教计算机办某个事情的语言。</p><p>比如你想让计算机执行复制某个文件的操作，如：<strong>cp ~/Desktop/*.txt ~/text</strong></p><p>你可以在文本编辑器写入上边的代码并且保存此文件，然后你通过执行这个文本文件来执行上面的代码，并不需要重复手动输入上边的代码。</p><p>下面这句话是我在网上看到的：</p><blockquote><p>所以脚本其实就是短小的、用来让计算机自动化完成一系列工作的程序，这类程序可以用文本编辑器修改，不需要编译，通常是解释运行的。</p></blockquote><h3 id="4-ubuntulinux下-source-sh-bash-执行脚本的区别是什么"><a class="markdownIt-Anchor" href="#4-ubuntulinux下-source-sh-bash-执行脚本的区别是什么"></a> 4. ubuntu（linux）下 source、sh、bash、./ 执行脚本的区别是什么？</h3><p><strong>1. source命令用法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source FileName</span><br></pre></td></tr></table></figure><p>作用:在当前 bash 环境下读取并执行 FileName 中的命令。该 filename 文件可以无 “执行权限”。</p><p>注：该命令通常用命令 <strong>.</strong> 来替代。</p><p><strong>2. sh、bash的命令用法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sh FileName</span><br><span class="line">或</span><br><span class="line">bash FileName</span><br></pre></td></tr></table></figure><p>作用:打开一个子 shell 来读取并执行 FileName 中命令。该 filename 文件可以无 “执行权限”。</p><p>注：运行一个shell脚本时会启动另一个命令解释器。</p><p><strong>3、./的命令用法：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./FileName</span><br></pre></td></tr></table></figure><p>作用: 打开一个子 shell 来读取并执行 FileName 中命令，该 filename 文件需要 “执行权限”。</p><p>注：运行一个 shell 脚本时会启动另一个命令解释器。</p><h3 id="5-shell-和-shell-脚本的概念"><a class="markdownIt-Anchor" href="#5-shell-和-shell-脚本的概念"></a> 5. shell 和 shell 脚本的概念</h3><p>shell 是指一种应用程序，这个应用程序提供了一个界面，用户通过这个界面访问操作系统内核的服务。Ken Thompson 的 sh 是第一种 Unix Shell，Windows Explorer 是一个典型的图形界面 Shell。</p><p>shell 脚本（shell script），是一种为 shell 编写的脚本程序。业界所说的 shell 通常都是指 shell 脚本，但读者朋友要知道，shell 和 shell script 是两个不同的概念。由于习惯的原因，简洁起见，本文出现的 “shell编程” 都是指 shell 脚本编程，不是指开发 shell 自身（如Windows Explorer扩展开发）。</p><h1 id="2-shell-变量"><a class="markdownIt-Anchor" href="#2-shell-变量"></a> 2. Shell 变量</h1><p>定义变量时，变量名不加美元符号（<code>$</code>，PHP语言中变量需要），如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;elec-creator.com&quot;</span><br></pre></td></tr></table></figure><p><strong>注意</strong>，**变量名和等号之间不能有空格，这可能和你熟悉的所有编程语言都不一样。**同时，变量名的命名须遵循如下规则：</p><ul><li>命名只能使用英文字母，数字和下划线，首个字符不能以数字开头。</li><li>中间不能有空格，可以使用下划线（_）。</li><li>不能使用标点符号。</li><li><strong>不能使用bash里的关键字（可用help命令查看保留关键字）。</strong></li></ul><p>有效的 Shell 变量名示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">RUNOOB</span><br><span class="line">LD_LIBRARY_PATH</span><br><span class="line">_var</span><br><span class="line">var2</span><br></pre></td></tr></table></figure><p>无效的变量命名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">?var=123</span><br><span class="line">user*name=elec-creator</span><br></pre></td></tr></table></figure><p>除了显式地直接赋值，还可以用语句给变量赋值，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for file in `ls /etc`</span><br><span class="line">或</span><br><span class="line">for file in $(ls /etc)</span><br></pre></td></tr></table></figure><p>以上语句将 /etc 下目录的文件名循环出来。</p><h2 id="变量"><a class="markdownIt-Anchor" href="#变量"></a> 变量</h2><h3 id="1-使用变量"><a class="markdownIt-Anchor" href="#1-使用变量"></a> 1. 使用变量</h3><p>使用一个定义过的变量，只要在变量名前面加美元符号即可，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;qinjx&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">echo $&#123;your_name&#125;</span><br></pre></td></tr></table></figure><p>变量名外面的花括号是可选的，加不加都行，加花括号是为了帮助解释器识别变量的边界，比如下面这种情况：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for skill in Ada Coffe Action Java; do</span><br><span class="line">    echo &quot;I am good at $&#123;skill&#125;Script&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>如果不给skill变量加花括号，写成echo “I am good at <code>$</code>skillScript”，解释器就会把<code>$</code>skillScript当成一个变量（其值为空），代码执行结果就不是我们期望的样子了。</p><p><strong>推荐给所有变量加上花括号，这是个好的编程习惯。</strong></p><p>已定义的变量，可以被重新定义，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;tom&quot;</span><br><span class="line">echo $your_name</span><br><span class="line">your_name=&quot;alibaba&quot;</span><br><span class="line">echo $your_name</span><br></pre></td></tr></table></figure><p>这样写是合法的，<strong>但注意，第二次赋值的时候不能写<code>$</code>your_name=“alibaba”</strong>，使用变量的时候才加美元符（<code>$</code>）。</p><h3 id="2-只读变量"><a class="markdownIt-Anchor" href="#2-只读变量"></a> 2. 只读变量</h3><p>使用 readonly 命令可以将变量定义为只读变量，只读变量的值不能被改变。</p><p>下面的例子尝试更改只读变量，结果报错：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">myUrl=&quot;http://www.google.com&quot;</span><br><span class="line">readonly myUrl</span><br><span class="line">myUrl=&quot;http://www.elec-creator.com&quot;</span><br></pre></td></tr></table></figure><p>运行脚本，结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">/bin/sh: NAME: This variable is read only.</span><br></pre></td></tr></table></figure><h3 id="3-删除变量"><a class="markdownIt-Anchor" href="#3-删除变量"></a> 3. 删除变量</h3><p>使用 unset 命令可以删除变量。语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">unset variable_name</span><br></pre></td></tr></table></figure><p>变量被删除后不能再次使用。<strong>unset 命令不能删除只读变量。</strong></p><p><strong>实例</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">myUrl=&quot;https://www.elec-creator.com&quot;</span><br><span class="line">unset myUrl</span><br><span class="line">echo $myUrl</span><br></pre></td></tr></table></figure><p>以上实例执行将没有任何输出。</p><h3 id="4-变量类型"><a class="markdownIt-Anchor" href="#4-变量类型"></a> 4. 变量类型</h3><p>运行shell时，会同时存在三种变量：</p><ul><li><strong>1) 局部变量</strong> 局部变量在脚本或命令中定义，仅在当前shell实例中有效，其他shell启动的程序不能访问局部变量。</li><li><strong>2) 环境变量</strong> 所有的程序，包括shell启动的程序，都能访问环境变量，有些程序需要环境变量来保证其正常运行。必要的时候shell脚本也可以定义环境变量。</li><li><strong>3) shell变量</strong> shell变量是由shell程序设置的特殊变量。shell变量中有一部分是环境变量，有一部分是局部变量，这些变量保证了shell的正常运行</li></ul><h2 id="shell-字符串"><a class="markdownIt-Anchor" href="#shell-字符串"></a> Shell 字符串</h2><p>字符串是shell编程中最常用最有用的数据类型（除了数字和字符串，也没啥其它类型好用了），字符串可以用单引号，也可以用双引号，也可以不用引号。单双引号的区别跟PHP类似。</p><h3 id="单双引号的区别"><a class="markdownIt-Anchor" href="#单双引号的区别"></a> 单双引号的区别</h3><p>1、变量。双引号解释变量，单引百号不解释变量；双引号里插入单引号，其中单引号里如果有变量的话，变量解度释；</p><p>2、字符。双引号解释转义字符，单引号不解释转义字符，但是解释<code>'\</code>和<code>\</code>；</p><p>3、效率。能使单引号知字符尽量使用单引号，单引号的效率比双引号要高（因为双引号要先遍历一遍，判断里面有没有变量，然后再进行操作，道而单引号则不需要判断）。</p><p><strong>扩展资料:</strong></p><p>一般情况下两者是通用的。但双引号内部变量会解析，回而单引号则不解析。</p><p>PHP允许我们在双引号串中直接包含字串变量。</p><p>而单引号串中的内容总被认为是普通字符，因此答单引号中的内容不会被转义效率更高。</p><p>比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">str = <span class="string">&#x27;hello world&#x27;</span>;</span></span><br><span class="line"></span><br><span class="line">echo &quot;str is $str&quot;; //运行权结果: str is hello world</span><br><span class="line"></span><br><span class="line">echo &#x27;str is $str&#x27;; //运行结果: str is $str</span><br></pre></td></tr></table></figure><h3 id="单引号"><a class="markdownIt-Anchor" href="#单引号"></a> 单引号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">str=&#x27;this is a string&#x27;</span><br></pre></td></tr></table></figure><p>单引号字符串的限制：</p><ul><li>单引号里的任何字符都会原样输出，单引号字符串中的变量是无效的；</li><li>单引号字串中不能出现单独一个的单引号（对单引号使用转义符后也不行），但可成对出现，作为字符串拼接使用。</li></ul><h3 id="双引号"><a class="markdownIt-Anchor" href="#双引号"></a> 双引号</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">your_name=&#x27;elec-creator&#x27;</span><br><span class="line">str=&quot;Hello, I know you are \&quot;$your_name\&quot;! \n&quot;</span><br><span class="line">echo -e $str</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Hello, I know you are &quot;elec-creator&quot;! </span><br></pre></td></tr></table></figure><p>双引号的优点：</p><ul><li><strong>双引号里可以有变量</strong></li><li><strong>双引号里可以出现转义字符</strong></li></ul><h3 id="拼接字符串"><a class="markdownIt-Anchor" href="#拼接字符串"></a> 拼接字符串</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">your_name=&quot;elec-creator&quot;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用双引号拼接</span></span><br><span class="line">greeting=&quot;hello, &quot;$your_name&quot; !&quot;</span><br><span class="line">greeting_1=&quot;hello, $&#123;your_name&#125; !&quot;</span><br><span class="line">echo $greeting  $greeting_1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用单引号拼接</span></span><br><span class="line">greeting_2=&#x27;hello, &#x27;$your_name&#x27; !&#x27;</span><br><span class="line">greeting_3=&#x27;hello, $&#123;your_name&#125; !&#x27;</span><br><span class="line">echo $greeting_2  $greeting_3</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">hello, elec-creator ! hello, elec-creator !</span><br><span class="line">hello, elec-creator ! hello, $&#123;your_name&#125; !</span><br></pre></td></tr></table></figure><h3 id="获取字符串长度"><a class="markdownIt-Anchor" href="#获取字符串长度"></a> 获取字符串长度</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;abcd&quot;</span><br><span class="line">echo $&#123;#string&#125; #输出 4</span><br></pre></td></tr></table></figure><h3 id="提取子字符串"><a class="markdownIt-Anchor" href="#提取子字符串"></a> 提取子字符串</h3><p>以下实例从字符串第 <strong>2</strong> 个字符开始截取 <strong>4</strong> 个字符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;elec-creator is a great site&quot;</span><br><span class="line">echo $&#123;string:1:4&#125; # 输出 lec-</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：第一个字符的索引值为 <strong>0</strong>。</p><h3 id="查找子字符串"><a class="markdownIt-Anchor" href="#查找子字符串"></a> 查找子字符串</h3><p>查找字符 <strong>i</strong> 或 <strong>o</strong> 的位置(哪个字母先出现就计算哪个)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;runoob is a great site&quot;</span><br><span class="line">echo `expr index &quot;$string&quot; io`  # 输出 4</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 以上脚本中 <strong>`</strong> 是反引号，而不是单引号 <strong>'</strong>，不要看错了哦。</p><h2 id="shell-数组"><a class="markdownIt-Anchor" href="#shell-数组"></a> Shell 数组</h2><p><strong>bash支持一维数组（不支持多维数组），并且没有限定数组的大小。</strong></p><p>类似于 C 语言，数组元素的下标由 0 开始编号。获取数组中的元素要利用下标，下标可以是整数或算术表达式，其值应大于或等于 0。</p><h3 id="定义数组"><a class="markdownIt-Anchor" href="#定义数组"></a> 定义数组</h3><p>在 Shell 中，用括号来表示数组，<strong>数组元素用&quot;空格&quot;符号分割开</strong>。定义数组的一般形式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">数组名=(值1 值2 ... 值n)</span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value0 value1 value2 value3)</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array_name=(</span><br><span class="line">value0</span><br><span class="line">value1</span><br><span class="line">value2</span><br><span class="line">value3</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>还可以单独定义数组的各个分量：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[n]=valuen</span><br></pre></td></tr></table></figure><p>可以不使用连续的下标，而且下标的范围没有限制。</p><h3 id="读取数组"><a class="markdownIt-Anchor" href="#读取数组"></a> 读取数组</h3><p>读取数组元素值的一般格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;数组名[下标]&#125;</span></span><br></pre></td></tr></table></figure><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">valuen=$&#123;array_name[n]&#125;</span><br></pre></td></tr></table></figure><p>使用 <strong>@</strong> 符号可以获取数组中的所有元素，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;array_name[@]&#125;</span><br></pre></td></tr></table></figure><h3 id="获取数组的长度"><a class="markdownIt-Anchor" href="#获取数组的长度"></a> 获取数组的长度</h3><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 取得数组元素的个数</span></span><br><span class="line">length=$&#123;#array_name[@]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者</span></span><br><span class="line">length=$&#123;#array_name[*]&#125;</span><br><span class="line"><span class="meta">#</span><span class="bash"> 取得数组单个元素的长度</span></span><br><span class="line">lengthn=$&#123;#array_name[n]&#125;</span><br></pre></td></tr></table></figure><h2 id="shell-注释"><a class="markdownIt-Anchor" href="#shell-注释"></a> Shell 注释</h2><p>以 <strong>#</strong> 开头的行就是注释，会被解释器忽略。</p><p>通过每一行加一个 <strong>#</strong> 号设置多行注释，像这样：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这是一个注释</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author：</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> site：www.elec-creator.com</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> slogan：</span></span><br><span class="line"><span class="meta">#</span><span class="bash">--------------------------------------------</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#### 用户配置区 开始 #####</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">#</span></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 这里可以添加脚本描述信息</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"></span></span><br><span class="line"><span class="bash"><span class="comment">##### 用户配置区 结束  #####</span></span></span><br></pre></td></tr></table></figure><p>如果在开发过程中，遇到大段的代码需要临时注释起来，过一会儿又取消注释，怎么办呢？</p><p><strong>每一行加个#符号太费力了，可以把这一段要注释的代码用一对花括号括起来，定义成一个函数，没有地方调用这个函数，这块代码就不会执行，达到了和注释一样的效果。</strong></p><h3 id="多行注释"><a class="markdownIt-Anchor" href="#多行注释"></a> 多行注释</h3><p>多行注释还可以使用以下格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;EOF</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>EOF 也可以使用其他符号:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">:&lt;&lt;&#x27;</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">&#x27;</span><br><span class="line"></span><br><span class="line">:&lt;&lt;!</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">注释内容...</span><br><span class="line">!</span><br></pre></td></tr></table></figure><h2 id="note"><a class="markdownIt-Anchor" href="#note"></a> Note</h2><h3 id="1-linux-的字符串截取很有用-有八种方法"><a class="markdownIt-Anchor" href="#1-linux-的字符串截取很有用-有八种方法"></a> 1. Linux 的字符串截取很有用。有八种方法。</h3><p>假设有变量 var=http://www.aaa.com/123.htm</p><p><strong>1. # 号截取，删除左边字符，保留右边字符。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var#*//&#125;</span><br></pre></td></tr></table></figure><p>其中 var 是变量名，# 号是运算符，*// 表示从左边开始删除第一个 // 号及左边的所有字符</p><p>即删除 http://</p><p>结果是 ：<a href="http://www.aaa.com/123.htm">www.aaa.com/123.htm</a></p><p><strong>2. ## 号截取，删除左边字符，保留右边字符。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var##*/&#125;</span><br></pre></td></tr></table></figure><p>##*/ 表示从左边开始删除最后（最右边）一个 / 号及左边的所有字符</p><p>即删除 <a href="http://www.aaa.com/">http://www.aaa.com/</a></p><p>结果是 123.htm</p><p><strong>3. %号截取，删除右边字符，保留左边字符</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var%/*&#125;</span><br></pre></td></tr></table></figure><p>%/* 表示从右边开始，删除第一个 / 号及右边的字符</p><p>结果是：<a href="http://www.aaa.com">http://www.aaa.com</a></p><p><strong>4. %% 号截取，删除右边字符，保留左边字符</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var%%/*&#125;</span><br></pre></td></tr></table></figure><p>%%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符</p><p>结果是：http:</p><p><strong>5. 从左边第几个字符开始，及字符的个数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var:0:5&#125;</span><br></pre></td></tr></table></figure><p>其中的 0 表示左边第一个字符开始，5 表示字符的总个数。</p><p>结果是：http:</p><p><strong>6. 从左边第几个字符开始，一直到结束。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var:7&#125;</span><br></pre></td></tr></table></figure><p>其中的 7 表示左边第8个字符开始，一直到结束。</p><p>结果是 ：<a href="http://www.aaa.com/123.htm">www.aaa.com/123.htm</a></p><p><strong>7. 从右边第几个字符开始，及字符的个数</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo $&#123;var:0-7:3&#125;</span><br></pre></td></tr></table></figure><p>其中的 0-7 表示右边算起第七个字符开始，3 表示字符的个数。</p><p>结果是：123</p><p><strong>8. 从右边第几个字符开始，一直到结束。</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shellecho $&#123;var:0-7&#125;</span><br></pre></td></tr></table></figure><p>表示从右边第七个字符开始，一直到结束。</p><p>结果是：123.htm</p><p><strong>注：</strong>（左边的第一个字符是用 0 表示，右边的第一个字符用 0-1 表示）</p><h3 id="2-差别"><a class="markdownIt-Anchor" href="#2-差别"></a> 2. #  ##  %  %%差别</h3><p>描述的有点儿不容易懂，看了好久才勉强明白 <strong>#</strong> <strong>##</strong> <strong>%</strong> <strong>%%</strong>。</p><p><strong>#</strong>、<strong>##</strong> 表示从左边开始删除。一个 <strong>#</strong> 表示从左边删除到第一个指定的字符；两个 <strong>#</strong> 表示从左边删除到最后一个指定的字符。</p><p><strong>%</strong>、<strong>%%</strong> 表示从右边开始删除。一个 <strong>%</strong> 表示从右边删除到第一个指定的字符；两个 <strong>%</strong> 表示从左边删除到最后一个指定的字符。</p><p>删除包括了指定的字符本身</p><h3 id="3"><a class="markdownIt-Anchor" href="#3"></a> 3.</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash">author:amau</span></span><br><span class="line"></span><br><span class="line">var=&quot;http://www.runoob.com/linux/linux-shell-variable.html&quot;</span><br><span class="line"></span><br><span class="line">s1=$&#123;var%%t*&#125;</span><br><span class="line">s2=$&#123;var%t*&#125;</span><br><span class="line">s3=$&#123;var%%.*&#125;</span><br><span class="line">s4=$&#123;var#*/&#125;</span><br><span class="line">s5=$&#123;var##*/&#125;</span><br></pre></td></tr></table></figure><p>echo “关于字符串的截取%，#的使用方法” echo “原字符串为：”<code>$</code>{var} echo “%%t<em>的效果：&quot;<code>$</code>{s1} echo &quot;%t</em>的效果：”<code>$</code>{s2} echo “%%.<em>的效果：&quot;<code>$</code>{s3} echo &quot;#</em>/的效果：”<code>$</code>{s4} echo “##*/的效果：”${s5}</p><p>运行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">关于字符串的截取%，#的使用方法</span><br><span class="line">原字符串为：http://www.runoob.com/linux/linux-shell-variable.html</span><br><span class="line"><span class="meta">%</span><span class="bash">%t*的效果：h</span></span><br><span class="line"><span class="meta">%</span><span class="bash">t*的效果：http://www.runoob.com/linux/linux-shell-variable.h</span></span><br><span class="line"><span class="meta">%</span><span class="bash">%.*的效果：http://www</span></span><br><span class="line"><span class="meta">#</span><span class="bash">*/的效果：/www.runoob.com/linux/linux-shell-variable.html</span></span><br><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#*/的效果：linux-shell-variable.html</span></span></span><br></pre></td></tr></table></figure><h3 id="4-计算字符长度也可是使用-length"><a class="markdownIt-Anchor" href="#4-计算字符长度也可是使用-length"></a> 4. 计算字符长度也可是使用 <strong>length</strong>:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">string=&quot;hello,everyone my name is xiaoming&quot;</span><br><span class="line">expr length &quot;$string&quot;</span><br></pre></td></tr></table></figure><p>输出:34</p><p><strong>注意</strong>：string字符串里边有空格,所以需要添加双引号</p><p>使用 <strong>expr</strong> 命令时，表达式中的运算符左右必须包含空格，如果不包含空格，将会输出表达式本身:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr 5+6    // 直接输出 5+6</span><br><span class="line">expr 5 + 6       // 输出 11</span><br></pre></td></tr></table></figure><p>对于某些运算符，还需要我们使用符号&quot;&quot;进行转义，否则就会提示语法错误。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expr 5 * 6       // 输出错误</span><br><span class="line">expr 5 \* 6      // 输出30</span><br></pre></td></tr></table></figure><h3 id="5-read命令用于获取键盘输入信息"><a class="markdownIt-Anchor" href="#5-read命令用于获取键盘输入信息"></a> 5. <strong>read命令用于获取键盘输入信息</strong></h3><p>它的语法形式一般是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">read [-options] [variable...]</span><br></pre></td></tr></table></figure><p>以下实例读取键盘输入的内容并将其赋值给shell变量，为：-p 参数由于设置提示信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;input a val:&quot; a    #获取键盘输入的 a 变量数字</span><br><span class="line">read -p &quot;input b val:&quot; b    #获取键盘输入的 b 变量数字</span><br><span class="line">r=$[a+b]                    #计算a+b的结果 赋值给r  不能有空格</span><br><span class="line">echo &quot;result = $&#123;r&#125;&quot;        #输出显示结果 r</span><br></pre></td></tr></table></figure><p>测试结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">input a val:1</span><br><span class="line">input b val:2</span><br><span class="line">result = 3</span><br></pre></td></tr></table></figure><h1 id="3-shell-传递参数"><a class="markdownIt-Anchor" href="#3-shell-传递参数"></a> 3. Shell 传递参数</h1><p>我们可以在执行 Shell 脚本时，向脚本传递参数，脚本内获取参数的格式为：<strong>$n</strong>。<strong>n</strong> 代表一个数字，1 为执行脚本的第一个参数，2 为执行脚本的第二个参数，以此类推……</p><p><strong>实例:</strong></p><p>以下实例我们向脚本传递三个参数，并分别输出，其中 <strong>$0</strong> 为执行的文件名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;执行的文件名：$0&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line">echo &quot;第二个参数为：$2&quot;;</span><br><span class="line">echo &quot;第三个参数为：$3&quot;;</span><br></pre></td></tr></table></figure><p>为脚本设置可执行权限，并执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh 1 2 3</span></span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">执行的文件名：./test.sh</span><br><span class="line">第一个参数为：1</span><br><span class="line">第二个参数为：2</span><br><span class="line">第三个参数为：3</span><br></pre></td></tr></table></figure><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th style="text-align:left">参数处理</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>$#</code></td><td style="text-align:left">传递到脚本的参数个数</td></tr><tr><td style="text-align:left"><code>$*</code></td><td style="text-align:left">以一个单字符串显示所有向脚本传递的参数。 如&quot;<code>$*</code>“用「”」括起来的情况、以&quot;<code>$1 $2 … $n</code>&quot;的形式输出所有参数。</td></tr><tr><td style="text-align:left"><code>$$</code></td><td style="text-align:left">脚本运行的当前进程ID号</td></tr><tr><td style="text-align:left"><code>$!</code></td><td style="text-align:left">后台运行的最后一个进程的ID号</td></tr><tr><td style="text-align:left"><code>$@</code></td><td style="text-align:left">与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。 如&quot;<code>$@</code>“用「”」括起来的情况、以<code>&quot;$1&quot; &quot;$2&quot; … &quot;$n&quot;</code> 的形式输出所有参数。</td></tr><tr><td style="text-align:left"><code>$-</code></td><td style="text-align:left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td style="text-align:left"><code>$?</code></td><td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">echo &quot;Shell 传递参数实例！&quot;;</span><br><span class="line">echo &quot;第一个参数为：$1&quot;;</span><br><span class="line"></span><br><span class="line">echo &quot;参数个数为：$#&quot;;</span><br><span class="line">echo &quot;传递的参数作为一个字符串显示：$*&quot;;</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh 1 2 3</span></span><br><span class="line">Shell 传递参数实例！</span><br><span class="line">第一个参数为：1</span><br><span class="line">参数个数为：3</span><br><span class="line">传递的参数作为一个字符串显示：1 2 3</span><br></pre></td></tr></table></figure><p><code>$*</code> 与 <code>$@</code> 区别：</p><ul><li>相同点：都是引用所有参数。</li><li>不同点：只有在双引号中体现出来。假设在脚本运行时写了三个参数 1、2、3，，则 &quot; * &quot; 等价于 “1 2 3”（传递了一个参数），而 “@” 等价于 “1” “2” “3”（传递了三个参数）。</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">echo &quot;-- \$* 演示 ---&quot;</span><br><span class="line">for i in &quot;$*&quot;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;-- \$@ 演示 ---&quot;</span><br><span class="line">for i in &quot;$@&quot;; do</span><br><span class="line">    echo $i</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh 1 2 3</span></span><br><span class="line">-- $* 演示 ---</span><br><span class="line">1 2 3</span><br><span class="line">-- $@ 演示 ---</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h2 id="note-2"><a class="markdownIt-Anchor" href="#note-2"></a> Note</h2><h3 id="1"><a class="markdownIt-Anchor" href="#1"></a> 1.</h3><p>在为shell脚本传递的参数中<strong>如果包含空格，应该使用单引号或者双引号将该参数括起来，以便于脚本将这个参数作为整体来接收</strong>。</p><p>在有参数时，可以使用对参数进行校验的方式处理以减少错误发生：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ -n &quot;$1&quot; ]; then</span><br><span class="line">    echo &quot;包含第一个参数&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;没有包含第一参数&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：中括号 <strong>[]</strong> 与其中间的代码应该有空格隔开</p><h3 id="2shell-里面的中括号包括单中括号与双中括号可用于一些条件的测试"><a class="markdownIt-Anchor" href="#2shell-里面的中括号包括单中括号与双中括号可用于一些条件的测试"></a> 2.Shell 里面的中括号（包括单中括号与双中括号）可用于一些条件的测试</h3><ul><li>算术比较, 比如一个变量是否为0, <code>[ $var -eq 0 ]</code>。</li><li>文件属性测试，比如一个文件是否存在，<code>[ -e $var ]</code>, 是否是目录，<code>[ -d $var ]</code>。</li><li>字符串比较, 比如两个字符串是否相同， <code>[[ $var1 = $var2 ]]</code>。</li></ul><blockquote><p>[] 常常可以使用 test 命令来代替，具体可参看：<a href="https://www.runoob.com/w3cnote/shell-summary-brackets.html">Shell 中的中括号用法总结</a>。</p></blockquote><h1 id="4-shell-数组"><a class="markdownIt-Anchor" href="#4-shell-数组"></a> 4. Shell 数组</h1><p>数组中可以存放多个值。<strong>Bash Shell 只支持一维数组（不支持多维数组）</strong>，初始化时不需要定义数组大小（与 PHP 类似）。</p><p>与大部分编程语言类似，数组元素的下标由0开始。</p><p>Shell 数组用括号来表示，元素用&quot;空格&quot;符号分割开，语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">array_name=(value1 ... valuen)</span><br></pre></td></tr></table></figure><p><strong>实例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:shell</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">my_array=(A B &quot;C&quot; D)</span><br></pre></td></tr></table></figure><p>我们也可以使用下标来定义数组:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">array_name[0]=value0</span><br><span class="line">array_name[1]=value1</span><br><span class="line">array_name[2]=value2</span><br></pre></td></tr></table></figure><h2 id="读取数组-2"><a class="markdownIt-Anchor" href="#读取数组-2"></a> 读取数组</h2><p>读取数组元素值的一般格式是：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">&#123;array_name[index]&#125;</span></span><br></pre></td></tr></table></figure><p><strong>实例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">my_array=(A B &quot;C&quot; D)</span><br><span class="line"></span><br><span class="line">echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;</span><br><span class="line">echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;</span><br><span class="line">echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;</span><br><span class="line">echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">第一个元素为: A</span><br><span class="line">第二个元素为: B</span><br><span class="line">第三个元素为: C</span><br><span class="line">第四个元素为: D</span><br></pre></td></tr></table></figure><h2 id="获取数组中的所有元素"><a class="markdownIt-Anchor" href="#获取数组中的所有元素"></a> 获取数组中的所有元素</h2><p>使用@ 或 * 可以获取数组中的所有元素，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组的元素为: $&#123;my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">数组的元素为: A B C D</span><br><span class="line">数组的元素为: A B C D</span><br></pre></td></tr></table></figure><h2 id="获取数组的长度-2"><a class="markdownIt-Anchor" href="#获取数组的长度-2"></a> 获取数组的长度</h2><p>获取数组长度的方法与获取字符串长度的方法相同，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">my_array[0]=A</span><br><span class="line">my_array[1]=B</span><br><span class="line">my_array[2]=C</span><br><span class="line">my_array[3]=D</span><br><span class="line"></span><br><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[*]&#125;&quot;</span><br><span class="line">echo &quot;数组元素个数为: $&#123;#my_array[@]&#125;&quot;</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test.sh</span></span><br><span class="line">数组元素个数为: 4</span><br><span class="line">数组元素个数为: 4</span><br></pre></td></tr></table></figure><h2 id="note-3"><a class="markdownIt-Anchor" href="#note-3"></a> Note</h2><h3 id="1-数组的值也可以写入变量"><a class="markdownIt-Anchor" href="#1-数组的值也可以写入变量"></a> 1. 数组的值也可以写入变量。</h3><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">A=1</span><br><span class="line">my_array=($A B C D)</span><br><span class="line">echo &quot;第一个元素为: $&#123;my_array[0]&#125;&quot;</span><br><span class="line">echo &quot;第二个元素为: $&#123;my_array[1]&#125;&quot;</span><br><span class="line">echo &quot;第三个元素为: $&#123;my_array[2]&#125;&quot;</span><br><span class="line">echo &quot;第四个元素为: $&#123;my_array[3]&#125;&quot;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">第一个元素为: 1第二个元素为: B第三个元素为: c第四个元素为: D</span><br></pre></td></tr></table></figure><h3 id="2-根据数组元素索引获取该数组元素值时数组下标可为变量"><a class="markdownIt-Anchor" href="#2-根据数组元素索引获取该数组元素值时数组下标可为变量"></a> 2. 根据数组元素索引获取该数组元素值时，数组下标可为变量。</h3><p>例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arr=(a b c d)</span><br><span class="line">i=2</span><br><span class="line">echo $&#123;arr[i]&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><p>c</p><h3 id="3-看数组的时候觉得遍历数组用的比较多所以自己试着写了写遍历同时试了一下在shell脚本中的变量自增几个写法在就新手学习的时候注意一下-和-之间要有空格没有空格运行会报错新手可能不太注意这一点我开始就没注意到~~~~"><a class="markdownIt-Anchor" href="#3-看数组的时候觉得遍历数组用的比较多所以自己试着写了写遍历同时试了一下在shell脚本中的变量自增几个写法在就新手学习的时候注意一下-和-之间要有空格没有空格运行会报错新手可能不太注意这一点我开始就没注意到~~~~"></a> 3. 看数组的时候，觉得遍历数组用的比较多，所以自己试着写了写遍历，同时试了一下在SHELL脚本中的变量自增几个写法，在就新手学习的时候注意一下 [ 和 <code>$</code> 之间要有空格，没有空格运行会报错，新手可能不太注意这一点，我开始就没注意到～～～～</h3><p>示例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">my_arry=(a b &quot;c&quot;,&quot;d&quot; abc)</span><br><span class="line">echo &quot;-------FOR循环遍历输出数组--------&quot;</span><br><span class="line">for i in $&#123;my_arry[@]&#125;;</span><br><span class="line">do</span><br><span class="line">  echo $i</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;-------::::WHILE循环输出 使用 let i++ 自增:::::---------&quot;</span><br><span class="line">j=0</span><br><span class="line">while [ $j -lt $&#123;#my_arry[@]&#125; ]</span><br><span class="line">do</span><br><span class="line">  echo $&#123;my_arry[$j]&#125;</span><br><span class="line">  let j++</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;--------:::WHILE循环输出 使用 let  &quot;n++ &quot;自增: 多了双引号，其实不用也可以:::---------&quot;</span><br><span class="line">n=0</span><br><span class="line">while [ $n -lt $&#123;#my_arry[@]&#125; ]</span><br><span class="line">do</span><br><span class="line">  echo $&#123;my_arry[$n]&#125;</span><br><span class="line">  let &quot;n++&quot;</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;---------::::WHILE循环输出 使用 let m+=1 自增,这种写法其他编程中也常用::::----------&quot;</span><br><span class="line">m=0</span><br><span class="line">while [ $m -lt $&#123;#my_arry[@]&#125; ]</span><br><span class="line">do</span><br><span class="line">  echo $&#123;my_arry[$m]&#125;</span><br><span class="line">  let m+=1</span><br><span class="line">done</span><br><span class="line"></span><br><span class="line">echo &quot;-------::WHILE循环输出 使用 a=$[$a+1] 自增,个人觉得这种写法比较麻烦::::----------&quot;</span><br><span class="line">a=0</span><br><span class="line">while [ $a -lt $&#123;#my_arry[@]&#125; ]</span><br><span class="line">do</span><br><span class="line"> echo $&#123;my_arry[$a]&#125;</span><br><span class="line"> a=$[$a+1]</span><br><span class="line">done</span><br></pre></td></tr></table></figure><h3 id="4-bourne-shell原生kernel下下不支持数组只能通过模拟来实现类似数组功能"><a class="markdownIt-Anchor" href="#4-bourne-shell原生kernel下下不支持数组只能通过模拟来实现类似数组功能"></a> 4. Bourne shell（原生kernel下）下不支持数组，只能通过模拟来实现类似数组功能。</h3><p>实例 1</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意不是/bin/bash</span></span><br><span class="line">echo &quot;##############使用eval函数###############&quot;</span><br><span class="line">echo &quot;使用参考:&quot;</span><br><span class="line">echo &quot;http://www.runoob.com/linux/linux-comm-eval.html&quot;</span><br><span class="line">eval a1=bili</span><br><span class="line">eval a2=nico</span><br><span class="line">eval a3=yama</span><br><span class="line"></span><br><span class="line">for i in 1 2 3 ; do</span><br><span class="line">  eval echo &quot;\$a$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#############使用eval函数###############</span></span></span><br><span class="line">使用参考:</span><br><span class="line">http://www.runoob.com/linux/linux-comm-eval.html</span><br><span class="line">bili</span><br><span class="line">nico</span><br><span class="line">yama</span><br></pre></td></tr></table></figure><p>实例 2</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line"><span class="meta">#</span><span class="bash">注意不是/bin/bash</span></span><br><span class="line">echo &quot;##########################################&quot;</span><br><span class="line">echo &quot;指令参考:&quot;</span><br><span class="line">echo &quot;http://www.runoob.com/linux/linux-comm-expr.html&quot;</span><br><span class="line">:&lt;&lt;!</span><br><span class="line">根据用户输入的一句话来定义数组</span><br><span class="line">并遍历数组元素</span><br><span class="line">!</span><br><span class="line">echo &quot;输入字符串（以空格分开）:&quot;</span><br><span class="line">read str</span><br><span class="line">i=0</span><br><span class="line">for word in $str; do</span><br><span class="line">    i=`expr $i + 1`</span><br><span class="line">    eval a$i=&quot;$word&quot;</span><br><span class="line">    eval echo &quot;数组的第 $i 个元素为: \$a$i&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"><span class="comment">#########################################</span></span></span><br><span class="line">指令参考:</span><br><span class="line">http://www.runoob.com/linux/linux-comm-expr.html</span><br><span class="line">输入字符串（以空格分开）:</span><br><span class="line">runoob google taobao</span><br><span class="line">数组的第 1 个元素为: runoob</span><br><span class="line">数组的第 2 个元素为: google</span><br><span class="line">数组的第 3 个元素为: taobao</span><br></pre></td></tr></table></figure><h3 id="5-用-for-循环遍历数组"><a class="markdownIt-Anchor" href="#5-用-for-循环遍历数组"></a> 5. 用 for 循环遍历数组：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">  arr=(1 2 3 4 5 6 7 8 9 10)</span><br><span class="line">  for a in $&#123;arr[*]&#125;</span><br><span class="line">  do</span><br><span class="line">    echo $a</span><br><span class="line">  done</span><br></pre></td></tr></table></figure><h1 id="5-shell-基本运算符"><a class="markdownIt-Anchor" href="#5-shell-基本运算符"></a> 5. Shell 基本运算符</h1><p>Shell 和其他编程语言一样，支持多种运算符，包括：</p><ul><li>算数运算符</li><li>关系运算符</li><li>布尔运算符</li><li>字符串运算符</li><li>文件测试运算符</li></ul><p><strong>原生bash不支持简单的数学运算，但是可以通过其他命令来实现</strong>，例如 awk 和 expr，expr 最常用。</p><p>expr 是一款表达式计算工具，使用它能完成表达式的求值操作。</p><p>例如，两个数相加(<strong>注意使用的是反引号 ` 而不是单引号 '</strong>)：</p><p><strong>实例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">val=`expr 2 + 2`</span><br><span class="line">echo &quot;两数之和为 : $val&quot;</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两数之和为 : 4</span><br></pre></td></tr></table></figure><p>两点注意：</p><ul><li><strong>表达式和运算符之间要有空格</strong>，例如 2+2 是不对的，必须写成 2 + 2，这与我们熟悉的大多数编程语言不一样。</li><li>完整的表达式要被 ``包含，注意这个字符不是常用的单引号，在 Esc 键下边。</li></ul><h2 id="1-算术运算符"><a class="markdownIt-Anchor" href="#1-算术运算符"></a> 1. 算术运算符</h2><p>下表列出了常用的算术运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">+</td><td style="text-align:left">加法</td><td style="text-align:left"><code>expr $a + $b</code> 结果为 30。</td></tr><tr><td style="text-align:left">-</td><td style="text-align:left">减法</td><td style="text-align:left"><code>expr $a - $b</code> 结果为 -10。</td></tr><tr><td style="text-align:left">*</td><td style="text-align:left">乘法</td><td style="text-align:left"><code>expr $a \* $b</code> 结果为  200。</td></tr><tr><td style="text-align:left">/</td><td style="text-align:left">除法</td><td style="text-align:left"><code>expr $b / $a</code> 结果为 2。</td></tr><tr><td style="text-align:left">%</td><td style="text-align:left">取余</td><td style="text-align:left"><code>expr $b % $a</code> 结果为 0。</td></tr><tr><td style="text-align:left">=</td><td style="text-align:left">赋值</td><td style="text-align:left"><code>a=$b</code> 将把变量 b 的值赋给 a。</td></tr><tr><td style="text-align:left">==</td><td style="text-align:left">相等。用于比较两个数字，相同则返回 true。</td><td style="text-align:left"><code>[ $a == $b ]</code> 返回 false。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不相等。用于比较两个数字，不相同则返回 true。</td><td style="text-align:left"><code>[ $a != $b ]</code> 返回 true。</td></tr></tbody></table><p>**注意：**条件表达式要放在方括号之间，并且要有空格，例如: <strong>[<span class="katex"><span class="katex-mathml"><math><semantics><mrow><mi>a</mi><mo>=</mo><mo>=</mo></mrow><annotation encoding="application/x-tex">a==</annotation></semantics></math></span><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.43056em;vertical-align:0em;"></span><span class="mord mathdefault">a</span><span class="mspace" style="margin-right:0.2777777777777778em;"></span><span class="mrel">=</span></span><span class="base"><span class="strut" style="height:0.36687em;vertical-align:0em;"></span><span class="mrel">=</span></span></span></span>b]</strong> 是错误的，必须写成 <strong>[ $a == $b ]</strong>。</p><h3 id="实例"><a class="markdownIt-Anchor" href="#实例"></a> 实例</h3><p>算术运算符实例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">val=`expr $a + $b`</span><br><span class="line">echo &quot;a + b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a - $b`</span><br><span class="line">echo &quot;a - b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $a \* $b`</span><br><span class="line">echo &quot;a * b : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b / $a`</span><br><span class="line">echo &quot;b / a : $val&quot;</span><br><span class="line"></span><br><span class="line">val=`expr $b % $a`</span><br><span class="line">echo &quot;b % a : $val&quot;</span><br><span class="line"></span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 不等于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a + b : 30</span><br><span class="line">a - b : -10</span><br><span class="line">a * b : 200</span><br><span class="line">b / a : 2</span><br><span class="line">b % a : 0</span><br><span class="line">a 不等于 b</span><br></pre></td></tr></table></figure><blockquote><p><strong>注意：</strong></p><ul><li>乘号(*)前边必须加反斜杠()才能实现乘法运算；</li><li>if…then…fi 是条件语句，后续将会讲解。</li><li>在 MAC 中 shell 的 expr 语法是：<strong>$((表达式))</strong>，此处表达式中的 “*” 不需要转义符号 “” 。</li></ul></blockquote><h2 id="关系运算符"><a class="markdownIt-Anchor" href="#关系运算符"></a> 关系运算符</h2><p>关系运算符只支持数字，不支持字符串，除非字符串的值是数字。</p><p>下表列出了常用的关系运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">-eq</td><td style="text-align:left">检测两个数是否相等，相等返回 true。</td><td style="text-align:left">[ $a -eq $b ] 返回 false。</td></tr><tr><td style="text-align:left">-ne</td><td style="text-align:left">检测两个数是否不相等，不相等返回 true。</td><td style="text-align:left">[ $a -ne $b ] 返回 true。</td></tr><tr><td style="text-align:left">-gt</td><td style="text-align:left">检测左边的数是否大于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -gt $b ] 返回 false。</td></tr><tr><td style="text-align:left">-lt</td><td style="text-align:left">检测左边的数是否小于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -lt $b ] 返回 true。</td></tr><tr><td style="text-align:left">-ge</td><td style="text-align:left">检测左边的数是否大于等于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -ge $b ] 返回 false。</td></tr><tr><td style="text-align:left">-le</td><td style="text-align:left">检测左边的数是否小于等于右边的，如果是，则返回 true。</td><td style="text-align:left">[ $a -le $b ] 返回 true。</td></tr></tbody></table><h3 id="实例-2"><a class="markdownIt-Anchor" href="#实例-2"></a> 实例</h3><p>关系运算符实例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ne $b: a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ne $b : a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -gt $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -gt $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -lt $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -lt $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ge $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ge $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -le $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -le $b: a 大于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">10 -eq 20: a 不等于 b</span><br><span class="line">10 -ne 20: a 不等于 b</span><br><span class="line">10 -gt 20: a 不大于 b</span><br><span class="line">10 -lt 20: a 小于 b</span><br><span class="line">10 -ge 20: a 小于 b</span><br><span class="line">10 -le 20: a 小于或等于 b</span><br></pre></td></tr></table></figure><h2 id="2-布尔运算符"><a class="markdownIt-Anchor" href="#2-布尔运算符"></a> 2. 布尔运算符</h2><p>下表列出了常用的布尔运算符，假定变量 a 为 10，变量 b 为 20：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">!</td><td style="text-align:left">非运算，表达式为 true 则返回 false，否则返回 true。</td><td style="text-align:left"><code>[ ! false ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">或运算，有一个表达式为 true 则返回 true。</td><td style="text-align:left"><code>[ $a -lt 20 -o $b -gt 100 ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-a</td><td style="text-align:left">与运算，两个表达式都为 true 才返回 true。</td><td style="text-align:left"><code>[ $a -lt 20 -a $b -gt 100 ]</code> 返回 false。</td></tr></tbody></table><h3 id="实例-3"><a class="markdownIt-Anchor" href="#实例-3"></a> 实例</h3><p>布尔运算符实例如下：</p><p><strong>实例:</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [ $a -eq $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -eq $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -eq $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ne $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ne $b: a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ne $b : a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -gt $b: a 大于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -gt $b: a 不大于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -lt $b: a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -lt $b: a 不小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -ge $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -ge $b: a 大于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -ge $b: a 小于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a -le $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a -le $b: a 小于或等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a -le $b: a 大于 b&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">10 != 20 : a 不等于 b</span><br><span class="line">10 小于 100 且 20 大于 15 : 返回 true</span><br><span class="line">10 小于 100 或 20 大于 100 : 返回 true</span><br><span class="line">10 小于 5 或 20 大于 100 : 返回 false</span><br></pre></td></tr></table></figure><h2 id="3-逻辑运算符"><a class="markdownIt-Anchor" href="#3-逻辑运算符"></a> 3. 逻辑运算符</h2><p>以下介绍 Shell 的逻辑运算符，假定变量 a 为 10，变量 b 为 20:</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">&amp;&amp;</td><td style="text-align:left">逻辑的 AND</td><td style="text-align:left">[[ $a -lt 100 &amp;&amp; $b -gt 100 ]] 返回 false</td></tr><tr><td style="text-align:left">||</td><td style="text-align:left">逻辑的 OR</td><td style="text-align:left">[[ $a -lt 100 || $b -gt 100 ]] 返回 true</td></tr></tbody></table><h3 id="实例-4"><a class="markdownIt-Anchor" href="#实例-4"></a> 实例</h3><p>逻辑运算符实例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 &amp;&amp; $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if [[ $a -lt 100 || $b -gt 100 ]]</span><br><span class="line">then</span><br><span class="line">   echo &quot;返回 true&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;返回 false&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">返回 false</span><br><span class="line">返回 true</span><br></pre></td></tr></table></figure><h2 id="4-字符串运算符"><a class="markdownIt-Anchor" href="#4-字符串运算符"></a> 4. 字符串运算符</h2><p>下表列出了常用的字符串运算符，假定变量 a 为 “abc”，变量 b 为 “efg”：</p><table><thead><tr><th style="text-align:left">运算符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">检测两个字符串是否相等，相等返回 true。</td><td style="text-align:left"><code>[ $a = $b ]</code> 返回 false。</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">检测两个字符串是否相等，不相等返回 true。</td><td style="text-align:left"><code>[ $a != $b ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-z</td><td style="text-align:left">检测字符串长度是否为0，为0返回 true。</td><td style="text-align:left"><code>[ -z $a ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-n</td><td style="text-align:left">检测字符串长度是否不为 0，不为 0 返回 true。</td><td style="text-align:left"><code>[ -n &quot;$a&quot; ]</code> 返回 true。</td></tr><tr><td style="text-align:left">$</td><td style="text-align:left">检测字符串是否为空，不为空返回 true。</td><td style="text-align:left"><code>[ $a ]</code> 返回 true。</td></tr></tbody></table><h3 id="实例-5"><a class="markdownIt-Anchor" href="#实例-5"></a> 实例</h3><p>字符串运算符实例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:菜鸟教程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">a=&quot;abc&quot;</span><br><span class="line">b=&quot;efg&quot;</span><br><span class="line"></span><br><span class="line">if [ $a = $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a = $b : a 等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a = $b: a 不等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a != $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a != $b : a 不等于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a != $b: a 等于 b&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -z $a ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-z $a : 字符串长度为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-z $a : 字符串长度不为 0&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -n &quot;$a&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-n $a : 字符串长度不为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-n $a : 字符串长度为 0&quot;</span><br><span class="line">fi</span><br><span class="line">if [ $a ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;$a : 字符串不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;$a : 字符串为空&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">abc = efg: a 不等于 b</span><br><span class="line">abc != efg : a 不等于 b</span><br><span class="line">-z abc : 字符串长度不为 0</span><br><span class="line">-n abc : 字符串长度不为 0</span><br><span class="line">abc : 字符串不为空</span><br></pre></td></tr></table></figure><h2 id="5-文件测试运算符"><a class="markdownIt-Anchor" href="#5-文件测试运算符"></a> 5. 文件测试运算符</h2><p>文件测试运算符用于检测 Unix 文件的各种属性。</p><p>属性检测描述如下：</p><table><thead><tr><th style="text-align:left">操作符</th><th style="text-align:left">说明</th><th style="text-align:left">举例</th></tr></thead><tbody><tr><td style="text-align:left">-b file</td><td style="text-align:left">检测文件是否是块设备文件，如果是，则返回 true。</td><td style="text-align:left"><code>[ -b $file ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-c file</td><td style="text-align:left">检测文件是否是字符设备文件，如果是，则返回 true。</td><td style="text-align:left"><code>[ -c $file ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-d file</td><td style="text-align:left">检测文件是否是目录，如果是，则返回 true。</td><td style="text-align:left"><code>[ -d $file ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-f file</td><td style="text-align:left">检测文件是否是普通文件（既不是目录，也不是设备文件），如果是，则返回 true。</td><td style="text-align:left"><code>[ -f $file ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-g file</td><td style="text-align:left">检测文件是否设置了 SGID 位，如果是，则返回 true。</td><td style="text-align:left"><code>[ -g $file ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-k file</td><td style="text-align:left">检测文件是否设置了粘着位(Sticky Bit)，如果是，则返回 true。</td><td style="text-align:left"><code>[ -k $file ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-p file</td><td style="text-align:left">检测文件是否是有名管道，如果是，则返回 true。</td><td style="text-align:left"><code>[ -p $file ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-u file</td><td style="text-align:left">检测文件是否设置了 SUID 位，如果是，则返回 true。</td><td style="text-align:left"><code>[ -u $file ]</code> 返回 false。</td></tr><tr><td style="text-align:left">-r file</td><td style="text-align:left">检测文件是否可读，如果是，则返回 true。</td><td style="text-align:left"><code>[ -r $file ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-w file</td><td style="text-align:left">检测文件是否可写，如果是，则返回 true。</td><td style="text-align:left"><code>[ -w $file ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-x file</td><td style="text-align:left">检测文件是否可执行，如果是，则返回 true。</td><td style="text-align:left"><code>[ -x $file ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-s file</td><td style="text-align:left">检测文件是否为空（文件大小是否大于0），不为空返回 true。</td><td style="text-align:left"><code>[ -s $file ]</code> 返回 true。</td></tr><tr><td style="text-align:left">-e file</td><td style="text-align:left">检测文件（包括目录）是否存在，如果是，则返回 true。</td><td style="text-align:left"><code>[ -e $file ]</code> 返回 true。</td></tr></tbody></table><p>其他检查符：</p><ul><li><strong>-S</strong>: 判断某文件是否 socket。</li><li><strong>-L</strong>: 检测文件是否存在并且是一个符号链接。</li></ul><h3 id="实例-6"><a class="markdownIt-Anchor" href="#实例-6"></a> 实例</h3><p>变量 file 表示文件 <strong>/var/www/runoob/test.sh</strong>，它的大小为 100 字节，具有 <strong>rwx</strong> 权限。下面的代码，将检测该文件的各种属性：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">file=&quot;/var/www/runoob/test.sh&quot;</span><br><span class="line">if [ -r $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可读&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可读&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -w $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可写&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可写&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -x $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件可执行&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不可执行&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -f $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件为普通文件&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件为特殊文件&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -d $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件是个目录&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不是个目录&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -s $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件不为空&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件为空&quot;</span><br><span class="line">fi</span><br><span class="line">if [ -e $file ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;文件存在&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;文件不存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">文件可读</span><br><span class="line">文件可写</span><br><span class="line">文件可执行</span><br><span class="line">文件为普通文件</span><br><span class="line">文件不是个目录</span><br><span class="line">文件不为空</span><br><span class="line">文件存在</span><br></pre></td></tr></table></figure><h2 id="note-4"><a class="markdownIt-Anchor" href="#note-4"></a> Note</h2><h3 id="1-2"><a class="markdownIt-Anchor" href="#1-2"></a> 1.</h3><p>EQ 就是 EQUAL等于</p><p>NE 就是 NOT EQUAL不等于</p><p>GT 就是 GREATER THAN大于</p><p>LT 就是 LESS THAN小于</p><p>GE 就是 GREATER THAN OR EQUAL 大于等于</p><p>LE 就是 LESS THAN OR EQUAL 小于等于</p><h3 id="2"><a class="markdownIt-Anchor" href="#2"></a> 2.</h3><p>使用 <strong>[[ … ]]</strong> 条件判断结构，而不是 <strong>[ … ]</strong>，能够防止脚本中的许多逻辑错误。比如，<strong>&amp;&amp;</strong>、<strong>||</strong>、<strong>&lt;</strong> 和 <strong>&gt;</strong> 操作符能够正常存在于 <strong>[[ ]]</strong> 条件判断结构中，但是如果出现在 <strong>[ ]</strong> 结构中的话，会报错。</p><h3 id="3-2"><a class="markdownIt-Anchor" href="#3-2"></a> 3.</h3><p>1、进行数值比较时，可以使用 <strong>[ expression1 OPexpression2 ]</strong>，<strong>OP</strong> 可以为 <strong>-gt、-lt、-ge、-le、-eq、-ne</strong> 也可以使用 <strong>((expression1 OP expression2))</strong>，<strong>OP</strong> 可以为 <strong>&gt;、&lt;、&gt;=、&lt;=、==、!=</strong>。这几个关系运算符都是测试整数表达式 expression1 和 expression2 之间的大小关系。</p><p>2、 <strong>&gt;、&lt;、==、!=</strong> 也可以进行字符串比较。</p><p>3、进行字符串比较时，== 可以使用 = 替代。</p><p>4、 == 和 !=进行字符串比较时，可以使用 [ string1 OP string2 ] 或者 [[ string1 OP string2 ]] 的形式。</p><p>5、 &gt; 和 &lt; 进行字符串比较时，需要使用[[ string1 OP string2 ]] 或者 [ string1 \OP string2 ]。也就是使用 [] 时，&gt; 和 &lt; 需要使用反斜线转义。</p><h3 id="4"><a class="markdownIt-Anchor" href="#4"></a> 4.</h3><p>字符串比较是否为 <strong>null</strong> 这里:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=&quot;&quot;</span><br><span class="line">if [ -n $a ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-n $a : 字符串长度不为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-n $a : 字符串长度为 0&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n  : 字符串长度不为 0</span><br></pre></td></tr></table></figure><p>从结果上看 <strong><code>-n $a</code></strong> 返回 true，这并正确，正确的做法是 <strong><code>$a</code></strong> 这里应该加上双引号，否则 <strong><code>-n $a</code></strong> 的结果永远是 true：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=&quot;&quot;</span><br><span class="line">if [ -n &quot;$a&quot; ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;-n $a : 字符串长度不为 0&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;-n $a : 字符串长度为 0&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-n  : 字符串长度为 0</span><br></pre></td></tr></table></figure><h3 id="5"><a class="markdownIt-Anchor" href="#5"></a> 5.</h3><p>Shell 相加目前发现有 3 种写法：</p><p><strong>1.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">c=`expr $&#123;a&#125; + $&#123;b&#125;`</span><br><span class="line">echo &quot;$c&quot;</span><br></pre></td></tr></table></figure><p><strong>2.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=$[ `expr 10 + 20` ]</span><br><span class="line">echo &quot;$c&quot;</span><br></pre></td></tr></table></figure><p><strong>3.</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">c=$[ 10 + 20 ]</span><br><span class="line">echo &quot;$c&quot;</span><br></pre></td></tr></table></figure><p>初学者推荐第一种写法，虽然看着复杂，但逻辑清晰，不易混淆。</p><h3 id="6推荐用-代替"><a class="markdownIt-Anchor" href="#6推荐用-代替"></a> 6.推荐用 <strong>$()</strong> 代替 <strong>``</strong>:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">val=`expr 10 + 20`</span><br><span class="line"></span><br><span class="line">val=$(expr 10 + 20)</span><br></pre></td></tr></table></figure><h3 id="7-相加补充一种方式"><a class="markdownIt-Anchor" href="#7-相加补充一种方式"></a> 7. 相加补充一种方式：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">c=$(($a+$b))</span><br></pre></td></tr></table></figure><h3 id="8-表达式"><a class="markdownIt-Anchor" href="#8-表达式"></a> 8. <strong>[] 表达式</strong></h3><p><strong>注意</strong>：在 [] 表达式中，常见的 &gt;, &lt; 需要加转义字符，表示字符串大小比较，以 acill 码位置作为比较。不直接支持 &gt;, &lt; 运算符，还有逻辑运算符 || 、&amp;&amp; ，它需要用 -a[and] -o[or] 表示。</p><p><strong>[[ ]] 表达式</strong></p><p><strong>注意</strong>：[[]] 运算符只是 [] 运算符的扩充。能够支持 &gt;, &lt; 符号运算不需要转义符，它还是以字符串比较大小。里面支持逻辑运算符：<strong>|| &amp;&amp;</strong> ，不再使用 <strong>-a -o</strong>。</p><h1 id="6-shell-echo命令"><a class="markdownIt-Anchor" href="#6-shell-echo命令"></a> 6. Shell echo命令</h1><p>Shell 的 echo 指令与 PHP 的 echo 指令类似，都是用于字符串的输出。命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo string</span><br></pre></td></tr></table></figure><p>您可以使用echo实现更复杂的输出格式控制。</p><h2 id="1显示普通字符串"><a class="markdownIt-Anchor" href="#1显示普通字符串"></a> 1.显示普通字符串:</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure><p>这里的双引号完全可以省略，以下命令与上面实例效果一致：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo It is a test</span><br></pre></td></tr></table></figure><h2 id="2显示转义字符"><a class="markdownIt-Anchor" href="#2显示转义字符"></a> 2.显示转义字符</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;\&quot;It is a test\&quot;&quot;</span><br></pre></td></tr></table></figure><p>结果将是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&quot;It is a test&quot;</span><br></pre></td></tr></table></figure><p>同样，双引号也可以省略</p><h2 id="3显示变量"><a class="markdownIt-Anchor" href="#3显示变量"></a> 3.显示变量</h2><p>read 命令从标准输入中读取一行,并把输入行的每个字段的值指定给 shell 变量</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">read name </span><br><span class="line">echo &quot;$name It is a test&quot;</span><br></pre></td></tr></table></figure><p>以上代码保存为 <a href="http://test.sh">test.sh</a>，name 接收标准输入的变量，结果将是:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@www ~]# sh test.sh</span><br><span class="line">OK                     #标准输入</span><br><span class="line">OK It is a test        #输出</span><br></pre></td></tr></table></figure><h2 id="4显示换行"><a class="markdownIt-Anchor" href="#4显示换行"></a> 4.显示换行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">echo -e &quot;OK! \n&quot; # -e 开启转义</span><br><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">OK!</span><br><span class="line"></span><br><span class="line">It is a test</span><br></pre></td></tr></table></figure><h2 id="5显示不换行"><a class="markdownIt-Anchor" href="#5显示不换行"></a> 5.显示不换行</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/sh</span></span><br><span class="line">echo -e &quot;OK! \c&quot; # -e 开启转义 \c 不换行</span><br><span class="line">echo &quot;It is a test&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">OK! It is a test</span><br></pre></td></tr></table></figure><h2 id="6显示结果定向至文件"><a class="markdownIt-Anchor" href="#6显示结果定向至文件"></a> 6.显示结果定向至文件</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &quot;It is a test&quot; &gt; myfile</span><br></pre></td></tr></table></figure><h2 id="7原样输出字符串不进行转义或取变量用单引号"><a class="markdownIt-Anchor" href="#7原样输出字符串不进行转义或取变量用单引号"></a> 7.原样输出字符串，不进行转义或取变量(用单引号)</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;$name\&quot;&#x27;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">name\&quot;</span></span><br></pre></td></tr></table></figure><h2 id="8显示命令执行结果"><a class="markdownIt-Anchor" href="#8显示命令执行结果"></a> 8.显示命令执行结果</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">echo `date`</span><br></pre></td></tr></table></figure><p><strong>注意：</strong> 这里使用的是反引号 <strong>`</strong>, 而不是单引号 <strong>'</strong>。</p><p>结果将显示当前日期</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Thu Jul 24 10:08:46 CST 2014</span><br></pre></td></tr></table></figure><h2 id="note-5"><a class="markdownIt-Anchor" href="#note-5"></a> Note</h2><h3 id="1-echo输出的字符串总结"><a class="markdownIt-Anchor" href="#1-echo输出的字符串总结"></a> 1. echo输出的字符串总结</h3><p>===================================================================</p><p>​    能否引用变量  |  能否引用转移符  |  能否引用文本格式符(如：换行符、制表符)</p><p>单引号  |      否      |       否       |               否</p><p>双引号  |      能      |       能       |               能</p><p>无引号  |      能      |       能       |               否</p><p>===================================================================</p><h3 id="2-2"><a class="markdownIt-Anchor" href="#2-2"></a> 2.</h3><p>read 命令一个一个词组地接收输入的参数，每个词组需要使用空格进行分隔；如果输入的词组个数大于需要的参数个数，则多出的词组将被作为整体为最后一个参数接收。</p><p>测试文件 <a href="http://test.sh">test.sh</a> 代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read firstStr secondStr</span><br><span class="line">echo &quot;第一个参数:$firstStr; 第二个参数:$secondStr&quot;</span><br></pre></td></tr></table></figure><p>执行测试：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh test.sh</span> </span><br><span class="line">一 二 三 四</span><br><span class="line">第一个参数:一; 第二个参数:二 三 四</span><br></pre></td></tr></table></figure><p>实例, 文件 <a href="http://test.sh">test.sh</a>:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">read -p &quot;请输入一段文字:&quot; -n 6 -t 5 -s password</span><br><span class="line">echo -e &quot;\npassword is $password&quot;</span><br></pre></td></tr></table></figure><p>参数说明：</p><ul><li><strong>-p</strong> 输入提示文字</li><li><strong>-n</strong> 输入字符长度限制(达到6位，自动结束)</li><li><strong>-t</strong> 输入限时</li><li><strong>-s</strong> 隐藏输入内容</li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> sh test.sh</span> </span><br><span class="line">请输入一段文字:</span><br><span class="line">password is asdfgh</span><br></pre></td></tr></table></figure><h3 id="3-3"><a class="markdownIt-Anchor" href="#3-3"></a> 3.</h3><p><strong>&gt;</strong> 重定向输出到某个位置，替换原有文件的所有内容。</p><p><strong>&gt;&gt;</strong> 重定向追加到某个位置，在原有文件的末尾添加内容。</p><p><strong>&lt;</strong> 重定向输入某个位置文件。</p><p><strong>2&gt;</strong> 重定向错误输出。</p><p><strong>2&gt;&gt;</strong> 重定向错误追加输出到文件末尾。</p><p><strong>&amp;&gt;</strong> 混合输出错误的和正确的都输出。</p><h1 id="7-shell-printf-命令"><a class="markdownIt-Anchor" href="#7-shell-printf-命令"></a> 7. Shell printf 命令</h1><p>上一章节我们学习了 Shell 的 echo 命令，本章节我们来学习 Shell 的另一个输出命令 printf。</p><p>printf 命令模仿 C 程序库（library）里的 printf() 程序。</p><p>printf 由 POSIX 标准所定义，因此使用 printf 的脚本比使用 echo 移植性好。</p><p>printf 使用引用文本或空格分隔的参数，外面可以在 printf 中使用格式化字符串，还可以制定字符串的宽度、左右对齐方式等。默认 printf 不会像 echo 自动添加换行符，我们可以手动添加 \n。</p><p>printf 命令的语法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">printf  format-string  [arguments...]</span><br></pre></td></tr></table></figure><p><strong>参数说明：</strong></p><ul><li><strong>format-string:</strong> 为格式控制字符串</li><li><strong>arguments:</strong> 为参数列表。</li></ul><p>实例如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;Hello, Shell&quot;</span></span></span><br><span class="line">Hello, Shell</span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;Hello, Shell\n&quot;</span></span></span><br><span class="line">Hello, Shell</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>接下来,我来用一个脚本来体现printf的强大功能：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:菜鸟教程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:www.runoob.com</span></span><br><span class="line"> </span><br><span class="line">printf &quot;%-10s %-8s %-4s\n&quot; 姓名 性别 体重kg  </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭靖 男 66.1234 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 杨过 男 48.6543 </span><br><span class="line">printf &quot;%-10s %-8s %-4.2f\n&quot; 郭芙 女 47.9876 </span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">姓名     性别   体重kg</span><br><span class="line">郭靖     男      66.12</span><br><span class="line">杨过     男      48.65</span><br><span class="line">郭芙     女      47.99</span><br></pre></td></tr></table></figure><p>%s %c %d %f都是格式替代符</p><p>%-10s 指一个宽度为10个字符（-表示左对齐，没有则表示右对齐），任何字符都会被显示在10个字符宽的字符内，如果不足则自动以空格填充，超过也会将内容全部显示出来。</p><p>%-4.2f 指格式化为小数，其中.2指保留2位小数。</p><p>更多实例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:菜鸟教程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:www.runoob.com</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> format-string为双引号</span></span><br><span class="line">printf &quot;%d %s\n&quot; 1 &quot;abc&quot;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 单引号与双引号效果一样</span> </span><br><span class="line">printf &#x27;%d %s\n&#x27; 1 &quot;abc&quot; </span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 没有引号也可以输出</span></span><br><span class="line">printf %s abcdef</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 格式只指定了一个参数，但多出的参数仍然会按照该格式输出，format-string 被重用</span></span><br><span class="line">printf %s abc def</span><br><span class="line"></span><br><span class="line">printf &quot;%s\n&quot; abc def</span><br><span class="line"></span><br><span class="line">printf &quot;%s %s %s\n&quot; a b c d e f g h i j</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 如果没有 arguments，那么 %s 用NULL代替，%d 用 0 代替</span></span><br><span class="line">printf &quot;%s and %d \n&quot; </span><br></pre></td></tr></table></figure><p>执行脚本，输出结果如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 abc</span><br><span class="line">1 abc</span><br><span class="line">abcdefabcdefabc</span><br><span class="line">def</span><br><span class="line">a b c</span><br><span class="line">d e f</span><br><span class="line">g h i</span><br><span class="line">j  </span><br><span class="line"> and 0</span><br></pre></td></tr></table></figure><h2 id="printf的转义序列"><a class="markdownIt-Anchor" href="#printf的转义序列"></a> printf的转义序列</h2><table><thead><tr><th style="text-align:left">序列</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">\a</td><td style="text-align:left">警告字符，通常为ASCII的BEL字符</td></tr><tr><td style="text-align:left">\b</td><td style="text-align:left">后退</td></tr><tr><td style="text-align:left">\c</td><td style="text-align:left">抑制（不显示）输出结果中任何结尾的换行字符（只在%b格式指示符控制下的参数字符串中有效），而且，任何留在参数里的字符、任何接下来的参数以及任何留在格式字符串中的字符，都被忽略</td></tr><tr><td style="text-align:left">\f</td><td style="text-align:left">换页（formfeed）</td></tr><tr><td style="text-align:left">\n</td><td style="text-align:left">换行</td></tr><tr><td style="text-align:left">\r</td><td style="text-align:left">回车（Carriage return）</td></tr><tr><td style="text-align:left">\t</td><td style="text-align:left">水平制表符</td></tr><tr><td style="text-align:left">\v</td><td style="text-align:left">垂直制表符</td></tr><tr><td style="text-align:left">\</td><td style="text-align:left">一个字面上的反斜杠字符</td></tr><tr><td style="text-align:left">\ddd</td><td style="text-align:left">表示1到3位数八进制值的字符。仅在格式字符串中有效</td></tr><tr><td style="text-align:left">\0ddd</td><td style="text-align:left">表示1到3位的八进制值字符</td></tr></tbody></table><h3 id="实例-7"><a class="markdownIt-Anchor" href="#实例-7"></a> 实例</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;a string, no processing:&lt;%s&gt;\n&quot;</span> <span class="string">&quot;A\nB&quot;</span></span></span><br><span class="line">a string, no processing:&lt;A\nB&gt;</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;a string, no processing:&lt;%b&gt;\n&quot;</span> <span class="string">&quot;A\nB&quot;</span></span></span><br><span class="line">a string, no processing:&lt;A</span><br><span class="line"><span class="meta">B&gt;</span><span class="bash"></span></span><br><span class="line"><span class="bash"></span><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;www.runoob.com \a&quot;</span></span></span><br><span class="line">www.runoob.com $                  #不换行</span><br></pre></td></tr></table></figure><h2 id="note-6"><a class="markdownIt-Anchor" href="#note-6"></a> Note</h2><h3 id="1-3"><a class="markdownIt-Anchor" href="#1-3"></a> 1.</h3><p><strong>%d %s %c %f</strong> 格式替代符详解:</p><p><strong>d: Decimal 十进制整数</strong> – 对应位置参数必须是十进制整数，否则报错！</p><p><strong>s: String 字符串</strong> – 对应位置参数必须是字符串或者字符型，否则报错！</p><p><strong>c: Char 字符</strong> – 对应位置参数必须是字符串或者字符型，否则报错！</p><p><strong>f: Float 浮点</strong> – 对应位置参数必须是数字型，否则报错！</p><p>如：其中最后一个参数是 “def”，%c 自动截取字符串的第一个字符作为结果输出。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  <span class="built_in">printf</span> <span class="string">&quot;%d %s %c\n&quot;</span> 1 <span class="string">&quot;abc&quot;</span> <span class="string">&quot;def&quot;</span></span></span><br><span class="line">1 abc d</span><br></pre></td></tr></table></figure><h3 id="2-补充格式符-b"><a class="markdownIt-Anchor" href="#2-补充格式符-b"></a> 2. 补充格式符 %b:</h3><p>**%b: 字符串–**相对应的参数被视为含有要被处理的转义序列之字符串</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;a string, no processing:&lt;%b&gt;\n&quot;</span> <span class="string">&quot;A\nB&quot;</span></span></span><br><span class="line">a string, no processing:&lt;A</span><br><span class="line"><span class="meta">B&gt;</span></span><br></pre></td></tr></table></figure><p>无论时在格式字符串内还是在使用 %b 所打印的参数字符串里，大部分的转义序列都是被相同对待。</p><p>无论如何，\c 与 \0ddd 只有搭配 %b 使用才有效，而 \ddd 只有在格式字符串里才会被解释。</p><h3 id="3-f-格式化浮点数默认支持-6-位小数"><a class="markdownIt-Anchor" href="#3-f-格式化浮点数默认支持-6-位小数"></a> 3. <strong>%f</strong> 格式化浮点数默认支持 6 位小数:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">printf</span> <span class="string">&quot;%d %s %c %f\n&quot;</span> 10 <span class="string">&quot;abc&quot;</span> <span class="string">&quot;def&quot;</span> <span class="string">&quot;3.1415926&quot;</span></span></span><br><span class="line">10 abc d 3.141593          # 格式化浮点数默认支持小数点后六位，后面多出的四舍五入</span><br></pre></td></tr></table></figure><h1 id="8-shell-test-命令"><a class="markdownIt-Anchor" href="#8-shell-test-命令"></a> 8. Shell test 命令</h1><p><strong>Shell中的 test 命令用于检查某个条件是否成立，它可以进行数值、字符和文件三个方面的测试。</strong></p><h2 id="数值测试"><a class="markdownIt-Anchor" href="#数值测试"></a> 数值测试</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-eq</td><td style="text-align:left">等于则为真</td></tr><tr><td style="text-align:left">-ne</td><td style="text-align:left">不等于则为真</td></tr><tr><td style="text-align:left">-gt</td><td style="text-align:left">大于则为真</td></tr><tr><td style="text-align:left">-ge</td><td style="text-align:left">大于等于则为真</td></tr><tr><td style="text-align:left">-lt</td><td style="text-align:left">小于则为真</td></tr><tr><td style="text-align:left">-le</td><td style="text-align:left">小于等于则为真</td></tr></tbody></table><p>实例演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=100</span><br><span class="line">num2=100</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数相等！&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数不相等！&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个数相等！</span><br></pre></td></tr></table></figure><p>代码中的 [] 执行基本的算数运算，如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=5</span><br><span class="line">b=6</span><br><span class="line"></span><br><span class="line">result=$[a+b] # 注意等号两边不能有空格</span><br><span class="line">echo &quot;result 为： $result&quot;</span><br></pre></td></tr></table></figure><p>结果为:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result 为： 11</span><br></pre></td></tr></table></figure><h2 id="字符串测试"><a class="markdownIt-Anchor" href="#字符串测试"></a> 字符串测试</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">=</td><td style="text-align:left">等于则为真</td></tr><tr><td style="text-align:left">!=</td><td style="text-align:left">不相等则为真</td></tr><tr><td style="text-align:left">-z 字符串</td><td style="text-align:left">字符串的长度为零则为真</td></tr><tr><td style="text-align:left">-n 字符串</td><td style="text-align:left">字符串的长度不为零则为真</td></tr></tbody></table><p>实例演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=&quot;ru1noob&quot;</span><br><span class="line">num2=&quot;runoob&quot;</span><br><span class="line">if test $num1 = $num2</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个字符串相等!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个字符串不相等!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个字符串不相等!</span><br></pre></td></tr></table></figure><h2 id="文件测试"><a class="markdownIt-Anchor" href="#文件测试"></a> 文件测试</h2><table><thead><tr><th style="text-align:left">参数</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">-e 文件名</td><td style="text-align:left">如果文件存在则为真</td></tr><tr><td style="text-align:left">-r 文件名</td><td style="text-align:left">如果文件存在且可读则为真</td></tr><tr><td style="text-align:left">-w 文件名</td><td style="text-align:left">如果文件存在且可写则为真</td></tr><tr><td style="text-align:left">-x 文件名</td><td style="text-align:left">如果文件存在且可执行则为真</td></tr><tr><td style="text-align:left">-s 文件名</td><td style="text-align:left">如果文件存在且至少有一个字符则为真</td></tr><tr><td style="text-align:left">-d 文件名</td><td style="text-align:left">如果文件存在且为目录则为真</td></tr><tr><td style="text-align:left">-f 文件名</td><td style="text-align:left">如果文件存在且为普通文件则为真</td></tr><tr><td style="text-align:left">-c 文件名</td><td style="text-align:left">如果文件存在且为字符型特殊文件则为真</td></tr><tr><td style="text-align:left">-b 文件名</td><td style="text-align:left">如果文件存在且为块特殊文件则为真</td></tr></tbody></table><p>实例演示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &#x27;文件已存在!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;文件不存在!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">文件已存在!</span><br></pre></td></tr></table></figure><p>另外，Shell还提供了与( -a )、或( -o )、非( ! )三个逻辑操作符用于将测试条件连接起来，其优先级为：&quot;!“最高，”-a&quot;次之，&quot;-o&quot;最低。例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">cd /bin</span><br><span class="line">if test -e ./notFile -o -e ./bash</span><br><span class="line">then</span><br><span class="line">    echo &#x27;至少有一个文件存在!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个文件都不存在&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">至少有一个文件存在!</span><br></pre></td></tr></table></figure><h2 id="note-7"><a class="markdownIt-Anchor" href="#note-7"></a> Note</h2><h3 id="1-符号含义"><a class="markdownIt-Anchor" href="#1-符号含义"></a> 1. <strong>符号含义：</strong></h3><p>\1. eq （equal的缩写），表示等于为真</p><p>\2. ne  (not equal的缩写），表示不等于为真</p><p>\3. gt   (greater than的缩写），表示大于为真</p><p>\4. ge （greater&amp;equal的缩写），表示大于等于为真</p><p>\5. lt  （lower than的缩写），表示小于为真</p><p>\6. le  （lower&amp;equal的缩写），表示小于等于为真</p><h3 id="2-3"><a class="markdownIt-Anchor" href="#2-3"></a> 2.</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result=$[a + b]</span><br></pre></td></tr></table></figure><p>等同于：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">result=`expr $a + $b `</span><br></pre></td></tr></table></figure><h3 id="3-4"><a class="markdownIt-Anchor" href="#3-4"></a> 3.</h3><p><strong>shell 判断文件夹或文件是否存在</strong></p><p>文件夹不存在则创建</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -d &quot;/data/&quot; ];then</span><br><span class="line">  mkdir /data</span><br><span class="line">  else</span><br><span class="line">  echo &quot;文件夹已经存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>文件存在则删除</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ ! -f &quot;/data/filename&quot; ];then</span><br><span class="line">  echo &quot;文件不存在&quot;</span><br><span class="line">  else</span><br><span class="line">  rm -f /data/filename</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>判断文件夹是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ -d &quot;/data/&quot; ];then</span><br><span class="line">  echo &quot;文件夹存在&quot;</span><br><span class="line">  else</span><br><span class="line">  echo &quot;文件夹不存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>判断文件是否存在</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">if [ -f &quot;/data/filename&quot; ];then</span><br><span class="line">  echo &quot;文件存在&quot;</span><br><span class="line">  else</span><br><span class="line">  echo &quot;文件不存在&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>文件比较符</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">-e 判断对象是否存在</span><br><span class="line">-d 判断对象是否存在，并且为目录</span><br><span class="line">-f 判断对象是否存在，并且为常规文件</span><br><span class="line">-L 判断对象是否存在，并且为符号链接</span><br><span class="line">-h 判断对象是否存在，并且为软链接</span><br><span class="line">-s 判断对象是否存在，并且长度不为0</span><br><span class="line">-r 判断对象是否存在，并且可读</span><br><span class="line">-w 判断对象是否存在，并且可写</span><br><span class="line">-x 判断对象是否存在，并且可执行</span><br><span class="line">-O 判断对象是否存在，并且属于当前用户</span><br><span class="line">-G 判断对象是否存在，并且属于当前用户组</span><br><span class="line">-nt 判断file1是否比file2新  [ &quot;/data/file1&quot; -nt &quot;/data/file2&quot; ]</span><br><span class="line">-ot 判断file1是否比file2旧  [ &quot;/data/file1&quot; -ot &quot;/data/file2&quot; ]</span><br></pre></td></tr></table></figure><h1 id="9-shell-流程控制"><a class="markdownIt-Anchor" href="#9-shell-流程控制"></a> 9. Shell 流程控制</h1><p>和Java、PHP等语言不一样，sh的流程控制不可为空，如(以下为PHP流程控制写法)：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;?php</span><br><span class="line">if (isset($_GET[&quot;q&quot;])) &#123;</span><br><span class="line">    search(q);</span><br><span class="line">&#125;</span><br><span class="line">else &#123;</span><br><span class="line">    // 不做任何事情</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在sh/bash里可不能这么写，如果else分支没有语句执行，就不要写这个else。</p><h2 id="1-if-else"><a class="markdownIt-Anchor" href="#1-if-else"></a> 1. if else</h2><h3 id="if"><a class="markdownIt-Anchor" href="#if"></a> if</h3><p>if 语句语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN </span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>写成一行（适用于终端命令提示符）：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">if [ $(ps -ef | grep -c &quot;ssh&quot;) -gt 1 ]; then echo &quot;true&quot;; fi</span><br></pre></td></tr></table></figure><p>末尾的fi就是if倒过来拼写，后面还会遇到类似的。</p><h3 id="if-else"><a class="markdownIt-Anchor" href="#if-else"></a> if else</h3><p>if else 语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition</span><br><span class="line">then</span><br><span class="line">    command1 </span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">else</span><br><span class="line">    command</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><h3 id="if-else-if-else"><a class="markdownIt-Anchor" href="#if-else-if-else"></a> if else-if else</h3><p>if else-if else 语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">if condition1</span><br><span class="line">then</span><br><span class="line">    command1</span><br><span class="line">elif condition2 </span><br><span class="line">then </span><br><span class="line">    command2</span><br><span class="line">else</span><br><span class="line">    commandN</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>以下实例判断两个变量是否相等：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">a=10</span><br><span class="line">b=20</span><br><span class="line">if [ $a == $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 等于 b&quot;</span><br><span class="line">elif [ $a -gt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 大于 b&quot;</span><br><span class="line">elif [ $a -lt $b ]</span><br><span class="line">then</span><br><span class="line">   echo &quot;a 小于 b&quot;</span><br><span class="line">else</span><br><span class="line">   echo &quot;没有符合的条件&quot;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a 小于 b</span><br></pre></td></tr></table></figure><p>if else语句经常与test命令结合使用，如下所示：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">num1=$[2*3]</span><br><span class="line">num2=$[1+5]</span><br><span class="line">if test $[num1] -eq $[num2]</span><br><span class="line">then</span><br><span class="line">    echo &#x27;两个数字相等!&#x27;</span><br><span class="line">else</span><br><span class="line">    echo &#x27;两个数字不相等!&#x27;</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">两个数字相等!</span><br></pre></td></tr></table></figure><h2 id="2-for-循环"><a class="markdownIt-Anchor" href="#2-for-循环"></a> 2. for 循环</h2><p>与其他编程语言类似，Shell支持for循环。</p><p>for循环一般格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN</span><br><span class="line">do</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>写成一行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for var in item1 item2 ... itemN; do command1; command2… done;</span><br></pre></td></tr></table></figure><p>当变量值在列表里，for循环即执行一次所有命令，使用变量名获取列表中的当前取值。命令可为任何有效的shell命令和语句。in列表可以包含替换、字符串和文件名。</p><p>in列表是可选的，如果不用它，for循环使用命令行的位置参数。</p><p>例如，顺序输出当前列表中的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for loop in 1 2 3 4 5</span><br><span class="line">do</span><br><span class="line">    echo &quot;The value is: $loop&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">The value is: 1</span><br><span class="line">The value is: 2</span><br><span class="line">The value is: 3</span><br><span class="line">The value is: 4</span><br><span class="line">The value is: 5</span><br></pre></td></tr></table></figure><p>顺序输出字符串中的字符：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">for str in &#x27;This is a string&#x27;</span><br><span class="line">do</span><br><span class="line">    echo $str</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">This is a string</span><br></pre></td></tr></table></figure><h2 id="3-while-语句"><a class="markdownIt-Anchor" href="#3-while-语句"></a> 3. while 语句</h2><p>while循环用于不断执行一系列命令，也用于从输入文件中读取数据；命令通常为测试条件。其格式为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>以下是一个基本的while循环，测试条件是：如果int小于等于5，那么条件返回真。int从0开始，每次循环处理时，int加1。运行上述脚本，返回数字1到5，然后终止。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">int=1</span><br><span class="line">while(( $int&lt;=5 ))</span><br><span class="line">do</span><br><span class="line">    echo $int</span><br><span class="line">    let &quot;int++&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行脚本，输出：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>以上实例使用了 Bash let 命令，它用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量，具体可查阅：<a href="https://www.runoob.com/linux/linux-comm-let.html">Bash let 命令</a></p><p>。</p><p>while循环可用于读取键盘信息。下面的例子中，输入信息被设置为变量FILM，按<Ctrl-D>结束循环。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;按下 &lt;CTRL-D&gt; 退出&#x27;</span><br><span class="line">echo -n &#x27;输入你最喜欢的网站名: &#x27;</span><br><span class="line">while read FILM</span><br><span class="line">do</span><br><span class="line">    echo &quot;是的！$FILM 是一个好网站&quot;</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行脚本，输出类似下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">按下 &lt;CTRL-D&gt; 退出</span><br><span class="line">输入你最喜欢的网站名:菜鸟教程</span><br><span class="line">是的！菜鸟教程 是一个好网站</span><br></pre></td></tr></table></figure><h3 id="无限循环"><a class="markdownIt-Anchor" href="#无限循环"></a> 无限循环</h3><p>无限循环语法格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">while true</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>或者</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">for (( ; ; ))</span><br></pre></td></tr></table></figure><h2 id="4-until-循环"><a class="markdownIt-Anchor" href="#4-until-循环"></a> 4. until 循环</h2><p>until 循环执行一系列命令直至条件为 true 时停止。</p><p>until 循环与 while 循环在处理方式上刚好相反。</p><p>一般 while 循环优于 until 循环，但在某些时候—也只是极少数情况下，until 循环更加有用。</p><p>until 语法格式:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">until condition</span><br><span class="line">do</span><br><span class="line">    command</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>condition 一般为条件表达式，如果返回值为 false，则继续执行循环体内的语句，否则跳出循环。</p><p>以下实例我们使用 until 命令来输出 0 ~ 9 的数字：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">a=0</span><br><span class="line"></span><br><span class="line">until [ ! $a -lt 10 ]</span><br><span class="line">do</span><br><span class="line">   echo $a</span><br><span class="line">   a=`expr $a + 1`</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行结果：</p><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">0</span><br><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td></tr></table></figure><h2 id="5-case"><a class="markdownIt-Anchor" href="#5-case"></a> 5. case</h2><p>Shell case语句为多选择语句。可以用case语句匹配一个值与一个模式，如果匹配成功，执行相匹配的命令。case语句格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    ...</span><br><span class="line">    commandN</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>case工作方式如上所示。取值后面必须为单词in，每一模式必须以右括号结束。取值可以为变量或常数。匹配发现取值符合某一模式后，其间所有命令开始执行直至 ;;。</p><p>取值将检测匹配的每一个模式。一旦模式匹配，则执行完匹配模式相应命令后不再继续其他模式。如果无一匹配模式，使用星号 * 捕获该值，再执行后面的命令。</p><p>下面的脚本提示输入1到4，与每一种模式进行匹配：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">echo &#x27;输入 1 到 4 之间的数字:&#x27;</span><br><span class="line">echo &#x27;你输入的数字为:&#x27;</span><br><span class="line">read aNum</span><br><span class="line">case $aNum in</span><br><span class="line">    1)  echo &#x27;你选择了 1&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    2)  echo &#x27;你选择了 2&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    3)  echo &#x27;你选择了 3&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    4)  echo &#x27;你选择了 4&#x27;</span><br><span class="line">    ;;</span><br><span class="line">    *)  echo &#x27;你没有输入 1 到 4 之间的数字&#x27;</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>输入不同的内容，会有不同的结果，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入 1 到 4 之间的数字:</span><br><span class="line">你输入的数字为:</span><br><span class="line">3</span><br><span class="line">你选择了 3</span><br></pre></td></tr></table></figure><h2 id="6-跳出循环"><a class="markdownIt-Anchor" href="#6-跳出循环"></a> 6. 跳出循环</h2><p>在循环过程中，有时候需要在未达到循环结束条件时强制跳出循环，Shell使用两个命令来实现该功能：break和continue。</p><h3 id="break命令"><a class="markdownIt-Anchor" href="#break命令"></a> break命令</h3><p>break命令允许跳出所有循环（终止执行后面的所有循环）。</p><p>下面的例子中，脚本进入死循环直至用户输入数字大于5。要跳出这个循环，返回到shell提示符下，需要使用break命令。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字:&quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的! 游戏结束&quot;</span><br><span class="line">            break</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>执行以上代码，输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入 1 到 5 之间的数字:3</span><br><span class="line">你输入的数字为 3!</span><br><span class="line">输入 1 到 5 之间的数字:7</span><br><span class="line">你输入的数字不是 1 到 5 之间的! 游戏结束</span><br></pre></td></tr></table></figure><h3 id="continue"><a class="markdownIt-Anchor" href="#continue"></a> continue</h3><p>continue命令与break命令类似，只有一点差别，它不会跳出所有循环，仅仅跳出当前循环。</p><p>对上面的例子进行修改：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">while :</span><br><span class="line">do</span><br><span class="line">    echo -n &quot;输入 1 到 5 之间的数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    case $aNum in</span><br><span class="line">        1|2|3|4|5) echo &quot;你输入的数字为 $aNum!&quot;</span><br><span class="line">        ;;</span><br><span class="line">        *) echo &quot;你输入的数字不是 1 到 5 之间的!&quot;</span><br><span class="line">            continue</span><br><span class="line">            echo &quot;游戏结束&quot;</span><br><span class="line">        ;;</span><br><span class="line">    esac</span><br><span class="line">done</span><br></pre></td></tr></table></figure><p>运行代码发现，当输入大于5的数字时，该例中的循环不会结束，语句 <strong>echo “游戏结束”</strong> 永远不会被执行。</p><h2 id="7-case-esac"><a class="markdownIt-Anchor" href="#7-case-esac"></a> 7. case … esac</h2><p><strong>case … esac</strong> 与其他语言中的 switch … case 语句类似，是一种多分枝选择结构，每个 case 分支用右圆括号开始，用两个分号 <strong>;;</strong> 表示 break，即执行结束，跳出整个 case … esac 语句，esac（就是 case 反过来）作为结束标记。</p><p>case … esac 语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">case 值 in</span><br><span class="line">模式1)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">模式2）</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">*)</span><br><span class="line">    command1</span><br><span class="line">    command2</span><br><span class="line">    command3</span><br><span class="line">    ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>case 后为取值，值可以为变量或常数。</p><p>值后为关键字 in，接下来是匹配的各种模式，每一模式最后必须以右括号结束，模式支持正则表达式。</p><h3 id="实例-8"><a class="markdownIt-Anchor" href="#实例-8"></a> 实例</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#!/bin/sh</span><br><span class="line"></span><br><span class="line">site=&quot;runoob&quot;</span><br><span class="line"></span><br><span class="line">**case** &quot;$site&quot; in</span><br><span class="line">  &quot;runoob&quot;) echo &quot;菜鸟教程&quot;</span><br><span class="line">  ;;</span><br><span class="line">  &quot;google&quot;) echo &quot;Google 搜索&quot;</span><br><span class="line">  ;;</span><br><span class="line">  &quot;taobao&quot;) echo &quot;淘宝网&quot;</span><br><span class="line">  ;;</span><br><span class="line">esac</span><br></pre></td></tr></table></figure><p>输出结果为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">菜鸟教程</span><br></pre></td></tr></table></figure><h2 id="note-8"><a class="markdownIt-Anchor" href="#note-8"></a> Note</h2><h3 id="1-4"><a class="markdownIt-Anchor" href="#1-4"></a> 1.</h3><p>shell 中的 for 循环不仅可以用文章所述的方法。</p><p>对于习惯其他语言 for 循环的朋友来说可能有点别扭。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">for((assignment;condition:next));do</span><br><span class="line">    command_1;</span><br><span class="line">    command_2;</span><br><span class="line">    commond_..;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><p>如上所示，这里的 for 循环与 C 中的相似，但并不完全相同。</p><p>通常情况下 shell 变量调用需要加 <code>$</code>,但是 for 的 (()) 中不需要,下面来看一个例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">for((i=1;i&lt;=5;i++));do</span><br><span class="line">    echo &quot;这是第 $i 次调用&quot;;</span><br><span class="line">done;</span><br></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">这是第1次调用</span><br><span class="line">这是第2次调用</span><br><span class="line">这是第3次调用</span><br><span class="line">这是第4次调用</span><br><span class="line">这是第5次调用</span><br></pre></td></tr></table></figure><p>与 C 中相似，赋值和下一步执行可以放到代码之前循环语句之中执行，这里要注意一点：如果要在循环体中进行 for 中的 next 操作，记得变量要加 <code>$</code>，不然程序会变成死循环。</p><h1 id="10-shell-函数"><a class="markdownIt-Anchor" href="#10-shell-函数"></a> 10. Shell 函数</h1><p>linux shell 可以用户定义函数，然后在shell脚本中可以随便调用。</p><p>shell中函数的定义格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[ function ] funname [()]</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line"></span><br><span class="line">    action;</span><br><span class="line"></span><br><span class="line">    [return int;]</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：</p><ul><li>1、可以带function fun() 定义，也可以直接fun() 定义,不带任何参数。</li><li>2、参数返回，可以显示加：return 返回，如果不加，将以最后一条命令运行结果，作为返回值。 return后跟数值n(0-255</li></ul><p>下面的例子定义了一个函数并进行调用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">demoFun()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">&#125;</span><br><span class="line">echo &quot;-----函数开始执行-----&quot;</span><br><span class="line">demoFun</span><br><span class="line">echo &quot;-----函数执行完毕-----&quot;</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">-----函数开始执行-----</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">-----函数执行完毕-----</span><br></pre></td></tr></table></figure><p>下面定义一个带有return语句的函数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">funWithReturn()&#123;</span><br><span class="line">    echo &quot;这个函数会对输入的两个数字进行相加运算...&quot;</span><br><span class="line">    echo &quot;输入第一个数字: &quot;</span><br><span class="line">    read aNum</span><br><span class="line">    echo &quot;输入第二个数字: &quot;</span><br><span class="line">    read anotherNum</span><br><span class="line">    echo &quot;两个数字分别为 $aNum 和 $anotherNum !&quot;</span><br><span class="line">    return $(($aNum+$anotherNum))</span><br><span class="line">&#125;</span><br><span class="line">funWithReturn</span><br><span class="line">echo &quot;输入的两个数字之和为 $? !&quot;</span><br></pre></td></tr></table></figure><p>输出类似下面：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">这个函数会对输入的两个数字进行相加运算...</span><br><span class="line">输入第一个数字: </span><br><span class="line">1</span><br><span class="line">输入第二个数字: </span><br><span class="line">2</span><br><span class="line">两个数字分别为 1 和 2 !</span><br><span class="line">输入的两个数字之和为 3 !</span><br></pre></td></tr></table></figure><p>函数返回值在调用该函数后通过 <code>$?</code> 来获得。</p><p>注意：所有函数在使用前必须定义。这意味着必须将函数放在脚本开始部分，直至shell解释器首次发现它时，才可以使用。调用函数仅使用其函数名即可。</p><h2 id="函数参数"><a class="markdownIt-Anchor" href="#函数参数"></a> 函数参数</h2><p>在Shell中，调用函数时可以向其传递参数。在函数体内部，通过 <code>$n</code> 的形式来获取参数的值，例如，<code>$1</code>表示第一个参数，<code>$2</code>表示第二个参数…</p><p>带参数的函数示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:</span></span><br><span class="line"></span><br><span class="line">funWithParam()&#123;</span><br><span class="line">    echo &quot;第一个参数为 $1 !&quot;</span><br><span class="line">    echo &quot;第二个参数为 $2 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $10 !&quot;</span><br><span class="line">    echo &quot;第十个参数为 $&#123;10&#125; !&quot;</span><br><span class="line">    echo &quot;第十一个参数为 $&#123;11&#125; !&quot;</span><br><span class="line">    echo &quot;参数总数有 $# 个!&quot;</span><br><span class="line">    echo &quot;作为一个字符串输出所有参数 $* !&quot;</span><br><span class="line">&#125;</span><br><span class="line">funWithParam 1 2 3 4 5 6 7 8 9 34 73</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">第一个参数为 1 !</span><br><span class="line">第二个参数为 2 !</span><br><span class="line">第十个参数为 10 !</span><br><span class="line">第十个参数为 34 !</span><br><span class="line">第十一个参数为 73 !</span><br><span class="line">参数总数有 11 个!</span><br><span class="line">作为一个字符串输出所有参数 1 2 3 4 5 6 7 8 9 34 73 !</span><br></pre></td></tr></table></figure><p>注意，<code>$10</code> 不能获取第十个参数，获取第十个参数需要<code>$&#123;10&#125;</code>。当n&gt;=10时，需要使用<code>$&#123;n&#125;</code>来获取参数。</p><p>另外，还有几个特殊字符用来处理参数：</p><table><thead><tr><th style="text-align:left">参数处理</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left"><code>$#</code></td><td style="text-align:left">传递到脚本或函数的参数个数</td></tr><tr><td style="text-align:left"><code>$*</code></td><td style="text-align:left">以一个单字符串显示所有向脚本传递的参数</td></tr><tr><td style="text-align:left"><code>$$</code></td><td style="text-align:left">脚本运行的当前进程ID号</td></tr><tr><td style="text-align:left"><code>$!</code></td><td style="text-align:left">后台运行的最后一个进程的ID号</td></tr><tr><td style="text-align:left"><code>$@</code></td><td style="text-align:left">与<code>$*</code>相同，但是使用时加引号，并在引号中返回每个参数。</td></tr><tr><td style="text-align:left"><code>$-</code></td><td style="text-align:left">显示Shell使用的当前选项，与set命令功能相同。</td></tr><tr><td style="text-align:left"><code>$?</code></td><td style="text-align:left">显示最后命令的退出状态。0表示没有错误，其他任何值表明有错误。</td></tr></tbody></table><h2 id="note-9"><a class="markdownIt-Anchor" href="#note-9"></a> Note</h2><h3 id="1-5"><a class="markdownIt-Anchor" href="#1-5"></a> 1.</h3><p><strong><code>$?</code></strong> 仅对其上一条指令负责，一旦函数返回后其返回值没有立即保存入参数，那么其返回值将不再能通过 <strong><code>$?</code></strong> 获得。</p><p>测试代码：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line">function demoFun1()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">    return `expr 1 + 1`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demoFun1</span><br><span class="line">echo $?</span><br><span class="line"></span><br><span class="line">function demoFun2()&#123;</span><br><span class="line"> echo &quot;这是我的第二个 shell 函数!&quot;</span><br><span class="line"> expr 1 + 1</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demoFun2</span><br><span class="line">echo $?</span><br><span class="line">demoFun1</span><br><span class="line">echo 在这里插入命令！</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">2</span><br><span class="line">这是我的第二个 shell 函数!</span><br><span class="line">2</span><br><span class="line">0</span><br><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">在这里插入命令！</span><br><span class="line">0</span><br></pre></td></tr></table></figure><p>调用 demoFun2 后，函数最后一条命令 expr 1 + 1 得到的返回值（$?值）为 0，意思是这个命令没有出错。所有的命令的返回值仅表示其是否出错，而不会有其他有含义的结果。</p><p>第二次调用 demoFun1 后，没有立即查看 $? 的值，而是先插入了一条别的 echo 命令，最后再查看 $? 的值得到的是 0，也就是上一条 echo 命令的结果，而 demoFun1 的返回值被覆盖了。</p><p>下面这个测试，连续使用两次 <strong>echo $?</strong>，得到的结果不同，更为直观：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">function demoFun1()&#123;</span><br><span class="line">    echo &quot;这是我的第一个 shell 函数!&quot;</span><br><span class="line">    return `expr 1 + 1`</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">demoFun1</span><br><span class="line">echo $?</span><br><span class="line">echo $?</span><br></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">这是我的第一个 shell 函数!</span><br><span class="line">2</span><br><span class="line">0</span><br></pre></td></tr></table></figure><h3 id="2-4"><a class="markdownIt-Anchor" href="#2-4"></a> 2.</h3><p>函数与命令的执行结果可以作为条件语句使用。要注意的是，和 C 语言不同，shell 语言中 0 代表 true，0 以外的值代表 false。</p><p>请参见下例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">echo &quot;Hello World !&quot; | grep -e Hello</span><br><span class="line">echo $?</span><br><span class="line">echo &quot;Hello World !&quot; | grep -e Bye</span><br><span class="line">echo $?</span><br><span class="line">if echo &quot;Hello World !&quot; | grep -e Hello</span><br><span class="line">then</span><br><span class="line">    echo true</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if echo &quot;Hello World !&quot; | grep -e Bye</span><br><span class="line">then</span><br><span class="line">    echo true</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">function demoFun1()&#123;</span><br><span class="line">    return 0</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function demoFun2()&#123;</span><br><span class="line">    return 12</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">if demoFun1</span><br><span class="line">then</span><br><span class="line">    echo true</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">if demoFun2</span><br><span class="line">then</span><br><span class="line">    echo ture</span><br><span class="line">else</span><br><span class="line">    echo false</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><p>其执行结果如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Hello World !</span><br><span class="line">0</span><br><span class="line">1</span><br><span class="line">Hello World !</span><br><span class="line">true</span><br><span class="line">false</span><br><span class="line">true</span><br><span class="line">false</span><br></pre></td></tr></table></figure><p>grep 是从给定字符串中寻找匹配内容的命令。首先看出如果找到了匹配的内容，会打印匹配部分且得到的返回值 $? 为 0，如果找不到，则返回值 $? 为 1。</p><p>接下来分别将这两次执行的 grep 命令当作条件语句交给 if 判断，得出返回值 $? 为 0，即执行成功时，条件语句为 true，当返回值 $? 为 1，即执行失败时，条件语句为 false。</p><p>之后再用函数的 return 值作为测试，其中 demoFun1 返回值为 0，demoFun2 返回值选择了任意一个和 0 不同的整数，这里为 12。</p><p>将函数作为条件语句交给 if 判断，得出返回值为 0 时，依然为 true，而返回值只要不是 0，条件语句都判断为 false。</p><h1 id="11-shell-输入输出重定向"><a class="markdownIt-Anchor" href="#11-shell-输入输出重定向"></a> 11. Shell 输入/输出重定向</h1><p>大多数 UNIX 系统命令从你的终端接受输入并将所产生的输出发送回到您的终端。一个命令通常从一个叫标准输入的地方读取输入，默认情况下，这恰好是你的终端。同样，一个命令通常将其输出写入到标准输出，默认情况下，这也是你的终端。</p><p>重定向命令列表如下：</p><table><thead><tr><th style="text-align:left">命令</th><th style="text-align:left">说明</th></tr></thead><tbody><tr><td style="text-align:left">command &gt; file</td><td style="text-align:left">将输出重定向到 file。</td></tr><tr><td style="text-align:left">command &lt; file</td><td style="text-align:left">将输入重定向到 file。</td></tr><tr><td style="text-align:left">command &gt;&gt; file</td><td style="text-align:left">将输出以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt; file</td><td style="text-align:left">将文件描述符为 n 的文件重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&gt; file</td><td style="text-align:left">将文件描述符为 n 的文件以追加的方式重定向到 file。</td></tr><tr><td style="text-align:left">n &gt;&amp; m</td><td style="text-align:left">将输出文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">n &lt;&amp; m</td><td style="text-align:left">将输入文件 m 和 n 合并。</td></tr><tr><td style="text-align:left">&lt;&lt; tag</td><td style="text-align:left">将开始标记 tag 和结束标记 tag 之间的内容作为输入。</td></tr></tbody></table><blockquote><p>需要注意的是文件描述符 0 通常是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p></blockquote><h2 id="输出重定向"><a class="markdownIt-Anchor" href="#输出重定向"></a> 输出重定向</h2><p>重定向一般通过在命令间插入特定的符号来实现。特别的，这些符号的语法如下所示:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &gt; file1</span><br></pre></td></tr></table></figure><p>上面这个命令执行command1然后将输出的内容存入file1。</p><p>注意任何file1内的已经存在的内容将被新内容替代。如果要将新内容添加在文件末尾，请使用&gt;&gt;操作符。</p><h3 id="实例-9"><a class="markdownIt-Anchor" href="#实例-9"></a> 实例</h3><p>执行下面的 who 命令，它将命令的完整的输出重定向在用户文件中(users):</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> who &gt; users</span></span><br></pre></td></tr></table></figure><p>执行后，并没有在终端输出信息，这是因为输出已被从默认的标准输出设备（终端）重定向到指定的文件。</p><p>你可以使用 cat 命令查看文件内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> cat users</span></span><br><span class="line">_mbsetupuser console  Oct 31 17:35 </span><br><span class="line">tianqixin    console  Oct 31 17:35 </span><br><span class="line">tianqixin    ttys000  Dec  1 11:33 </span><br></pre></td></tr></table></figure><p>输出重定向会覆盖文件内容，请看下面的例子：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;菜鸟教程：www.runoob.com&quot;</span> &gt; users</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat users</span></span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>如果不希望文件内容被覆盖，可以使用 &gt;&gt; 追加到文件末尾，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">echo</span> <span class="string">&quot;菜鸟教程：www.runoob.com&quot;</span> &gt;&gt; users</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cat users</span></span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line">菜鸟教程：www.runoob.com</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><h2 id="输入重定向"><a class="markdownIt-Anchor" href="#输入重定向"></a> 输入重定向</h2><p>和输出重定向一样，Unix 命令也可以从文件获取输入，语法为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; file1</span><br></pre></td></tr></table></figure><p>这样，本来需要从键盘获取输入的命令会转移到文件读取内容。</p><p>注意：输出重定向是大于号(&gt;)，输入重定向是小于号(&lt;)。</p><h3 id="实例-10"><a class="markdownIt-Anchor" href="#实例-10"></a> 实例</h3><p>接着以上实例，我们需要统计 users 文件的行数,执行以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l users</span></span><br><span class="line">       2 users</span><br></pre></td></tr></table></figure><p>也可以将输入重定向到 users 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash">  wc -l &lt; users</span></span><br><span class="line">       2 </span><br></pre></td></tr></table></figure><p>注意：上面两个例子的结果不同：第一个例子，会输出文件名；第二个不会，因为它仅仅知道从标准输入读取内容。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">command1 &lt; infile &gt; outfile</span><br></pre></td></tr></table></figure><p>同时替换输入和输出，执行command1，从文件infile读取内容，然后将输出写入到outfile中。</p><h2 id="重定向深入讲解"><a class="markdownIt-Anchor" href="#重定向深入讲解"></a> 重定向深入讲解</h2><p>一般情况下，每个 Unix/Linux 命令运行时都会打开三个文件：</p><ul><li>标准输入文件(stdin)：stdin的文件描述符为0，Unix程序默认从stdin读取数据。</li><li>标准输出文件(stdout)：stdout 的文件描述符为1，Unix程序默认向stdout输出数据。</li><li>标准错误文件(stderr)：stderr的文件描述符为2，Unix程序会向stderr流中写入错误信息。</li></ul><p>默认情况下，command &gt; file 将 stdout 重定向到 file，command &lt; file 将stdin 重定向到 file。</p><p>如果希望 stderr 重定向到 file，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> 2 &gt; file</span></span><br></pre></td></tr></table></figure><p>如果希望 stderr 追加到 file 文件末尾，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> 2 &gt;&gt; file</span></span><br></pre></td></tr></table></figure><p><strong>2</strong> 表示标准错误文件(stderr)。</p><p>如果希望将 stdout 和 stderr 合并后重定向到 file，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; file 2&gt;&amp;1</span></span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt;&gt; file 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><p>如果希望对 stdin 和 stdout 都重定向，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &lt; file1 &gt;file2</span></span><br></pre></td></tr></table></figure><p>command 命令将 stdin 重定向到 file1，将 stdout 重定向到 file2。</p><h2 id="here-document"><a class="markdownIt-Anchor" href="#here-document"></a> Here Document</h2><p>Here Document 是 Shell 中的一种特殊的重定向方式，用来将输入重定向到一个交互式 Shell 脚本或程序。</p><p>它的基本的形式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">command &lt;&lt; delimiter</span><br><span class="line">    document</span><br><span class="line">delimiter</span><br></pre></td></tr></table></figure><p>它的作用是将两个 delimiter 之间的内容(document) 作为输入传递给 command。</p><blockquote><p>注意：</p><ul><li>结尾的delimiter 一定要顶格写，前面不能有任何字符，后面也不能有任何字符，包括空格和 tab 缩进。</li><li>开始的delimiter前后的空格会被忽略掉。</li></ul></blockquote><h3 id="实例-11"><a class="markdownIt-Anchor" href="#实例-11"></a> 实例</h3><p>在命令行中通过 wc -l 命令计算 Here Document 的行数：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> wc -l &lt;&lt; <span class="string">EOF</span></span></span><br><span class="line">    欢迎来到</span><br><span class="line">    菜鸟教程</span><br><span class="line">    www.runoob.com</span><br><span class="line">EOF</span><br><span class="line">3          # 输出结果为 3 行</span><br><span class="line"><span class="meta">$</span></span><br></pre></td></tr></table></figure><p>我们也可以将 Here Document 用在脚本中，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:菜鸟教程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">cat &lt;&lt; EOF</span><br><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure><p>执行以上脚本，输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">欢迎来到</span><br><span class="line">菜鸟教程</span><br><span class="line">www.runoob.com</span><br></pre></td></tr></table></figure><h2 id="devnull-文件"><a class="markdownIt-Anchor" href="#devnull-文件"></a> /dev/null 文件</h2><p>如果希望执行某个命令，但又不希望在屏幕上显示输出结果，那么可以将输出重定向到 /dev/null：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null</span></span><br></pre></td></tr></table></figure><p>/dev/null 是一个特殊的文件，写入到它的内容都会被丢弃；如果尝试从该文件读取内容，那么什么也读不到。但是 /dev/null 文件非常有用，将命令的输出重定向到它，会起到&quot;禁止输出&quot;的效果。</p><p>如果希望屏蔽 stdout 和 stderr，可以这样写：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; /dev/null 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><blockquote><p>**注意：**0 是标准输入（STDIN），1 是标准输出（STDOUT），2 是标准错误输出（STDERR）。</p></blockquote><h2 id="note-10"><a class="markdownIt-Anchor" href="#note-10"></a> Note</h2><h3 id="1-6"><a class="markdownIt-Anchor" href="#1-6"></a> 1.</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt; file 2&gt;&amp;1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> <span class="built_in">command</span> &gt;&gt; file 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><p>这里的**&amp;**没有固定的意思</p><p>放在**&gt;<strong>后面的</strong>&amp;<strong>，表示重定向的目标不是一个</strong>文件**，而是一个<strong>文件描述符</strong>，内置的文件描述符如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1 =&gt; stdout</span><br><span class="line">2 =&gt; stderr</span><br><span class="line">0 =&gt; stdin</span><br></pre></td></tr></table></figure><p>换言之 <strong>2&gt;1</strong> 代表将<strong>stderr</strong>重定向到当前路径下文件名为<strong>1</strong>的<strong>regular file</strong>中，而<strong>2&gt;&amp;1</strong>代表将<strong>stderr</strong>重定向到<strong>文件描述符</strong>为<strong>1</strong>的文件(即**/dev/stdout**)中，这个文件就是<strong>stdout</strong>在<strong>file system</strong>中的映射</p><p>而**&amp;&gt;file<strong>是一种特殊的用法，也可以写成</strong>&gt;&amp;file**，二者的意思完全相同，都等价于</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash">file 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><p>此处**&amp;&gt;<strong>或者</strong>&gt;&amp;**视作整体，分开没有单独的含义</p><p><strong>顺序问题：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">find /etc -name .bashrc &gt; list 2&gt;&amp;1</span><br><span class="line"><span class="meta">#</span><span class="bash"> 我想问为什么不能调下顺序,比如这样</span></span><br><span class="line">find /etc -name .bashrc 2&gt;&amp;1 &gt; list</span><br></pre></td></tr></table></figure><p>这个是从左到右有顺序的</p><p>第一种</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx &gt; list 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>先将要输出到<strong>stdout</strong>的内容重定向到文件，此时文件<strong>list</strong>就是这个程序的<strong>stdout</strong>，再将<strong>stderr</strong>重定向到<strong>stdout</strong>，也就是文件<strong>list</strong></p><p>第二种</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">xxx 2&gt;&amp;1 &gt; list</span><br></pre></td></tr></table></figure><p>先将要输出到<strong>stderr</strong>的内容重定向到<strong>stdout</strong>，此时会产生一个<strong>stdout的拷贝</strong>，作为程序的<strong>stderr</strong>，而程序原本要输出到<strong>stdout</strong>的内容，依然是对接在<strong>stdout原身</strong>上的，因此第二步重定向<strong>stdout</strong>，对<strong>stdout的拷贝</strong>不产生任何影响</p><h3 id="2-5"><a class="markdownIt-Anchor" href="#2-5"></a> 2.</h3><p>对于上面 ‘2&gt;&amp;1’，举个例子，比如说:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> find /etc -names <span class="string">&quot;*.txt&quot;</span>  &gt;list 2&gt;&amp;1</span></span><br></pre></td></tr></table></figure><p>从左往右执行，执行到 &gt;list，此时的 stdout 为 list；而执行到 2&gt;&amp;1，表示 stderr 重定向到 stdout，这里也就是 list 文件。</p><p>因为 <strong>[ find /etc -names “*.txt” ]</strong> 这条命令是错误的( -names 应该是 -name)。</p><p>本来要输出到终端屏幕的错误信息:</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find: unknown predicate `-names`</span><br></pre></td></tr></table></figure><p>被重定向到了 stdout 也就是 list 文件中，所以屏幕不会出现错误信息，而是打印到了 list 文件中。</p><p><strong>cat list</strong> 可以查看到 find: unknown predicate `-names’ 就在里面。</p><h3 id="3-5"><a class="markdownIt-Anchor" href="#3-5"></a> 3.</h3><p>直接在 FreeBSD 或者 csh 中使用 <strong>command &gt; file 2&gt;&amp;1</strong> 时候会得到这个错误：<strong>Ambiguous output redirect</strong>。</p><p>出错的原因在于 FreeBSD 默认使用 csh，在 csh 中如果想把标准输出和错误输出同时重定向到一个文件，需要用下面命令 <strong>command &gt;&amp; file</strong>。</p><h1 id="12-shell-文件包含"><a class="markdownIt-Anchor" href="#12-shell-文件包含"></a> 12. Shell 文件包含</h1><p>和其他语言一样，Shell 也可以包含外部脚本。这样可以很方便的封装一些公用的代码作为一个独立的文件。</p><p>Shell 文件包含的语法格式如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">. filename   # 注意点号(.)和文件名中间有一空格</span><br><span class="line"></span><br><span class="line">或</span><br><span class="line"></span><br><span class="line">source filename</span><br></pre></td></tr></table></figure><h3 id="实例-12"><a class="markdownIt-Anchor" href="#实例-12"></a> 实例</h3><p>创建两个 shell 脚本文件。</p><p><a href="http://test1.sh">test1.sh</a> 代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:菜鸟教程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:www.runoob.com</span></span><br><span class="line"></span><br><span class="line">url=&quot;http://www.runoob.com&quot;</span><br></pre></td></tr></table></figure><p><a href="http://test2.sh">test2.sh</a> 代码如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> author:菜鸟教程</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> url:www.runoob.com</span></span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash">使用 . 号来引用test1.sh 文件</span></span><br><span class="line">. ./test1.sh</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者使用以下包含文件代码</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">source</span> ./test1.sh</span></span><br><span class="line"></span><br><span class="line">echo &quot;菜鸟教程官网地址：$url&quot;</span><br></pre></td></tr></table></figure><p>接下来，我们为 <a href="http://test2.sh">test2.sh</a> 添加可执行权限并执行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> chmod +x test2.sh</span> </span><br><span class="line"><span class="meta">$</span><span class="bash"> ./test2.sh</span> </span><br><span class="line">菜鸟教程官网地址：http://www.runoob.com</span><br></pre></td></tr></table></figure><blockquote><p>**注：**被包含的文件 <a href="http://test1.sh">test1.sh</a> 不需要可执行权限。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode快捷键</title>
      <link href="/posts/62e79da4.html"/>
      <url>/posts/62e79da4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-个人自定义使用快捷键"><a class="markdownIt-Anchor" href="#1-个人自定义使用快捷键"></a> 1. 个人自定义使用快捷键</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>ctrl + k,ctrl + j</td><td>打开所有的折叠栏(folds)</td></tr><tr><td>ctrl + k,ctrl + o</td><td>折叠起所有的折叠栏(folds)</td></tr><tr><td>alt</td><td>多指针操作,插入光标</td></tr><tr><td>alt + shift + 鼠标光标点击</td><td>在两个光标间所有行的垂直方向插入光标</td></tr><tr><td>ctrl + alt + Up/Dowm</td><td>向上向下插入光标</td></tr><tr><td>alt + Up/Dowm</td><td>上下移动现在光标做在的整行</td></tr><tr><td>shift + alt + Up/Dowm</td><td>向上向下复制行</td></tr><tr><td>Shift + alt + f</td><td>格式化文档</td></tr><tr><td>F2</td><td>Go to definition</td></tr><tr><td>alt + F2</td><td>peek definition</td></tr><tr><td>shift + F2</td><td>Go to declaration(声明)</td></tr><tr><td>ctrl + alt + F2</td><td>Peek declaration(声明)</td></tr><tr><td>ctrl + Enter</td><td>在下插入行</td></tr><tr><td>ctrl + Up/Dowm</td><td>上下滚动行</td></tr><tr><td>ctrl + i</td><td>选择当前行</td></tr><tr><td>ctrl + shift + l</td><td>选择当前选择的所有出现</td></tr><tr><td>ctrl + F3</td><td>选择当前字的下一个的出现位置</td></tr><tr><td>ctrl + 2</td><td>选择当前字的所有出现</td></tr><tr><td>ctrl + Space</td><td>触发建议</td></tr><tr><td>ctrl + shift + Space</td><td>触发器参数提示</td></tr><tr><td>ctrl + alt + i</td><td>文件头注释</td></tr><tr><td>alt + i</td><td>函数注释</td></tr><tr><td>shift + Enter</td><td>Auto Comment Blocks</td></tr><tr><td>ctrl + alt + a/ctrl + alt + =</td><td>comments aligh</td></tr><tr><td>alt + a</td><td>cursor aligh</td></tr></tbody></table><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + Shift + P，F1</td><td>显示命令面板 Show Command Palette</td></tr><tr><td>Ctrl + P</td><td>快速打开 Quick Open</td></tr><tr><td>Ctrl + Shift + N</td><td>新窗口/实例 New window/instance</td></tr><tr><td>Ctrl + Shift + W</td><td>关闭窗口/实例 Close window/instance</td></tr></tbody></table><h1 id="2-基础编辑-basic-editing"><a class="markdownIt-Anchor" href="#2-基础编辑-basic-editing"></a> 2. 基础编辑 Basic editing</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+X</td><td>剪切行（空选定） Cut line (empty selection)</td></tr><tr><td>Ctrl+C</td><td>复制行（空选定）Copy line (empty selection)</td></tr><tr><td>Alt+ ↑ / ↓</td><td>向上/向下移动行 Move line up/down</td></tr><tr><td>Shift+Alt + ↓ / ↑</td><td>向上/向下复制行 Copy line up/down</td></tr><tr><td>Ctrl+Shift+K</td><td>删除行 Delete line</td></tr><tr><td>Ctrl+Enter</td><td>在下面插入行 Insert line below</td></tr><tr><td>Ctrl+Shift+Enter</td><td>在上面插入行 Insert line above</td></tr><tr><td>Ctrl+Shift+\</td><td>跳到匹配的括号 Jump to matching bracket</td></tr><tr><td>Ctrl+] / [</td><td>缩进/缩进行 Indent/outdent line</td></tr><tr><td>Home</td><td>转到行首 Go to beginning of line</td></tr><tr><td>End</td><td>转到行尾 Go to end of line</td></tr><tr><td>Ctrl+Home</td><td>转到文件开头 Go to beginning of file</td></tr><tr><td>Ctrl+End</td><td>转到文件末尾 Go to end of file</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上/向下滚动行 Scroll line up/down</td></tr><tr><td>Alt+PgUp / PgDown</td><td>向上/向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Shift+[</td><td>折叠（折叠）区域 Fold (collapse) region</td></tr><tr><td>Ctrl+Shift+]</td><td>展开（未折叠）区域 Unfold (uncollapse) region</td></tr><tr><td>Ctrl+K Ctrl+[</td><td>折叠（未折叠）所有子区域 Fold (collapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+]</td><td>展开（未折叠）所有子区域 Unfold (uncollapse) all subregions</td></tr><tr><td>Ctrl+K Ctrl+0</td><td>折叠（折叠）所有区域 Fold (collapse) all regions</td></tr><tr><td>n</td><td>展开（未折叠）所有区域 Unfold (uncollapse) all regions</td></tr><tr><td>Ctrl+K Ctrl+C</td><td>添加行注释 Add line comment</td></tr><tr><td>Ctrl+K Ctrl+U</td><td>删除行注释 Remove line comment</td></tr><tr><td>Ctrl+/</td><td>切换行注释 Toggle line comment</td></tr><tr><td>Shift+Alt+A</td><td>切换块注释 Toggle block comment</td></tr><tr><td>Alt+Z</td><td>切换换行 Toggle word wrap</td></tr></tbody></table><h1 id="3-导航-navigation"><a class="markdownIt-Anchor" href="#3-导航-navigation"></a> 3. 导航 Navigation</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + T</td><td>显示所有符号 Show all Symbols</td></tr><tr><td>Ctrl + G</td><td>转到行… Go to Line…</td></tr><tr><td>Ctrl + P</td><td>转到文件… Go to File…</td></tr><tr><td>Ctrl + Shift + O</td><td>转到符号… Go to Symbol…</td></tr><tr><td>Ctrl + Shift + M</td><td>显示问题面板 Show Problems panel</td></tr><tr><td>F8</td><td>转到下一个错误或警告 Go to next error or warning</td></tr><tr><td>Shift + F8</td><td>转到上一个错误或警告 Go to previous error or warning</td></tr><tr><td>Ctrl + Shift + Tab</td><td>导航编辑器组历史记录 Navigate editor group history</td></tr><tr><td>Alt + ←/→</td><td>返回/前进 Go back / forward</td></tr><tr><td>Ctrl + M</td><td>切换选项卡移动焦点 Toggle Tab moves focus</td></tr></tbody></table><h1 id="4-搜索和替换-search-and-replace"><a class="markdownIt-Anchor" href="#4-搜索和替换-search-and-replace"></a> 4. 搜索和替换 Search and replace</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + F</td><td>查找 Find</td></tr><tr><td>Ctrl + H</td><td>替换 Replace</td></tr><tr><td>F3 / Shift + F3</td><td>查找下一个/上一个 Find next/previous</td></tr><tr><td>Alt + Enter</td><td>选择查找匹配的所有出现 Select all occurences of Find match</td></tr><tr><td>Ctrl + D</td><td>将选择添加到下一个查找匹配 Add selection to next Find match</td></tr><tr><td>Ctrl + K Ctrl + D</td><td>将最后一个选择移至下一个查找匹配项 Move last selection to next Find match</td></tr><tr><td>Alt + C / R / W</td><td>切换区分大小写/正则表达式/整个词 Toggle case-sensitive / regex / whole word</td></tr></tbody></table><h1 id="5-多光标和选择-multi-cursor-and-selection"><a class="markdownIt-Anchor" href="#5-多光标和选择-multi-cursor-and-selection"></a> 5. 多光标和选择 Multi-cursor and selection</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Alt +单击</td><td>插入光标 Insert cursor</td></tr><tr><td>Ctrl + Alt +↑/↓</td><td>在上/下插入光标 Insert cursor above / below</td></tr><tr><td>Ctrl + U</td><td>撤消上一个光标操作 Undo last cursor operation</td></tr><tr><td>Shift + Alt + I</td><td>在选定的每一行的末尾插入光标 Insert cursor at end of each line selected</td></tr><tr><td>Ctrl + I</td><td>选择当前行 Select current line</td></tr><tr><td>Ctrl + Shift + L</td><td>选择当前选择的所有出现 Select all occurrences of current selection</td></tr><tr><td>Ctrl + F2</td><td>选择当前字的所有出现 Select all occurrences of current word</td></tr><tr><td>Shift + Alt + →</td><td>展开选择 Expand selection</td></tr><tr><td>Shift + Alt + ←</td><td>缩小选择 Shrink selection</td></tr><tr><td>Shift + Alt + （拖动鼠标）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt +（箭头键）</td><td>列（框）选择 Column (box) selection</td></tr><tr><td>Ctrl + Shift + Alt + PgUp / PgDown</td><td>列（框）选择页上/下 Column (box) selection page up/down</td></tr></tbody></table><h1 id="6-丰富的语言编辑-rich-languages-editing"><a class="markdownIt-Anchor" href="#6-丰富的语言编辑-rich-languages-editing"></a> 6. 丰富的语言编辑 Rich languages editing</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl + 空格</td><td>触发建议 Trigger suggestion</td></tr><tr><td>Ctrl + Shift + Space</td><td>触发器参数提示 Trigger parameter hints</td></tr><tr><td>Tab</td><td>Emmet 展开缩写 Emmet expand abbreviation</td></tr><tr><td>Shift + Alt + F</td><td>格式化文档 Format document</td></tr><tr><td>Ctrl + K Ctrl + F</td><td>格式选定区域 Format selection</td></tr><tr><td>F12</td><td>转到定义 Go to Definition</td></tr><tr><td>Alt + F12</td><td>Peek定义 Peek Definition</td></tr><tr><td>Ctrl + K F12</td><td>打开定义到边 Open Definition to the side</td></tr><tr><td>Ctrl + .</td><td>快速解决 Quick Fix</td></tr><tr><td>Shift + F12</td><td>显示引用 Show References</td></tr><tr><td>F2</td><td>重命名符号 Rename Symbol</td></tr><tr><td>Ctrl + Shift + . /，</td><td>替换为下一个/上一个值 Replace with next/previous value</td></tr><tr><td>Ctrl + K Ctrl + X</td><td>修剪尾随空格 Trim trailing whitespace</td></tr><tr><td>Ctrl + K M</td><td>更改文件语言 Change file language</td></tr></tbody></table><h1 id="7-编辑器管理-editor-management"><a class="markdownIt-Anchor" href="#7-编辑器管理-editor-management"></a> 7. 编辑器管理 Editor management</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+F4, Ctrl+W</td><td>关闭编辑器 Close editor</td></tr><tr><td>Ctrl+K F</td><td>关闭文件夹 Close folder</td></tr><tr><td>Ctrl+\</td><td>拆分编辑器 Split editor</td></tr><tr><td>Ctrl+ 1 / 2 / 3</td><td>聚焦到第1，第2或第3编辑器组 Focus into 1st, 2nd or 3rd editor group</td></tr><tr><td>Ctrl+K Ctrl+ ←/→</td><td>聚焦到上一个/下一个编辑器组 Focus into previous/next editor group</td></tr><tr><td>Ctrl+Shift+PgUp / PgDown</td><td>向左/向右移动编辑器 Move editor left/right</td></tr><tr><td>Ctrl+K ← / →</td><td>移动活动编辑器组 Move active editor group</td></tr></tbody></table><h1 id="8-文件管理-file-management"><a class="markdownIt-Anchor" href="#8-文件管理-file-management"></a> 8. 文件管理 File management</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+N</td><td>新文件 New File</td></tr><tr><td>Ctrl+O</td><td>打开文件… Open File…</td></tr><tr><td>Ctrl+S</td><td>保存 Save</td></tr><tr><td>Ctrl+Shift+S</td><td>另存为… Save As…</td></tr><tr><td>Ctrl+K S</td><td>全部保存 Save All</td></tr><tr><td>Ctrl+F4</td><td>关闭 Close</td></tr><tr><td>Ctrl+K Ctrl+W</td><td>关闭所有 Close All</td></tr><tr><td>Ctrl+Shift+T</td><td>重新打开关闭的编辑器 Reopen closed editor</td></tr><tr><td>Ctrl+K</td><td>输入保持打开 Enter Keep Open</td></tr><tr><td>Ctrl+Tab</td><td>打开下一个 Open next</td></tr><tr><td>Ctrl+Shift+Tab</td><td>打开上一个 Open previous</td></tr><tr><td>Ctrl+K P</td><td>复制活动文件的路径 Copy path of active file</td></tr><tr><td>Ctrl+K R</td><td>显示资源管理器中的活动文件 Reveal active file in Explorer</td></tr><tr><td>Ctrl+K O</td><td>显示新窗口/实例中的活动文件 Show active file in new window/instance</td></tr></tbody></table><h1 id="9-显示-display"><a class="markdownIt-Anchor" href="#9-显示-display"></a> 9. 显示 Display</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>F11</td><td>切换全屏 Toggle full screen</td></tr><tr><td>Shift+Alt+1</td><td>切换编辑器布局 Toggle editor layout</td></tr><tr><td>Ctrl+ = / -</td><td>放大/缩小 Zoom in/out</td></tr><tr><td>Ctrl+B</td><td>切换侧栏可见性 Toggle Sidebar visibility</td></tr><tr><td>Ctrl+Shift+E</td><td>显示浏览器/切换焦点 Show Explorer / Toggle focus</td></tr><tr><td>Ctrl+Shift+F</td><td>显示搜索 Show Search</td></tr><tr><td>Ctrl+Shift+G</td><td>显示Git Show Git</td></tr><tr><td>Ctrl+Shift+D</td><td>显示调试 Show Debug</td></tr><tr><td>Ctrl+Shift+X</td><td>显示扩展 Show Extensions</td></tr><tr><td>Ctrl+Shift+H</td><td>替换文件 Replace in files</td></tr><tr><td>Ctrl+Shift+J</td><td>切换搜索详细信息 Toggle Search details</td></tr><tr><td>Ctrl+Shift+C</td><td>打开新命令提示符/终端 Open new command prompt/terminal</td></tr><tr><td>Ctrl+Shift+U</td><td>显示输出面板 Show Output panel</td></tr><tr><td>Ctrl+Shift+V</td><td>切换Markdown预览 Toggle Markdown preview</td></tr><tr><td>Ctrl+K V</td><td>从旁边打开Markdown预览 Open Markdown preview to the side</td></tr></tbody></table><h1 id="10-调试-debug"><a class="markdownIt-Anchor" href="#10-调试-debug"></a> 10. 调试 Debug</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>F9</td><td>切换断点 Toggle breakpoint</td></tr><tr><td>F5</td><td>开始/继续 Start/Continue</td></tr><tr><td>Shift+F5</td><td>停止 Stop</td></tr><tr><td>F11 / Shift+F11</td><td>下一步/上一步 Step into/out</td></tr><tr><td>F10</td><td>跳过 Step over</td></tr><tr><td>Ctrl+K Ctrl+I</td><td>显示悬停 Show hover</td></tr></tbody></table><h1 id="11-集成终端-integrated-terminal"><a class="markdownIt-Anchor" href="#11-集成终端-integrated-terminal"></a> 11. 集成终端 Integrated terminal</h1><table><thead><tr><th>按 Press</th><th>功能 Function</th></tr></thead><tbody><tr><td>Ctrl+`</td><td>显示集成终端 Show integrated terminal</td></tr><tr><td>Ctrl+Shift+`</td><td>创建新终端 Create new terminal</td></tr><tr><td>Ctrl+Shift+C</td><td>复制选定 Copy selection</td></tr><tr><td>Ctrl+Shift+V</td><td>粘贴到活动端子 Paste into active terminal</td></tr><tr><td>Ctrl+↑ / ↓</td><td>向上/向下滚动 Scroll up/down</td></tr><tr><td>Shift+PgUp / PgDown</td><td>向上/向下滚动页面 Scroll page up/down</td></tr><tr><td>Ctrl+Home / End</td><td>滚动到顶部/底部 Scroll to top/bottom</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> Vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode多设备同步扩展插件</title>
      <link href="/posts/fb80edc7.html"/>
      <url>/posts/fb80edc7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-准备工作"><a class="markdownIt-Anchor" href="#1-准备工作"></a> 1. 准备工作</h1><p>电脑上需安装VSCode，拥有一个github账户。实现同步的功能主要依赖于VSCode插件 “Settings Sync”。</p><h1 id="2-setting-sync-介绍"><a class="markdownIt-Anchor" href="#2-setting-sync-介绍"></a> 2. Setting Sync 介绍</h1><h2 id="setting-sync-可同步包含的所有扩展和完整的用户文件夹"><a class="markdownIt-Anchor" href="#setting-sync-可同步包含的所有扩展和完整的用户文件夹"></a> Setting Sync 可同步包含的所有扩展和完整的用户文件夹</h2><ol><li>设置文件</li><li>快捷键设置文件</li><li>Launch File</li><li>Snippets Folder</li><li>VSCode 扩展设置</li><li>工作空间</li></ol><h2 id="setting-sync-快捷键"><a class="markdownIt-Anchor" href="#setting-sync-快捷键"></a> Setting Sync 快捷键</h2><ol><li>上传： Shift + Alt + U (Sync: Update / Upload Settings)</li><li>下载： Shift + Alt + D (Sync: Download  Settings)</li></ol><p>如果快捷键有冲突，可Ctrl + K + S快捷键设置配置其它快捷键 或 Ctrl + P / F1 在命令窗口输入 &gt;sync 即会出现相应命令供选择</p><p><img src="https://images2017.cnblogs.com/blog/635400/201708/635400-20170824104107261-1046727224.png" alt="img" /></p><h1 id="3-安装-同步插件settings-sync"><a class="markdownIt-Anchor" href="#3-安装-同步插件settings-sync"></a> 3. 安装 同步插件&quot;Settings Sync&quot;</h1><p><img src="https://images2017.cnblogs.com/blog/635400/201708/635400-20170823100639527-466207576.png" alt="img" /></p><h1 id="4-创建personal-access-tokens"><a class="markdownIt-Anchor" href="#4-创建personal-access-tokens"></a> 4. 创建Personal access tokens</h1><p>进入github -&gt; Settings 在左侧 Developer settings -&gt; Personal access tokens</p><p><img src="https://images2017.cnblogs.com/blog/635400/201708/635400-20170823101018886-1450593067.png" alt="img" /></p><p>点击按钮 Generate new token 新增一个token</p><p>图1：</p><p><img src="https://images2017.cnblogs.com/blog/635400/201708/635400-20170823101243980-1384930832.png" alt="img" /></p><p>图2：</p><p><img src="https://images2017.cnblogs.com/blog/635400/201708/635400-20170823101418527-2001799760.png" alt="img" /></p><p>图3：</p><p><img src="https://images2017.cnblogs.com/blog/635400/201708/635400-20170823101508918-1034003796.png" alt="img" /></p><p>记住你自己生成的token值，在VSCode配置上回用得到，最好找个笔记保存下来。</p><h1 id="5-回到vscode配置将token配置到本地"><a class="markdownIt-Anchor" href="#5-回到vscode配置将token配置到本地"></a> 5. 回到VSCode配置将token配置到本地</h1><p>(Sync: Update / Uplaod Settings) Shift + Alt + U 在弹窗里输入你的token， 回车后会生成syncSummary.txt文件</p><p><img src="https://images2017.cnblogs.com/blog/635400/201708/635400-20170824103332230-1621543570.png" alt="img" /></p><p>syncSummary.txt文件会存储VSCode的设置及所安装的插件列表</p><p>有点类似package.json这样形式的文件</p><p>可以将自己的token分享到自己的团队里面去，这样团队可以共用一套设置。</p><h1 id="6-设置上同步下载设置"><a class="markdownIt-Anchor" href="#6-设置上同步下载设置"></a> 6. 设置上同步下载设置</h1><p>(Sync: Download  Settings) Shift + Alt + D 在弹窗里输入你的gist值，稍后片刻便可同步成功</p><h1 id="7-如果要重置同步设置变更其它token"><a class="markdownIt-Anchor" href="#7-如果要重置同步设置变更其它token"></a> 7. 如果要重置同步设置，变更其它token</h1><p>Ctrl+P / F1 弹出输入&gt;sync,即可重新配置你的其它token来同步</p>]]></content>
      
      
      <categories>
          
          <category> Vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>我的Git常用命令对照录</title>
      <link href="/posts/4805fbba.html"/>
      <url>/posts/4805fbba.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p>写了那么多笔记还是使用的过程中,因为脑容量有限还是出现断片的情况,当然也是因为不够熟练的原因,所以特写此对照录方便查漏补缺,不断加深印象，提高自己的使用效率,!</p><h1 id="1-git-cheat-sheet"><a class="markdownIt-Anchor" href="#1-git-cheat-sheet"></a> 1. Git cheat sheet🔥</h1><p><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/git/git-command.jpg" alt="" /></p><h1 id="2-最起码的安装git这个神器"><a class="markdownIt-Anchor" href="#2-最起码的安装git这个神器"></a> 2. 最起码的,安装Git这个神器</h1><ul><li><strong>Linux</strong>：<code>sudo apt-get install git-core</code></li><li><strong>Windows</strong>：<a href="https://git-scm.com/">官网下载安装包</a></li></ul><h1 id="3-首先得配置本台设备使用的git账号"><a class="markdownIt-Anchor" href="#3-首先得配置本台设备使用的git账号"></a> 3. 首先得配置本台设备使用的Git账号</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.mail <span class="string">&quot;980298390@qq.com&quot;</span></span><br><span class="line"></span><br><span class="line">git config --global user.name <span class="string">&quot;MCUheart&quot;</span></span><br></pre></td></tr></table></figure><h2 id="31-创建ssh部署公钥"><a class="markdownIt-Anchor" href="#31-创建ssh部署公钥"></a> 3.1. 创建SSH部署公钥</h2><p>ssh-keygen -t rsa -C “<a href="mailto:980298390@qq.com">980298390@qq.com</a>”，生成ssh。然后按下图的方式找到用户目录<code>.SSH</code>下id_rsa.pub文件的内容。<br />在服务端添加公钥之后，验证公钥添加是否成功：<br />gitbash中验证是否添加成功：ssh -T <a href="mailto:98xx98x90@qq.com">98xx98x90@qq.com</a>(ssh -T <a href="mailto:git@github.com">git@github.com</a>)</p><h1 id="4-最基础的初始化本地仓库生成相应git配置文件"><a class="markdownIt-Anchor" href="#4-最基础的初始化本地仓库生成相应git配置文件"></a> 4. 最基础的,初始化本地仓库,生成相应.git配置文件</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><h1 id="5-tag-release正式版本快捷操作"><a class="markdownIt-Anchor" href="#5-tag-release正式版本快捷操作"></a> 5. tag-release正式版本快捷操作</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">----创建tag----</span><br><span class="line">$ git tag -a 1.0.2 -m <span class="string">&quot;1.0.2版本:xxxxx&quot;</span></span><br><span class="line">$ git push origin 1.0.2</span><br><span class="line"><span class="comment"># git tag -a 标签名称 -m &quot;说明&quot;</span></span><br><span class="line"><span class="comment"># git push origin 标签名称</span></span><br><span class="line"></span><br><span class="line">----删除tag----</span><br><span class="line">$ git tag -d 1.0.2  <span class="comment"># 删除本地tag</span></span><br><span class="line">$ git push origin :1.0.2 / git push origin --delete tag 1.0.2 <span class="comment"># 删除远程tag</span></span><br><span class="line"><span class="comment"># git tag -d 标签名称</span></span><br><span class="line"><span class="comment"># git push origin :标签名称 / git push origin --delete tag 标签名称</span></span><br></pre></td></tr></table></figure><h1 id="6-各服务商目前版本操作的差异总结这个我觉得-我是真的闲因为我踩了他们挖了一地的坑"><a class="markdownIt-Anchor" href="#6-各服务商目前版本操作的差异总结这个我觉得-我是真的闲因为我踩了他们挖了一地的坑"></a> 6. 各服务商目前版本操作的差异(总结这个我觉得  我是真的闲,因为我踩了他们挖了一地的坑🙀😢)</h1><h2 id="61-地址差异"><a class="markdownIt-Anchor" href="#61-地址差异"></a> 6.1. 地址差异：</h2><h3 id="611-github-地址"><a class="markdownIt-Anchor" href="#611-github-地址"></a> 6.1.1. Github 地址</h3><p><strong><a href="http://github.com">github.com</a></strong></p><h3 id="612-gitee-地址"><a class="markdownIt-Anchor" href="#612-gitee-地址"></a> 6.1.2. Gitee 地址</h3><p><strong><a href="http://gitee.com">gitee.com</a></strong></p><h3 id="613-coding-地址"><a class="markdownIt-Anchor" href="#613-coding-地址"></a> 6.1.3. Coding 地址</h3><p><strong><a href="http://e.coding.net">e.coding.net</a></strong></p><h2 id="62-pages差异"><a class="markdownIt-Anchor" href="#62-pages差异"></a> 6.2. Pages差异：</h2><h3 id="621-github-pages"><a class="markdownIt-Anchor" href="#621-github-pages"></a> 6.2.1. Github Pages</h3><p>格式为<code>xxxx.github.io</code></p><h3 id="622-gitee-pages"><a class="markdownIt-Anchor" href="#622-gitee-pages"></a> 6.2.2. Gitee Pages</h3><p>格式为<code>xxxx</code>，xxxx必须与用户名同名，如果以Github pages的方式生成，需要在域名后面加上该仓库名为二级目录才是自己的个人主页，参考<a href="https://gitee.com/help/articles/4136#article-header0">官方文档</a></p><h3 id="623-coding-pages"><a class="markdownIt-Anchor" href="#623-coding-pages"></a> 6.2.3. Coding Pages</h3><p>格式为<code>xxxx.coding.me</code>，生成的主页网址会在设置后固定一个pages网址，域名绑定时不使用通用的e.coding.io这样的CNAME，而是分配给的固定的那个pages网址！</p><h2 id="63-access-token个人令牌使用差异"><a class="markdownIt-Anchor" href="#63-access-token个人令牌使用差异"></a> 6.3. Access token（个人令牌）使用差异：</h2><h3 id="631-github-access-token"><a class="markdownIt-Anchor" href="#631-github-access-token"></a> 6.3.1. Github Access token</h3><ul><li><p><strong>https</strong>：<code>&lt;git command&gt; https://&lt;用户名&gt;:&lt;设置的个人令牌号&gt;@github.com/&lt;仓库名&gt;/&lt;用户名&gt;.git</code>/<code>&lt;git command&gt; https://&lt;设置的个人令牌号&gt;@github.com/&lt;仓库名&gt;/&lt;用户名&gt;.git</code></p></li><li><p><strong>SSH</strong>：<code>&lt;git command&gt; git@&lt;用户名&gt;:&lt;设置的个人令牌号&gt;@github.com/&lt;仓库名&gt;/&lt;用户名&gt;.git</code>/<code>&lt;git command&gt; git@&lt;设置的个人令牌号&gt;@github.com/&lt;仓库名&gt;/&lt;用户名&gt;.git</code></p><p>亲测以上另种方式都可。</p></li></ul><h3 id="632-gitee-access-token"><a class="markdownIt-Anchor" href="#632-gitee-access-token"></a> 6.3.2. Gitee Access token</h3><ul><li><strong>https</strong>：<code>&lt;git command&gt; https://&lt;用户名&gt;:&lt;设置的个人令牌号&gt;@gitee.com/&lt;仓库名&gt;/&lt;用户名&gt;.git</code></li><li><strong>SSH</strong>：<code>&lt;git command&gt; git@&lt;用户名&gt;:&lt;设置的个人令牌号&gt;@gitee.com/&lt;仓库名&gt;/&lt;用户名&gt;.git</code></li></ul><h3 id="633-coding-access-token"><a class="markdownIt-Anchor" href="#633-coding-access-token"></a> 6.3.3. Coding Access token</h3><p><strong>注意一下命令所使用的&lt;用户名&gt;是coding创建一个个人令牌时专门使用这个令牌的用户名！</strong></p><p>你所使用的个人令牌</p><ul><li><strong>https</strong>：<code>&lt;git command&gt; https://&lt;用户名&gt;:&lt;设置的个人令牌号&gt;@e.coding.net/&lt;仓库名&gt;/&lt;用户名&gt;.git</code></li><li><strong>SSH</strong>：<code>&lt;git command&gt; git@&lt;用户名&gt;:&lt;设置的个人令牌号&gt;@e.coding.net/&lt;仓库名&gt;/&lt;用户名&gt;.git</code></li></ul><p>看完是不是觉得很坑爹哈！！！应该让他们打一架让个大哥统一一下使用格式！💩</p><h1 id="7-命令分类"><a class="markdownIt-Anchor" href="#7-命令分类"></a> 7. 命令分类</h1><table><thead><tr><th style="text-align:left">设置和配置</th><th style="text-align:left">获取和创建项目</th><th style="text-align:left">基本快照</th><th style="text-align:left">分支和合并</th></tr></thead><tbody><tr><td style="text-align:left">git<br/>config<br/>help</td><td style="text-align:left">init<br/>clone</td><td style="text-align:left">add<br/>status<br/>diff<br/>commit<br/>reset<br/>rm<br/>mv</td><td style="text-align:left">branch<br/>checkout<br/>merge<br/>mergetool<br/>log<br/>stash<br/>tag<br/>worktree</td></tr><tr><td style="text-align:left">共享和更新项目</td><td style="text-align:left">检查和比较</td><td style="text-align:left">修补</td><td style="text-align:left">调试</td></tr><tr><td style="text-align:left">fetch<br/>pull<br/>push<br/>remote<br/>submodule</td><td style="text-align:left">show<br/>log<br/>diff<br/>shortlog<br/>describe</td><td style="text-align:left">apply<br/>cherry-pick<br/>diff<br/>rebase<br/>revert</td><td style="text-align:left">bisect<br/>blame<br/>grep</td></tr></tbody></table><h1 id="8-各子命令详细示例"><a class="markdownIt-Anchor" href="#8-各子命令详细示例"></a> 8. 各子命令详细示例🌞</h1><h2 id="81-git"><a class="markdownIt-Anchor" href="#81-git"></a> 8.1. git</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">　　git [--version] [--<span class="built_in">help</span>] [-C &lt;path&gt;] [-c &lt;name&gt;=&lt;value&gt;]</span><br><span class="line">    　　[--exec-path[=&lt;path&gt;]] [--html-path] [--man-path] [--info-path]</span><br><span class="line">    　　[-p|--paginate|--no-pager] [--no-replace-objects] [--bare]</span><br><span class="line">    　　[--git-dir=&lt;path&gt;] [--work-tree=&lt;path&gt;] [--namespace=&lt;name&gt;]</span><br><span class="line">    　　[--super-prefix=&lt;path&gt;]</span><br><span class="line">    　　&lt;<span class="built_in">command</span>&gt; [&lt;args&gt;]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    --version               <span class="comment"># 打印git程序的版本号</span></span><br><span class="line">    --<span class="built_in">help</span>                  <span class="comment"># 打印概要和最常用命令的列表</span></span><br><span class="line">    -C &lt;path&gt;               <span class="comment"># 在&lt;path&gt;而不是当前的工作目录中运行git</span></span><br><span class="line">    -c &lt;name&gt;=&lt;value&gt;       <span class="comment"># 将配置参数传递给命令, 给定的值将覆盖配置文件中的值</span></span><br><span class="line">    --exec-path[=&lt;path&gt;]    <span class="comment"># 安装核心Git程序的路径, 可以通过设置GIT_EXEC_PATH环境变量来控制, 如无路径, git将打印当前设置并退出</span></span><br><span class="line">    --html-path             <span class="comment"># 打印Git的HTML文档安装并退出的路径, 不带斜杠</span></span><br><span class="line">    --man-path              <span class="comment"># 打印man(1)此版本Git的手册页的manpath, 并退出</span></span><br><span class="line">    --info-path             <span class="comment"># 打印记录此版本Git的Info文件的安装路径并退出</span></span><br><span class="line">    -p, --paginate          <span class="comment"># 如果标准输出是终端, 则将所有输出管道更少（或如果设置为$ PAGER）, 这将覆盖pager.&lt;cmd&gt; 配置选项</span></span><br><span class="line">    --no-pager              <span class="comment"># 不要将Git输出管道传输到寻呼机</span></span><br><span class="line">    --no-replace-objects    <span class="comment"># 不要使用替换参考来替换Git对象</span></span><br><span class="line">    --bare                  <span class="comment"># 将存储库视为裸存储库, 如果未设置GIT_DIR环境, 则将其设置为当前工作目录</span></span><br><span class="line">    --git-dir=&lt;path&gt;        <span class="comment"># 设置存储库的路径, 可以通过设置GIT_DIR环境变量来控制, 可以是当前工作目录的绝对或相对路径</span></span><br><span class="line">    --work-tree=&lt;path&gt;      <span class="comment"># 设置工作树的路径, 可以通过设置GIT_WORK_TREE环境变量和core.worktree配置变量来控制, 相对于当前工作目录的绝对或相对路径</span></span><br><span class="line">    --namespace=&lt;path&gt;      <span class="comment"># 设置Git命名空间, 相当于设置GIT_NAMESPACE环境变量</span></span><br><span class="line">    --super-prefix=&lt;path&gt;   <span class="comment"># 目前仅供内部使用, 设置一个前缀, 该前缀从存储库到根的路径, 一个用途是给调用它的超级项目的子模块上下文</span></span><br><span class="line">    --literal-pathspecs     <span class="comment"># 字面上处理pathspecs, 相当于设置GIT_LITERAL_PATHSPECS为1</span></span><br><span class="line">    --glob-pathspecs        <span class="comment"># 添加&quot;glob&quot;到所有pathspec, 相当于设置GIT_GLOB_PATHSPECS为1</span></span><br><span class="line">    --noglob-pathspecs      <span class="comment"># 添加&quot;文字&quot;到所有pathspec, 相当于设置GIT_NOGLOB_PATHSPECS为1</span></span><br><span class="line">    --icase-pathspecs       <span class="comment"># 添加&quot;icase&quot;到所有pathspec, 相当于设置GIT_ICASE_PATHSPECS为1</span></span><br><span class="line">    --no-optional-locks     <span class="comment"># 不要执行需要锁定的可选操作, 相当于设置GIT_OPTIONAL_LOCKS为0</span></span><br></pre></td></tr></table></figure><h2 id="82-git-config"><a class="markdownIt-Anchor" href="#82-git-config"></a> 8.2. git config</h2><p>配置 Git 的相关参数。</p><p>Git 一共有3个配置文件：</p><p>\1. 仓库级的配置文件：在仓库的 <code>.git/.gitconfig</code>，该配置文件只对所在的仓库有效。<br />\2. 全局配置文件：Mac 系统在 <code>~/.gitconfig</code>，Windows 系统在 <code>C:\Users\&lt;用户名&gt;\.gitconfig</code>。<br />\3. 系统级的配置文件：在 Git 的安装目录下（Mac 系统下安装目录在 <code>/usr/local/git</code>）的 <code>etc</code> 文件夹中的 <code>gitconfig</code>。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看配置信息</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看当前生效的配置信息</span></span><br><span class="line">$ git config -l</span><br><span class="line"></span><br><span class="line"><span class="comment"># 编辑配置文件</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; -e</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加配置项</span></span><br><span class="line"><span class="comment"># --local：仓库级，--global：全局级，--system：系统级</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --add &lt;name&gt; &lt;value&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 获取配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --get &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除配置项</span></span><br><span class="line">$ git config &lt;--<span class="built_in">local</span> | --global | --system&gt; --<span class="built_in">unset</span> &lt;name&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置提交记录中的用户信息</span></span><br><span class="line">$ git config --global user.name &lt;用户名&gt;</span><br><span class="line">$ git config --global user.email &lt;邮箱地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 更改Git缓存区的大小</span></span><br><span class="line"><span class="comment"># 如果提交的内容较大，默认缓存较小，提交会失败</span></span><br><span class="line"><span class="comment"># 缓存大小单位：B，例如：524288000（500MB）</span></span><br><span class="line">$ git config --global http.postBuffer &lt;缓存大小&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 调用 git status/git diff 命令时以高亮或彩色方式显示改动状态</span></span><br><span class="line">$ git config --global color.ui <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置可以缓存密码，默认缓存时间15分钟</span></span><br><span class="line">$ git config --global credential.helper cache</span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置密码的缓存时间</span></span><br><span class="line"><span class="comment"># 缓存时间单位：秒</span></span><br><span class="line">$ git config --global credential.helper <span class="string">&#x27;cache --timeout=&lt;缓存时间&gt;&#x27;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 配置长期存储密码</span></span><br><span class="line">$ git config --global credential.helper store</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">　　git config [&lt;file-option&gt;] [<span class="built_in">type</span>] [--show-origin] [-z|--null] name [value [value_regex]]</span><br><span class="line">　　git config [&lt;file-option&gt;] [<span class="built_in">type</span>] --add name value</span><br><span class="line">　　git config [&lt;file-option&gt;] [<span class="built_in">type</span>] --replace-all name value [value_regex]</span><br><span class="line">　　git config [&lt;file-option&gt;] [<span class="built_in">type</span>] [--show-origin] [-z|--null] --get name [value_regex]</span><br><span class="line">　　git config [&lt;file-option&gt;] [<span class="built_in">type</span>] [--show-origin] [-z|--null] --get-all name [value_regex]</span><br><span class="line">　　git config [&lt;file-option&gt;] [<span class="built_in">type</span>] [--show-origin] [-z|--null] [--name-only] --get-regexp name_regex [value_regex]</span><br><span class="line">　　git config [&lt;file-option&gt;] [<span class="built_in">type</span>] [-z|--null] --get-urlmatch name URL</span><br><span class="line">　　git config [&lt;file-option&gt;] --<span class="built_in">unset</span> name [value_regex]</span><br><span class="line">　　git config [&lt;file-option&gt;] --unset-all name [value_regex]</span><br><span class="line">　　git config [&lt;file-option&gt;] --rename-section old_name new_name</span><br><span class="line">　　git config [&lt;file-option&gt;] --remove-section name</span><br><span class="line">　　git config [&lt;file-option&gt;] [--show-origin] [-z|--null] [--name-only] -l | --list</span><br><span class="line">　　git config [&lt;file-option&gt;] --get-color name [default]</span><br><span class="line">　　git config [&lt;file-option&gt;] --get-colorbool name [stdout-is-tty]</span><br><span class="line">　　git config [&lt;file-option&gt;] -e | --edit</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    --system                            <span class="comment"># 使用系统配置文件</span></span><br><span class="line">    --global                            <span class="comment"># 使用全局配置文件</span></span><br><span class="line">    --<span class="built_in">local</span>                             <span class="comment"># 使用本地配置文件, 默认</span></span><br><span class="line">    -f &lt;filename&gt;, --file &lt;filename&gt;    <span class="comment"># 使用指定配置文件</span></span><br><span class="line">    --blob &lt;blob-id&gt;                    <span class="comment"># 使用指定blob</span></span><br><span class="line">    --int                               <span class="comment"># 确保输出为简单十进制数</span></span><br><span class="line">    --bool                              <span class="comment"># 确保输出为&quot;true&quot; 或 &quot;false&quot; 的布尔字符串表示</span></span><br><span class="line">    --bool-or-int                       <span class="comment"># 确保输出为--bool或--int的格式</span></span><br><span class="line">    --path                              <span class="comment"># 将扩展~到指定用户的主目录的值 $HOME和~user主目录。</span></span><br><span class="line">    --replace-all                       <span class="comment"># 替换与该键匹配的所有行</span></span><br><span class="line">    --add                               <span class="comment"># 添加配置项</span></span><br><span class="line">    --get                               <span class="comment"># 获取给定键的值（可选用与值匹配的正则表达式进行过滤）</span></span><br><span class="line">    --get-all                           <span class="comment"># 像get一样，但返回多值键的所有值</span></span><br><span class="line">    --get-regexp                        <span class="comment"># 像get-all一样，但将该名称解释为正则表达式并写出键名称</span></span><br><span class="line">    --get-urlmatch name URL             <span class="comment"># 当给定一个由两部分组成的名称section.key时，会返回部分&lt;url&gt;.key的值</span></span><br><span class="line">    --remove-section                    <span class="comment"># 从配置文件中删除给定的部分</span></span><br><span class="line">    --rename-section                    <span class="comment"># 将给定部分重命名为新名称</span></span><br><span class="line">    --<span class="built_in">unset</span>                             <span class="comment"># 从配置文件中删除与密钥匹配的行</span></span><br><span class="line">    --unset-all                         <span class="comment"># 从配置文件中删除所有与密钥匹配的行</span></span><br><span class="line">    -l, --list                          <span class="comment"># 列出在配置文件中设置的所有变量及其值</span></span><br><span class="line">    --expiry-date                       <span class="comment"># 将确保输出从固定或相对日期字符串转换为时间戳, 设置该值时此选项无效</span></span><br><span class="line">    -z, --null                          <span class="comment"># 对于输出值和/或键的所有选项，始终使用空字符结束值, 使用换行符作为键和值之间的分隔符</span></span><br><span class="line">    --name-only                         <span class="comment"># 输出--listor 的配置变量的名称--get-regexp</span></span><br><span class="line">    --show-origin                       <span class="comment"># 使用原点类型（文件, 标准输入, blob, 命令行）和实际原点（配置文件路径, ref或blob id）扩大所有查询配置选项的输出</span></span><br><span class="line">    --get-colorbool name [stdout-is-tty]<span class="comment"># 找到name（例如color.diff）的颜色设置并输出&quot;true&quot;或&quot;false&quot;</span></span><br><span class="line">    --get-color name [default]          <span class="comment"># 查找name（例如color.diff.new）配置的颜色并将其作为ANSI颜色转义序列输出到标准输出</span></span><br><span class="line">    -e, --edit                          <span class="comment"># 打开一个编辑器来修改指定的配置文件; 或者 --system，--global或者存储库（默认）</span></span><br><span class="line">    --[no-]includes                     <span class="comment"># 查找值, 默认off, on搜索所有配置文件, 当值定文件时（使用：--file，--global等）</span></span><br></pre></td></tr></table></figure><h2 id="83-git-help"><a class="markdownIt-Anchor" href="#83-git-help"></a> 8.3. git help</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">　　git <span class="built_in">help</span> [-a|--all] [-g|--guide]</span><br><span class="line">       　　[-i|--info|-m|--man|-w|--web] [COMMAND|GUIDE]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a, --all           <span class="comment"># 在标准输出上打印所有可用的命令</span></span><br><span class="line">    -g, --guide         <span class="comment"># 在标准输出上打印有用的指南列表</span></span><br><span class="line">    -i, --info          <span class="comment"># 以信息格式显示命令的手册页</span></span><br><span class="line">    -m, --man           <span class="comment"># 以man格式显示命令的手册页</span></span><br><span class="line">    -w, --web           <span class="comment"># 以Web（HTML）格式显示命令的手册页</span></span><br></pre></td></tr></table></figure><h2 id="84-git-clone"><a class="markdownIt-Anchor" href="#84-git-clone"></a> 8.4. git clone</h2><p>从远程仓库克隆一个版本库到本地。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 默认在当前目录下创建和版本库名相同的文件夹并下载版本到该文件夹下</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 指定本地仓库的目录</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># -b 指定要克隆的分支，默认是master分支</span></span><br><span class="line">$ git <span class="built_in">clone</span> &lt;远程仓库的网址&gt; -b &lt;分支名称&gt; &lt;本地目录&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git <span class="built_in">clone</span> [--template=&lt;template_directory&gt;]</span><br><span class="line">        [-l] [-s] [--no-hardlinks] [-q] [-n] [--bare] [--mirror]</span><br><span class="line">        [-o &lt;name&gt;] [-b &lt;name&gt;] [-u &lt;upload-pack&gt;] [--reference &lt;repository&gt;]</span><br><span class="line">        [--dissociate] [--separate-git-dir &lt;git dir&gt;]</span><br><span class="line">        [--depth &lt;depth&gt;] [--[no-]single-branch] [--no-tags]</span><br><span class="line">        [--recurse-submodules[=&lt;pathspec&gt;]] [--[no-]shallow-submodules]</span><br><span class="line">        [--<span class="built_in">jobs</span> &lt;n&gt;] [--] &lt;repository&gt; [&lt;directory&gt;]</span><br><span class="line"></span><br><span class="line">选项：        </span><br><span class="line">    -l, --<span class="built_in">local</span>                        <span class="comment"># 当克隆的存储库位于本地计算机上时, 此标志绕过正常的“Git aware”传输机制, 并通过复制HEAD以及对象和引用目录下的所有内容来克隆存储库</span></span><br><span class="line">    --no-hardlinks                     <span class="comment"># 强制从本地文件系统的存储库复制进程, 以复制目录下的.git/objects 文件而不是使用硬链接</span></span><br><span class="line">    -s, --shared                       <span class="comment"># 当克隆的存储库位于本地计算机上时, 将自动设置.git/objects/info/alternates为与源存储库共享对象, 而不是使用硬链接, 生成的存储库首先没有任何对象</span></span><br><span class="line">    --reference[-if-able] &lt;repository&gt; <span class="comment"># 如存储库位于本地计算机上, 则自动设置.git/objects/info/alternates为从存储库获取对象将已存在存储库用作备用存储库将需从正在克隆的存储库中复制更少对象, 而降低网络和本地存储成本</span></span><br><span class="line">    --dissociate                       <span class="comment"># 借助--reference仅使用选项指定的引用存储库借用对象, 以减少网络传输, 并通过制作所需的借用对象的本地副本, 在克隆完成后停止借用它们</span></span><br><span class="line">    -q, --quiet                        <span class="comment"># 安静地操作, 进度未报告给标准错误流</span></span><br><span class="line">    -v, --verbose                      <span class="comment"># 运行详细, 不影响向标准错误流报告进度状态</span></span><br><span class="line">    --progress                         <span class="comment"># 当连接到终端时，默认情况下, 标准错误流中会报告进度状态，除非指定-q，即使标准错误流未定向到终端, 此标志也会强制进度状态</span></span><br><span class="line">    -n, --no-checkout                  <span class="comment"># 克隆完成后, 不执行HEAD签出</span></span><br><span class="line">    --bare                             <span class="comment"># 制作一个纯粹的 Git存储库</span></span><br><span class="line">    --mirror                           <span class="comment"># 设置源存储库的镜像</span></span><br><span class="line">    -o &lt;name&gt;, --origin &lt;name&gt;         <span class="comment"># 不要使用远程名称origin来跟踪上游存储库，请使用&lt;name&gt;</span></span><br><span class="line">    -b &lt;name&gt;, --branch &lt;name&gt;         <span class="comment"># 而不是将新创建的HEAD指向克隆存储库HEAD指向的&lt;name&gt;分支，而是指向分支在非裸仓库中, 这是将被检出的分支。 --branch也可以在生成的存储库中提交标签并分离HEAD</span></span><br><span class="line">    -u &lt;upload-pack&gt;, --upload-pack &lt;upload-pack&gt;  <span class="comment"># 当给定时, 通过ssh访问要克隆的存储库, 这将为另一端运行的命令指定非默认路径</span></span><br><span class="line">    --template=&lt;template_directory&gt;                <span class="comment"># 指定将使用模板的目录</span></span><br><span class="line">    -c &lt;key&gt;=&lt;value&gt;, --config &lt;key&gt;=&lt;value&gt;       <span class="comment"># 在新创建的存储库中设置配置变量</span></span><br><span class="line">    --depth &lt;depth&gt;                                <span class="comment"># 创建一个历史截断为指定数目的提交的浅表副本</span></span><br><span class="line">    --shallow-since=&lt;date&gt;                         <span class="comment"># 在指定时间后创建一个具有历史记录的浅表克隆</span></span><br><span class="line">    --shallow-exclude=&lt;revision&gt;                   <span class="comment"># 创建有历史记录的浅层克隆, 但不包括从指定远程分支或标记可访问的提交</span></span><br><span class="line">    --[no-]single-branch　　　　　　　　　　　　　　　  <span class="comment"># 只克隆导致单个分支尖端的历史记录, 无论--branch选项指定还是主分支远程的HEAD指向</span></span><br><span class="line">    --no-tags 　　　　　　　　　　　　　　　　　　　　　  <span class="comment"># 不要克隆任何标签, 并remote.&lt;remote&gt;.tagOpt=--no-tags在配置中设置, 确保将来git pull和git fetch操作不会跟随任何标签</span></span><br><span class="line">    --recurse-submodules[=&lt;pathspec]               <span class="comment"># 创建克隆后, 根据pathspec初始化和克隆子模块。如未提供pathspec, 则初始化并克隆所有子模块</span></span><br><span class="line">    --[no-]shallow-submodules                      <span class="comment"># 所克隆的所有子模块将会变浅, 深度为1</span></span><br><span class="line">    --separate-git-dir=&lt;git dir&gt;                   <span class="comment"># 不要将克隆的存储库放置在它应该存在的位置, 而应将克隆的存储库放置在指定的目录中,然后创建一个与文件系统无关的Git符号链接。结果是Git仓库可以从工作树中分离出来</span></span><br><span class="line">    -j &lt;n&gt;, --<span class="built_in">jobs</span> &lt;n&gt;                             <span class="comment"># 同时获取的子模块的数量。默认为submodule.fetchJobs选项</span></span><br><span class="line">    &lt;repository&gt;                                   <span class="comment"># 从中克隆的存储库</span></span><br><span class="line">    &lt;directory&gt;                                    <span class="comment"># 要克隆到的新目录的名称</span></span><br></pre></td></tr></table></figure><h2 id="85-git-init"><a class="markdownIt-Anchor" href="#85-git-init"></a> 8.5. git init</h2><p>初始化项目所在目录，初始化后会在当前目录下出现一个名为 .git 的目录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 初始化本地仓库，在当前目录下生成 .git 文件夹</span></span><br><span class="line">$ git init</span><br><span class="line"></span><br><span class="line">语法：    </span><br><span class="line">    git init [-q | --quiet] [--bare] [--template=&lt;template_directory&gt;]</span><br><span class="line">        [--separate-git-dir &lt;git dir&gt;]</span><br><span class="line">        [--shared[=&lt;permissions&gt;]] [directory]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -q, --quiet                         　　　　　　<span class="comment"># 仅打印错误和警告消息, 所有其他输出将被抑制</span></span><br><span class="line">    --bare                              　　　　　　<span class="comment"># 创建一个裸仓库, 如果GIT_DIR未设置环境, 则将其设置为当前工作目录</span></span><br><span class="line">    --template=&lt;template_directory&gt;     　　　　　　<span class="comment"># 指定将使用模板的目录</span></span><br><span class="line">    --separate-git-dir=&lt;git dir&gt;        　　　　　　<span class="comment"># 相反, 初始化存储库作为目录之一$GIT_DIR或者./.git/, 创建一个包含路径的实际存储库的文本文件存在, 该文件充当文件系统不可知的Git与存储库的符号链接</span></span><br><span class="line">    --shared[=(<span class="literal">false</span>|<span class="literal">true</span>|<span class="built_in">umask</span>|group|all|world|everybody|0xxx)] <span class="comment"># 指定Git存储库在多用户间共享, 允许同一组的用户推入该存储库</span></span><br><span class="line">        <span class="built_in">umask</span> (or <span class="literal">false</span>)                　　　　　　<span class="comment"># 使用由umask(2)报告的权限, --shared未指定时的默认值</span></span><br><span class="line">        group (or <span class="literal">true</span>)                　　　　　　 <span class="comment"># 使存储库组可写</span></span><br><span class="line">        all (or world or everybody)     　　　　　　<span class="comment"># 与组相同，但使存储库可供所有用户读取</span></span><br><span class="line">        0xxx                            　　　　　　<span class="comment"># 0xxx是八进制数, 每个文件都有模式0xxx。</span></span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　 　　　　　　 0640将创建一个组可读的存储库, 但不能对其他组进行写入或访问。0660将创建一个对当前用户和组可读可写的回购, 但其他人无法访问。</span><br></pre></td></tr></table></figure><h2 id="86-git-status"><a class="markdownIt-Anchor" href="#86-git-status"></a> 8.6. git status</h2><p>查看本地仓库的状态。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看本地仓库的状态</span></span><br><span class="line">$ git status</span><br><span class="line"></span><br><span class="line"><span class="comment"># 以简短模式查看本地仓库的状态</span></span><br><span class="line"><span class="comment"># 会显示两列，第一列是文件的状态，第二列是对应的文件</span></span><br><span class="line"><span class="comment"># 文件状态：A 新增，M 修改，D 删除，?? 未添加到Git中</span></span><br><span class="line">$ git status -s</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git status [&lt;options&gt;…] [--] [&lt;pathspec&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -s, --short                               <span class="comment"># 以短格式输出输出</span></span><br><span class="line">    -b, --branch                              <span class="comment"># 甚至以短格式显示分支和跟踪信息</span></span><br><span class="line">    --show-stash                              <span class="comment"># 显示当前隐藏的条目数量</span></span><br><span class="line">    --porcelain[=&lt;version&gt;]                   <span class="comment"># 为脚本提供易于解析的格式输出</span></span><br><span class="line">    --long                                    <span class="comment"># 以长格式输出输出, 默认</span></span><br><span class="line">    -v, --verbose                             <span class="comment"># 除了已更改的文件名称之外, 还会显示正在执行的文本更改</span></span><br><span class="line">    -u[&lt;mode&gt;], --untracked-files[=&lt;mode&gt;]    <span class="comment"># 显示未跟踪的文件</span></span><br><span class="line">    --ignore-submodules[=&lt;when&gt;]              <span class="comment"># 查找更改时忽略对子模块的更改。&lt;when&gt;可以是&quot;none&quot;, &quot;untracked&quot;, &quot;dirty&quot;或&quot;all&quot;, 这是默认设置</span></span><br><span class="line">    --ignored[=&lt;mode&gt;]                        <span class="comment"># 也显示忽略的文件。mode参数用于指定忽略文件的处理, 可选的, 默认为传统</span></span><br><span class="line">        traditional                           <span class="comment"># 传统, 显示被忽略的文件和目录, 除非指定--untracked-files = all，这种情况下将显示忽略目录中的单个文件</span></span><br><span class="line">        no                                    <span class="comment"># 否, 不显示任何被忽略的文件</span></span><br><span class="line">        matching                              <span class="comment"># 匹配, 显示与忽略模式匹配的忽略文件和目录</span></span><br><span class="line">    -z                                        <span class="comment"># 用NUL而不是LF终止输入</span></span><br><span class="line">    --no-column, --column[=&lt;options&gt;]         <span class="comment"># 在列中显示未跟踪的文件</span></span><br><span class="line">    --ahead-behind, --no-ahead-behind         <span class="comment"># 显示或不显示分支相对于其上游分支的详细前/后计数。默认为true</span></span><br><span class="line">    &lt;pathspec&gt;…                               <span class="comment"># </span></span><br></pre></td></tr></table></figure><h2 id="87-git-remote"><a class="markdownIt-Anchor" href="#87-git-remote"></a> 8.7. git remote</h2><p>操作远程库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出已经存在的远程仓库</span></span><br><span class="line">$ git remote</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出远程仓库的详细信息，在别名后面列出URL地址</span></span><br><span class="line">$ git remote -v</span><br><span class="line">$ git remote --verbose</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加远程仓库</span></span><br><span class="line">$ git remote add &lt;远程仓库的别名&gt; &lt;远程仓库的URL地址&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的别名</span></span><br><span class="line">$ git remote rename &lt;原远程仓库的别名&gt; &lt;新的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定名称的远程仓库</span></span><br><span class="line">$ git remote remove &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改远程仓库的 URL 地址</span></span><br><span class="line">$ git remote set-url &lt;远程仓库的别名&gt; &lt;新的远程仓库URL地址&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git remote [-v | --verbose]</span><br><span class="line">    git remote add [-t &lt;branch&gt;] [-m &lt;master&gt;] [-f] [--[no-]tags] [--mirror=&lt;fetch|push&gt;] &lt;name&gt; &lt;url&gt;</span><br><span class="line">    git remote rename &lt;old&gt; &lt;new&gt;</span><br><span class="line">    git remote remove &lt;name&gt;</span><br><span class="line">    git remote set-head &lt;name&gt; (-a | --auto | -d | --delete | &lt;branch&gt;)</span><br><span class="line">    git remote set-branches [--add] &lt;name&gt; &lt;branch&gt;…​</span><br><span class="line">    git remote get-url [--push] [--all] &lt;name&gt;</span><br><span class="line">    git remote set-url [--push] &lt;name&gt; &lt;newurl&gt; [&lt;oldurl&gt;]</span><br><span class="line">    git remote set-url --add [--push] &lt;name&gt; &lt;newurl&gt;</span><br><span class="line">    git remote set-url --delete [--push] &lt;name&gt; &lt;url&gt;</span><br><span class="line">    git remote [-v | --verbose] show [-n] &lt;name&gt;…​</span><br><span class="line">    git remote prune [-n | --dry-run] &lt;name&gt;…​</span><br><span class="line">    git remote [-v | --verbose] update [-p | --prune] [(&lt;group&gt; | &lt;remote&gt;)…​]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -v, --verbose       <span class="comment"># 稍微详细一点，并在名称后显示远程URL</span></span><br><span class="line">    add                 <span class="comment"># 在&lt;url&gt;处添加一个名为&lt;名称&gt;的存储库</span></span><br><span class="line">    rename              <span class="comment"># 将名为&lt;old&gt;的远程重命名为&lt;new&gt;。远程的所有远程跟踪分支和配置设置都会更新</span></span><br><span class="line">    rm,    remove       <span class="comment"># 删除名为&lt;名称&gt;的远程。远程的所有远程跟踪分支和配置设置均被删除</span></span><br><span class="line">    set-head            <span class="comment"># 设置或删除refs/remotes/&lt;name&gt;/HEAD指定远程的默认分支（即symbolic-ref的目标）</span></span><br><span class="line">    set-branches        <span class="comment"># 更改已命名远程所跟踪分支的列表</span></span><br><span class="line">    get-url             <span class="comment"># 检索远程的URL</span></span><br><span class="line">    set-url             <span class="comment"># 更改远程的URL</span></span><br><span class="line">    show                <span class="comment"># 给出关于远程&lt;名称&gt;的一些信息</span></span><br><span class="line">    prune               <span class="comment"># 删除与&lt;名称&gt;关联的陈旧引用</span></span><br><span class="line">    update              <span class="comment"># 按遥控器&lt;group&gt;的定义，获取存储库中一组指定遥控器的更新</span></span><br></pre></td></tr></table></figure><h2 id="88-git-branch"><a class="markdownIt-Anchor" href="#88-git-branch"></a> 8.8. git branch</h2><p>操作 Git 的分支命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 列出本地的所有分支，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch</span><br><span class="line"></span><br><span class="line"><span class="comment"># 列出本地的所有分支并显示最后一次提交，当前所在分支以 &quot;*&quot; 标出</span></span><br><span class="line">$ git branch -v</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建新分支，新的分支基于上一次提交建立</span></span><br><span class="line">$ git branch &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改分支名称</span></span><br><span class="line"><span class="comment"># 如果不指定原分支名称则为当前所在分支</span></span><br><span class="line">$ git branch -m [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"><span class="comment"># 强制修改分支名称</span></span><br><span class="line">$ git branch -M [&lt;原分支名称&gt;] &lt;新的分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的本地分支</span></span><br><span class="line">$ git branch -d &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 强制删除指定的本地分支</span></span><br><span class="line">$ git branch -D &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git branch [--color[=&lt;when&gt;] | --no-color] [-r | -a]</span><br><span class="line">        [--list] [-v [--abbrev=&lt;length&gt; | --no-abbrev]]</span><br><span class="line">        [--column[=&lt;options&gt;] | --no-column] [--sort=&lt;key&gt;]</span><br><span class="line">        [(--merged | --no-merged) [&lt;commit&gt;]]</span><br><span class="line">        [--contains [&lt;commit]] [--no-contains [&lt;commit&gt;]]</span><br><span class="line">        [--points-at &lt;object&gt;] [--format=&lt;format&gt;] [&lt;pattern&gt;…]</span><br><span class="line">    git branch [--track | --no-track] [-l] [-f] &lt;branchname&gt; [&lt;start-point&gt;]</span><br><span class="line">    git branch (--set-upstream-to=&lt;upstream&gt; | -u &lt;upstream&gt;) [&lt;branchname&gt;]</span><br><span class="line">    git branch --unset-upstream [&lt;branchname&gt;]</span><br><span class="line">    git branch (-m | -M) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line">    git branch (-c | -C) [&lt;oldbranch&gt;] &lt;newbranch&gt;</span><br><span class="line">    git branch (-d | -D) [-r] &lt;branchname&gt;…</span><br><span class="line">    git branch --edit-description [&lt;branchname&gt;]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -d, --delete                                 <span class="comment"># 删除分支</span></span><br><span class="line">    -D                                           <span class="comment"># 快捷键--delete --force</span></span><br><span class="line">    -l, --create-reflog                          <span class="comment"># 创建分支的reflog</span></span><br><span class="line">    -f, --force                                  <span class="comment"># 将&lt;branchname&gt;重置为&lt;startpoint&gt;，即使&lt;branchname&gt;已存在</span></span><br><span class="line">    -m, --move                                   <span class="comment"># 移动/重命名分支和相应的reflog</span></span><br><span class="line">    -M                                           <span class="comment"># 快捷键--move --force</span></span><br><span class="line">    -c, --copy                                   <span class="comment"># 复制分支和相应的reflog</span></span><br><span class="line">    -C                                           <span class="comment"># 快捷键--copy --force</span></span><br><span class="line">    --color[=&lt;when&gt;]                             <span class="comment"># 颜色分支突出显示当前，本地和远程跟踪分支。该值必须始终（默认），永不，或自动</span></span><br><span class="line">    --no-color                                   <span class="comment"># 关闭分支颜色，即使配置文件将默认设置为颜色输出。和...一样--color=never</span></span><br><span class="line">    -i, --ignore-case                            <span class="comment"># 排序和过滤分支不区分大小写</span></span><br><span class="line">    --column[=&lt;options&gt;], --no-column            <span class="comment"># 在列中显示分支列表</span></span><br><span class="line">    -r, --remotes                                <span class="comment"># 列出或删除（如果与-d一起使用）远程跟踪分支</span></span><br><span class="line">    -a, --all                                    <span class="comment"># 列出远程追踪分行和当地分行</span></span><br><span class="line">    --list                                       <span class="comment"># 列出分支</span></span><br><span class="line">    -v, -vv, --verbose                           <span class="comment"># 在列表模式下，显示sha1并为每个头提交主题行，以及与上游分支（如果有）的关系</span></span><br><span class="line">    -q, --quiet                                  <span class="comment"># 创建或删除分支时更安静，抑制非错误消息</span></span><br><span class="line">    --abbrev=&lt;length&gt;                            <span class="comment"># 改变输出列表中sha1的最小显示长度。默认值是7</span></span><br><span class="line">    --no-abbrev                                  <span class="comment"># 在输出列表中显示完整的sha1，而不是缩写它们</span></span><br><span class="line">    -t, --track                                  <span class="comment"># 创建新分支时，设置branch.&lt;name&gt;.remote和 branch.&lt;name&gt;.merge配置条目以将起点分支标记为新分支的“上游”</span></span><br><span class="line">    --no-track                                   <span class="comment"># 即使branch.autoSetupMerge配置变量为true，也不要设置“上游”配置</span></span><br><span class="line">    --set-upstream                               <span class="comment"># 由于此选项具有混淆语法，因此不再支持。请使用--track或--set-upstream-to替代</span></span><br><span class="line">    -u &lt;upstream&gt;, --set-upstream-to=&lt;upstream&gt;  <span class="comment"># 设置&lt;branchname&gt;的跟踪信息，以便&lt;upstream&gt;被视为&lt;branchname&gt;的上游分支。如果未指定&lt;branchname&gt;，则默认为当前分支。</span></span><br><span class="line">    --unset-upstream                             <span class="comment"># 删除&lt;branchname&gt;的上游信息。如果未指定分支，则默认为当前分支</span></span><br><span class="line">    --edit-description                           <span class="comment"># 打开一个编辑器，编辑文本解释分支是干什么用的，通过其他各种命令使用（例如format-patch， request-pull和merge（如果启用））</span></span><br><span class="line">    --contains [&lt;commit&gt;]                        <span class="comment"># 只列出包含指定提交的分支（如果未指定，则为HEAD）。意味着--list</span></span><br><span class="line">    --no-contains [&lt;commit&gt;]                     <span class="comment"># 只列出不包含指定提交的分支（如果未指定，则为HEAD）。意味着--list</span></span><br><span class="line">    --merged [&lt;commit&gt;]                          <span class="comment"># 仅列出可从指定提交中获得提示的分支（如果未指定，则为HEAD）。暗示--list，不符合--no-merged</span></span><br><span class="line">    --no-merged [&lt;commit&gt;]                       <span class="comment"># 只列出提示无法从指定提交中获得的分支（如果未指定，则为HEAD）。暗示--list，不符合--merged</span></span><br><span class="line">    &lt;branchname&gt;                                 <span class="comment"># 要创建或删除的分支的名称</span></span><br><span class="line">    &lt;start-point&gt;                                <span class="comment"># 新的分支头将指向这个提交</span></span><br><span class="line">    &lt;oldbranch&gt;                                  <span class="comment"># 要重命名的现有分支的名称    </span></span><br><span class="line">    &lt;newbranch&gt;                                  <span class="comment"># 现有分支的新名称</span></span><br><span class="line">    --sort=&lt;key&gt;                                 <span class="comment"># 根据给定的关键字进行排序</span></span><br><span class="line">    --points-at &lt;object&gt;                         <span class="comment"># 只列出给定对象的分支</span></span><br><span class="line">    --format &lt;format&gt;                            <span class="comment"># 从显示的分支ref 中插入的字符串以及它指向的对象。格式与git-for-each-ref [1]的格式相同</span></span><br></pre></td></tr></table></figure><h2 id="89-git-checkout"><a class="markdownIt-Anchor" href="#89-git-checkout"></a> 8.9. git checkout</h2><p>检出命令，用于创建、切换分支等。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 切换到已存在的指定分支</span></span><br><span class="line">$ git checkout &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，保留所有的提交记录</span></span><br><span class="line"><span class="comment"># 等同于 &quot;git branch&quot; 和 &quot;git checkout&quot; 两个命令合并</span></span><br><span class="line">$ git checkout -b &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 创建并切换到指定的分支，删除所有的提交记录</span></span><br><span class="line">$ git checkout --orphan &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 替换掉本地的改动，新增的文件和已经添加到暂存区的内容不受影响</span></span><br><span class="line">$ git checkout &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git checkout [-q] [-f] [-m] [&lt;branch&gt;]</span><br><span class="line">    git checkout [-q] [-f] [-m] --detach [&lt;branch&gt;]</span><br><span class="line">    git checkout [-q] [-f] [-m] [--detach] &lt;commit&gt;</span><br><span class="line">    git checkout [-q] [-f] [-m] [[-b|-B|--orphan] &lt;new_branch&gt;] [&lt;start_point&gt;]</span><br><span class="line">    git checkout [-f|--ours|--theirs|-m|--conflict=&lt;style&gt;] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…</span><br><span class="line">    git checkout [&lt;tree-ish&gt;] [--] &lt;pathspec&gt;…</span><br><span class="line">    git checkout (-p|--patch) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -q, --quiet                     <span class="comment"># 抑制反馈信息</span></span><br><span class="line">    --[no-]progress                 <span class="comment"># 除非--quiet 已指定，否则标准错误流默认情况下会将其连接到终端时报告进度状态</span></span><br><span class="line">    -f, --force                     <span class="comment"># 切换分支时，即使索引或工作树与HEAD不同，也要继续。这用于丢弃本地更改</span></span><br><span class="line">    --ours, --theirs                <span class="comment"># 当从索引中检出路径时，请检查第2阶段(ours)或第3阶段(theirs)是否有未合并的路径</span></span><br><span class="line">    -b &lt;new_branch&gt;                 <span class="comment"># 创建一个名为&lt;new_branch&gt;的新分支并在&lt;start_point&gt;处启动它</span></span><br><span class="line">    -B &lt;new_branch&gt;                 <span class="comment"># 创建分支&lt;new_branch&gt;并在&lt;start_point&gt;处启动它</span></span><br><span class="line">    -t, --track                     <span class="comment"># 创建新分支时，设置“上游”配置</span></span><br><span class="line">    --no-track                      <span class="comment"># 即使branch.autoSetupMerge配置变量为true，也不要设置“上游”配置</span></span><br><span class="line">    -l                              <span class="comment"># 创建新分支的reflog</span></span><br><span class="line">    --detach                        <span class="comment"># 而不是检查一个分支来处理它，检查提交检查和可废弃的实验</span></span><br><span class="line">    --orphan &lt;new_branch&gt;           <span class="comment"># 创建一个名为&lt;new_branch&gt; 的新孤立分支，从&lt;start_point&gt;开始并切换到该分支</span></span><br><span class="line">    --ignore-skip-worktree-bits     <span class="comment"># 在稀疏结帐模式下，git checkout -- &lt;paths&gt;只会更新$GIT_DIR/info/sparse-checkout中由&lt;路径&gt;和稀疏模式匹配的条目</span></span><br><span class="line">    -m, --merge                     <span class="comment"># 在切换分支时，如果对当前分支与切换到的分支之间的一个或多个文件进行本地修改，则该命令将拒绝切换分支以便在上下文中保留修改</span></span><br><span class="line">    --conflict=&lt;style&gt;              <span class="comment"># 与上面的--merge选项相同，但改变了冲突的区块显示方式，覆盖merge.conflictStyle配置变量</span></span><br><span class="line">    -p, --patch                     <span class="comment"># 在&lt;tree-ish&gt;（或索引，如果未指定）和工作树之间的区别中交互地选择hunk。然后将选定的区块反向应用于工作树（并且如果指定了&lt;tree-ish&gt;，则索引）</span></span><br><span class="line">    --ignore-other-worktrees        <span class="comment"># git checkout当被通缉的裁判已经被另一个工作树签出时拒绝。这个选项使它无论如何检查裁判</span></span><br><span class="line">    --[no-]recurse-submodules       <span class="comment"># 使用--recurse子模块将根据超级项目中记录的提交更新所有已初始化的子模块的内容</span></span><br><span class="line">    &lt;branch&gt;                        <span class="comment"># 分支, 如果它引用了一个分支（即，前缀为“refs/heads/”的名称是有效的ref），那么该分支将被签出</span></span><br><span class="line">    &lt;new_branch&gt;                    <span class="comment"># 新分支的名称</span></span><br><span class="line">    &lt;start_point&gt;                   <span class="comment"># 要开始新分支的提交的名称</span></span><br><span class="line">    &lt;tree-ish&gt;                      <span class="comment"># 要检出的树（当有路径时）。如果未指定，则会使用索引</span></span><br></pre></td></tr></table></figure><h2 id="810-git-rebase"><a class="markdownIt-Anchor" href="#810-git-rebase"></a> 8.10. git rebase</h2><p>rebase命令执行后，实际上是将分支点从C移到了G，这样分支也就具有了从C到G的功能</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git rebase [-i | --interactive] [options] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;]</span><br><span class="line">        [&lt;upstream&gt; [&lt;branch&gt;]]</span><br><span class="line">    git rebase [-i | --interactive] [options] [--<span class="built_in">exec</span> &lt;cmd&gt;] [--onto &lt;newbase&gt;]</span><br><span class="line">        --root [&lt;branch&gt;]</span><br><span class="line">    git rebase --<span class="built_in">continue</span> | --skip | --abort | --quit | --edit-todo | --show-current-patch  </span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    --onto &lt;newbase&gt;                      <span class="comment"># 创建新提交的起点</span></span><br><span class="line">    &lt;upstream&gt;                            <span class="comment"># 上游分支进行比较。可以是任何有效的提交，而不仅仅是现有的分支名称。默认为当前分支的配置上游</span></span><br><span class="line">    &lt;branch&gt;                              <span class="comment"># 工作分部; 默认为HEAD</span></span><br><span class="line">    --<span class="built_in">continue</span>                            <span class="comment"># 解决了合并冲突后重新启动重新绑定过程</span></span><br><span class="line">    --abort                               <span class="comment"># 中止rebase操作并将HEAD重置为原始分支</span></span><br><span class="line">    --quit                                <span class="comment"># 放弃rebase操作，但HEAD不会重置回原始分支。索引和工作树也因此保持不变</span></span><br><span class="line">    --keep-empty                          <span class="comment"># 在结果中保留不改变父项的任何提交</span></span><br><span class="line">    --allow-empty-message                 <span class="comment"># 默认情况下，重新绑定提交空信息将失败</span></span><br><span class="line">    --skip                                <span class="comment"># 通过跳过当前补丁重新启动重新绑定过程</span></span><br><span class="line">    --edit-todo                           <span class="comment"># 在交互式重新绑定期间编辑待办事项列表</span></span><br><span class="line">    --show-current-patch                  <span class="comment"># 在交互式底图中显示当前的补丁，或者由于冲突而停止底牌。这相当于 git show REBASE_HEAD</span></span><br><span class="line">    -m, --merge                           <span class="comment"># 使用合并策略来重新分配</span></span><br><span class="line">    -s &lt;strategy&gt;, --strategy=&lt;strategy&gt;  <span class="comment"># 使用给定的合并策略</span></span><br><span class="line">    -X &lt;strategy-option&gt;, --strategy-option=&lt;strategy-option&gt;    <span class="comment"># 将&lt;strategy-option&gt;传递给合并策略</span></span><br><span class="line">    -S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;]               <span class="comment"># GPG标志提交</span></span><br><span class="line">    -q, --quiet                                     <span class="comment"># 安静。意味着 - 无统计</span></span><br><span class="line">    -v, --verbose                                   <span class="comment"># 详细。意味着--stat</span></span><br><span class="line">    -<span class="built_in">stat</span>                                           <span class="comment"># 显示自上次rebase以来上游变化的差异。diffstat也由配置选项rebase.stat控制</span></span><br><span class="line">    -n, --no-stat                                   <span class="comment"># 不要将diffstat显示为rebase过程的一部分</span></span><br><span class="line">    --no-verify                                     <span class="comment"># 此选项绕过预先重新绑定钩子</span></span><br><span class="line">    --verify                                        <span class="comment"># 允许预重贴挂钩运行，这是默认设置</span></span><br><span class="line">    -C&lt;n&gt;                                           <span class="comment"># 确保每次更改之前和之后至少有&lt;n&gt;行周围环境匹配</span></span><br><span class="line">    -f, --force-rebase                              <span class="comment"># 即使当前分支是最新的，并且--force没有做任何事情的命令也不会返回，强制重新分配</span></span><br><span class="line">    --fork-point, --no-fork-point                   <span class="comment"># 计算&lt;branch&gt;引入的提交时，使用reflog可以在&lt;upstream&gt;和&lt;branch&gt;之间找到更好的共同祖先</span></span><br><span class="line">    --ignore-whitespace, --whitespace=&lt;option&gt;      <span class="comment"># 这些标志被传递给应用该补丁的git apply程序。与--interactive选项不兼容</span></span><br><span class="line">    --committer-date-is-author-date, --ignore-date  <span class="comment"># 这些标志被传递给git am以轻松地改变重新发布的提交的日期。与--interactive选项不兼容。</span></span><br><span class="line">    --signoff                                       <span class="comment"># 这个标志被传递给git am签署所有重新提交的提交。与--interactive选项不兼容。</span></span><br><span class="line">    -i, --interactive                               <span class="comment"># 列出将要重新分配的提交列表。让用户在重新绑定之前编辑该列表</span></span><br><span class="line">    -p, --preserve-merges                           <span class="comment"># 重新创建合并提交，而不是通过重播合并提交引入的提交来平坦化历史</span></span><br><span class="line">    -x &lt;cmd&gt;, --<span class="built_in">exec</span> &lt;cmd&gt;                          <span class="comment"># 在每行在最终历史记录中创建提交后附加“exec &lt;cmd&gt;”。&lt;cmd&gt;将被解释为一个或多个shell命令</span></span><br><span class="line">    --root                                          <span class="comment"># 重新规划从&lt;branch&gt;可访问的所有提交，而不是用&lt;upstream&gt;限制它们</span></span><br><span class="line">    --autosquash, --no-autosquash                   <span class="comment"># 当提交日志消息以“squash！...”（或“fixup！...”）开始时，并且在待办事项列表中已经有一个与之相匹配的提交时...，                                                      会自动修改rebase -i的待办事项列表，以便被标记为压扁的提交在提交被修改后立即出现，并将被提交的提交的操作从（或）pick改为</span></span><br><span class="line">    --autostash, --no-autostash                     <span class="comment"># 在操作开始之前自动创建临时存储条目，并在操作结束后应用它</span></span><br><span class="line">    --no-ff                                         <span class="comment"># 与-interactive，cherry-pick所有基于rebased的提交，而不是快速转发到未更改的</span></span><br></pre></td></tr></table></figure><h2 id="811-git-revert"><a class="markdownIt-Anchor" href="#811-git-revert"></a> 8.11. git revert</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git revert [--[no-]edit] [-n] [-m parent-number] [-s] [-S[&lt;keyid&gt;]] &lt;commit&gt;…</span><br><span class="line">    git revert --<span class="built_in">continue</span></span><br><span class="line">    git revert --quit</span><br><span class="line">    git revert --abort</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    &lt;commit&gt;…                                    <span class="comment"># 承诺恢复。有关拼写提交名称的更完整列表</span></span><br><span class="line">    -e, --edit                                   <span class="comment"># 使用这个选项，git revert可以让你在提交恢复之前编辑提交信息</span></span><br><span class="line">    -m parent-number, --mainline parent-number   <span class="comment"># 通常您无法恢复合并，因为您不知道合并的哪一方应被视为主线</span></span><br><span class="line">    --no-edit                                    <span class="comment"># 使用这个选项，git revert不会启动提交消息编辑器</span></span><br><span class="line">    -n, --no-commit                              <span class="comment"># 通常，该命令会自动创建一些提交日志消息，提交哪些提交已恢复</span></span><br><span class="line">    -S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;]            <span class="comment"># GPG标志提交。该keyid参数是可选的，并且默认为提交者身份; 如果指定，它必须粘贴到选项没有空格。</span></span><br><span class="line">    -s, --signoff                                <span class="comment"># 在提交消息的末尾添加Signed-off-by行</span></span><br><span class="line">    --strategy=&lt;strategy&gt;                        <span class="comment"># 使用给定的合并策略</span></span><br><span class="line">    -X&lt;option&gt;, --strategy-option=&lt;option&gt;       <span class="comment"># 将合并策略特定选项传递给合并策略</span></span><br><span class="line">    --<span class="built_in">continue</span>                                   <span class="comment"># 继续使用.git/sequencer中的信息进行操作</span></span><br><span class="line">    --quit                                       <span class="comment"># 忘记当前正在进行的操作。可用于在失败的cherry-pick或还原后清除排序器状态</span></span><br><span class="line">    --abort                                      <span class="comment"># 取消操作并返回到预序列状态</span></span><br></pre></td></tr></table></figure><h2 id="812-git-bisect"><a class="markdownIt-Anchor" href="#812-git-bisect"></a> 8.12. git bisect</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git bisect &lt;subcommand&gt; &lt;options&gt;</span><br><span class="line">    git bisect start [--term-&#123;old,good&#125;=&lt;term&gt; --term-&#123;new,bad&#125;=&lt;term&gt;]</span><br><span class="line">        [--no-checkout] [&lt;bad&gt; [&lt;good&gt;...]] [--] [&lt;paths&gt;...]</span><br><span class="line">    git bisect (bad|new|&lt;term-new&gt;) [&lt;rev&gt;]</span><br><span class="line">    git bisect (good|old|&lt;term-old&gt;) [&lt;rev&gt;...]</span><br><span class="line">    git bisect terms [--term-good | --term-bad]</span><br><span class="line">    git bisect skip [(&lt;rev&gt;|&lt;range&gt;)...]</span><br><span class="line">    git bisect reset [&lt;commit&gt;]</span><br><span class="line">    git bisect (visualize|view)</span><br><span class="line">    git bisect replay &lt;logfile&gt;</span><br><span class="line">    git bisect <span class="built_in">log</span></span><br><span class="line">    git bisect run &lt;cmd&gt;...</span><br><span class="line">    git bisect <span class="built_in">help</span></span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    --no-checkout                      <span class="comment"># 在平分过程的每次迭代中，不要签出新的工作树</span></span><br></pre></td></tr></table></figure><h2 id="813-git-blame"><a class="markdownIt-Anchor" href="#813-git-blame"></a> 8.13. git blame</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git blame [-c] [-b] [-l] [--root] [-t] [-f] [-n] [-s] [-e] [-p] [-w] [--incremental]</span><br><span class="line">            [-L &lt;range&gt;] [-S &lt;revs-file&gt;] [-M] [-C] [-C] [-C] [--since=&lt;date&gt;]</span><br><span class="line">            [--progress] [--abbrev=&lt;n&gt;] [&lt;rev&gt; | --contents &lt;file&gt; | --reverse &lt;rev&gt;..&lt;rev&gt;]</span><br><span class="line">            [--] &lt;file&gt;</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -b                                  <span class="comment"># 显示边界提交的空白SHA-1。这也可以通过blame.blankboundary配置选项来控制</span></span><br><span class="line">    --root                              <span class="comment"># 不要将根提交视为边界。这也可以通过blame.showRoot配置选项来控制</span></span><br><span class="line">    --show-stats                        <span class="comment"># 在责备输出结尾包含更多统计数据</span></span><br><span class="line">    -L &lt;start&gt;, &lt;end&gt;, -L :&lt;funcname&gt;   <span class="comment"># 仅注释给定的线范围。可以多次指定。重叠范围是允许的</span></span><br><span class="line">    -l                                  <span class="comment"># 显示长时间（默认：关闭）</span></span><br><span class="line">    -t                                  <span class="comment"># 显示原始时间戳（默认值：关闭）</span></span><br><span class="line">    -S &lt;revs-file&gt;                      <span class="comment"># 使用revs-file中的修订版而不是调用git-rev-list [1]</span></span><br><span class="line">    --reverse &lt;rev&gt;..&lt;rev&gt;              <span class="comment"># 前进而不是后退。它不是显示一行出现的修订，而是显示一行存在的最后修订</span></span><br><span class="line">    -p, --porcelain                     <span class="comment"># 以设计用于机器消耗的格式显示</span></span><br><span class="line">    --line-porcelain                    <span class="comment"># 显示porcelain格式，但输出每行的提交信息，而不仅仅是第一次引用提交</span></span><br><span class="line">    --incremental                       <span class="comment"># 以设计用于机器消耗的格式逐步显示结果</span></span><br><span class="line">    --encoding=&lt;encoding&gt;               <span class="comment"># 指定用于输出作者姓名和提交摘要的编码。将其设置为none使责备输出未转换的数据</span></span><br><span class="line">    --contents &lt;file&gt;                   <span class="comment"># 当未指定&lt;rev&gt;时，该命令注释从工作树副本向后开始的更改</span></span><br><span class="line">    --date &lt;format&gt;                     <span class="comment"># 指定用于输出日期的格式</span></span><br><span class="line">    --[no-]progress                     <span class="comment"># 当连接到终端时，默认情况下标准错误流会报告进度状态</span></span><br><span class="line">    -M[&lt;num&gt;]                           <span class="comment"># 检测文件中移动或复制的行</span></span><br><span class="line">    -C[&lt;num&gt;]                           <span class="comment"># 除了-M检测从同一提交中修改的其他文件移动或复制的行之外</span></span><br><span class="line">    -h                                  <span class="comment"># 显示帮助信息</span></span><br><span class="line">    -c                                  <span class="comment"># 使用与git-annotate [1]相同的输出模式（默认值：关闭）</span></span><br><span class="line">    --score-debug                       <span class="comment"># 包含与文件之间的行移动有关的调试信息和文件中移动的行</span></span><br><span class="line">    -f, --show-name                     <span class="comment"># 在原始提交中显示文件名</span></span><br><span class="line">    -n, --show-number                   <span class="comment"># 在原始提交中显示行号（默认值：关闭）</span></span><br><span class="line">    -s                                  <span class="comment"># 从输出中抑制作者姓名和时间戳</span></span><br><span class="line">    -e, --show-email                    <span class="comment"># 显示作者电子邮件而不是作者姓名（默认：关闭）</span></span><br><span class="line">    -w                                  <span class="comment"># 在比较父版本和子版本时，忽略空白，并找出这些行来自哪里</span></span><br><span class="line">    --abbrev=&lt;n&gt;                        <span class="comment"># 使用默认的7 + 1十六进制数字作为缩写对象名称，而不是使用&lt;n&gt; +1个数字</span></span><br></pre></td></tr></table></figure><h2 id="814-git-grep"><a class="markdownIt-Anchor" href="#814-git-grep"></a> 8.14. git grep</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git grep [-a | --text] [-I] [--textconv] [-i | --ignore-case] [-w | --word-regexp]</span><br><span class="line">           [-v | --invert-match] [-h|-H] [--full-name]</span><br><span class="line">           [-E | --extended-regexp] [-G | --basic-regexp]</span><br><span class="line">           [-P | --perl-regexp]</span><br><span class="line">           [-F | --fixed-strings] [-n | --line-number]</span><br><span class="line">           [-l | --files-with-matches] [-L | --files-without-match]</span><br><span class="line">           [(-O | --open-files-in-pager) [&lt;pager&gt;]]</span><br><span class="line">           [-z | --null]</span><br><span class="line">           [-c | --count] [--all-match] [-q | --quiet]</span><br><span class="line">           [--max-depth &lt;depth&gt;]</span><br><span class="line">           [--color[=&lt;when&gt;] | --no-color]</span><br><span class="line">           [--<span class="built_in">break</span>] [--heading] [-p | --show-function]</span><br><span class="line">           [-A &lt;post-context&gt;] [-B &lt;pre-context&gt;] [-C &lt;context&gt;]</span><br><span class="line">           [-W | --function-context]</span><br><span class="line">           [--threads &lt;num&gt;]</span><br><span class="line">           [-f &lt;file&gt;] [-e] &lt;pattern&gt;</span><br><span class="line">           [--and|--or|--not|(|)|-e &lt;pattern&gt;…]</span><br><span class="line">           [--recurse-submodules] [--parent-basename &lt;basename&gt;]</span><br><span class="line">           [ [--[no-]exclude-standard] [--cached | --no-index | --untracked] | &lt;tree&gt;…]</span><br><span class="line">           [--] [&lt;pathspec&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    --cached                                     <span class="comment"># 在平分过程的每次迭代中，不要签出新的工作树</span></span><br><span class="line">    --no-index                                   <span class="comment"># 搜索当前目录中不受Git管理的文件</span></span><br><span class="line">    --untracked                                  <span class="comment"># 除了在工作树中跟踪文件中搜索外，还可以在未跟踪文件中搜索</span></span><br><span class="line">    --no-exclude-standard                        <span class="comment"># 通过不尊重.gitignore 机制来搜索被忽略的文件。只用于--untracked</span></span><br><span class="line">    --exclude-standard                           <span class="comment"># 不要关注通过.gitignore 机制指定的忽略文件，仅在使用当前目录搜索文件时有用--no-index</span></span><br><span class="line">    --recurse-submodules                         <span class="comment"># 递归搜索已在存储库中初始化并检出的每个子模块</span></span><br><span class="line">    -a, --text                                   <span class="comment"># 像处理文本一样处理二进制文件</span></span><br><span class="line">    --textconv                                   <span class="comment"># 尊重textconv过滤器设置</span></span><br><span class="line">    --no-textconv                                <span class="comment"># 不要兑现textconv过滤器设置。这是默认设置</span></span><br><span class="line">    -i, --ignore-case                            <span class="comment"># 忽略模式和文件之间的大小写区别</span></span><br><span class="line">    -I                                           <span class="comment"># 不匹配二进制文件中的模式</span></span><br><span class="line">    --max-depth &lt;depth&gt;                          <span class="comment"># 对于命令行中给出的每个&lt;pathspec&gt;，最多下降&lt;depth&gt;级别的目录</span></span><br><span class="line">    -w, --word-regexp                            <span class="comment"># 仅在字边界处匹配模式</span></span><br><span class="line">    -v, --invert-match                           <span class="comment"># 选择不匹配的行</span></span><br><span class="line">    -h, -H                                       <span class="comment"># 默认情况下，该命令显示每个匹配的文件名</span></span><br><span class="line">    --full-name                                  <span class="comment"># 从子目录运行时，该命令通常会输出相对于当前目录的路径    </span></span><br><span class="line">    -E, --extended-regexp, -G, --basic-regexp    <span class="comment"># 对于模式使用POSIX扩展/基本正则表达式。默认是使用基本的正则表达式</span></span><br><span class="line">    -P, --perl-regexp                            <span class="comment"># 为模式使用Perl兼容的正则表达式</span></span><br><span class="line">    -F, --fixed-strings                          <span class="comment"># 使用固定字符串模式</span></span><br><span class="line">    -n, --line-number                            <span class="comment"># 在行号前加上匹配的行</span></span><br><span class="line">    -l, --files-with-matches, --name-only, -L, --files-without-match    <span class="comment"># 不显示每条匹配的行，只显示包含（或不包含）匹配的文件的名称</span></span><br><span class="line">    -O[&lt;pager&gt;], --open-files-in-pager[=&lt;pager&gt;] <span class="comment"># 打开寻呼机中的匹配文件（不是grep的输出）</span></span><br><span class="line">    -z, --null                                   <span class="comment"># 输出\ 0而不是通常跟在文件名后的字符    </span></span><br><span class="line">    -c, --count                                  <span class="comment"># 显示匹配的行数，而不是显示每条匹配的行</span></span><br><span class="line">    --color[=&lt;when&gt;]                             <span class="comment"># 显示彩色的比赛。该值必须始终（默认），永不，或自动</span></span><br><span class="line">    --no-color                                   <span class="comment"># 关闭匹配突出显示，即使配置文件将默认设置为彩色输出。和...一样--color=never</span></span><br><span class="line">    --<span class="built_in">break</span>                                      <span class="comment"># 在不同文件的匹配之间打印空行</span></span><br><span class="line">    --heading                                    <span class="comment"># 在文件的上方显示文件名，而不是在每个显示的行的开头</span></span><br><span class="line">    -p, --show-function                          <span class="comment"># 显示包含匹配函数名称的上一行，除非匹配行是函数名称本身    </span></span><br><span class="line">    -&lt;num&gt;, -C &lt;num&gt;, --context &lt;num&gt;            <span class="comment"># 显示&lt;num&gt;前导和尾部线条，并放置包含--连续的匹配组之间的线条</span></span><br><span class="line">    -A &lt;num&gt;, --after-context &lt;num&gt;              <span class="comment"># 显示&lt;num&gt;尾随线，并--在连续的匹配组之间放置一行 </span></span><br><span class="line">    -B &lt;num&gt;, --before-context &lt;num&gt;             <span class="comment"># 显示&lt;num&gt;引出线，并--在相邻的匹配组之间放置一行 </span></span><br><span class="line">    -W, --function-context                       <span class="comment"># 显示前一行中包含函数名称的周围文本，直到下一个函数名称之前的文本，从而有效地显示找到匹配的整个函数</span></span><br><span class="line">    --threads &lt;num&gt;                              <span class="comment"># 要使用的grep工作线程数</span></span><br><span class="line">    -f &lt;file&gt;                                    <span class="comment"># 从&lt;file&gt;中读取模式，每行一个</span></span><br><span class="line">    -e                                           <span class="comment"># 下一个参数是模式</span></span><br><span class="line">    --and, --or, --not, ( … )                    <span class="comment"># 指定如何使用布尔表达式组合多个模式</span></span><br><span class="line">    --all-match                                  <span class="comment"># 将多个模式表达式结合使用时--or，会指定此标志以将匹配限制为具有与其匹配的所有行的文件</span></span><br><span class="line">    -q, --quiet                                  <span class="comment"># 不输出匹配的行</span></span><br><span class="line">    &lt;tree&gt;…                                      <span class="comment"># 而不是在工作树中搜索跟踪文件，搜索给定树中的斑点</span></span><br><span class="line">    --                                           <span class="comment"># 表示选项结束; 其余的参数是&lt;pathspec&gt;限制器</span></span><br><span class="line">    &lt;pathspec&gt;…                                  <span class="comment"># 如果给定，则将搜索限制为至少匹配一个模式的路径</span></span><br></pre></td></tr></table></figure><h2 id="815-git-stash"><a class="markdownIt-Anchor" href="#815-git-stash"></a> 8.15. git stash</h2><p>将当前未提交的工作存入Git工作栈中，时机成熟的时候再应用回来</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git stash list [&lt;options&gt;]</span><br><span class="line">    git stash show [&lt;stash&gt;]</span><br><span class="line">    git stash drop [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">    git stash ( pop | apply ) [--index] [-q|--quiet] [&lt;stash&gt;]</span><br><span class="line">    git stash branch &lt;branchname&gt; [&lt;stash&gt;]</span><br><span class="line">    git stash [push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]</span><br><span class="line">             [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]</span><br><span class="line">             [--] [&lt;pathspec&gt;…]]</span><br><span class="line">    git stash clear</span><br><span class="line">    git stash create [&lt;message&gt;]</span><br><span class="line">    git stash store [-m|--message &lt;message&gt;] [-q|--quiet] &lt;commit&gt;</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    push [-p|--patch] [-k|--[no-]keep-index] [-q|--quiet]        </span><br><span class="line">        [-u|--include-untracked] [-a|--all] [-m|--message &lt;message&gt;]</span><br><span class="line">        [--] [&lt;pathspec&gt;…]                 <span class="comment"># 将您的本地修改保存到新的存储条目中，并将它们回滚到HEAD（在工作树和索引中）</span></span><br><span class="line">    list [&lt;options&gt;]                       <span class="comment"># 列出您当前拥有的存储条目</span></span><br><span class="line">    show [&lt;stash&gt;]                         <span class="comment"># 显示存储条目中记录的更改，作为隐藏内容和提交首次创建存储条目时的提交之间的差异</span></span><br><span class="line">    pop [--index] [-q|--quiet] [&lt;stash&gt;]   <span class="comment"># 从存储列表中删除一个单独的存储状态并将其应用于当前工作树状态的顶部，即进行反操作git stash push。工作目录必须与索引匹配</span></span><br><span class="line">    apply [--index] [-q|--quiet] [&lt;stash&gt;] <span class="comment"># 喜欢pop，但不要从存储列表中删除状态。不像pop， &lt;stash&gt;可能是任何看起来像由stash pushor 创建的提交 stash create</span></span><br><span class="line">    branch &lt;branchname&gt; [&lt;stash&gt;]          <span class="comment"># 创建并检出&lt;branchname&gt;从&lt;stash&gt;最初创建的提交开始的新分支，将记录的更改应用&lt;stash&gt;到新的工作树和索引</span></span><br><span class="line">    clear                                  <span class="comment"># 删除所有的存储条目</span></span><br><span class="line">    drop [-q|--quiet] [&lt;stash&gt;]            <span class="comment"># 从存储条目列表中删除单个存储条目。如果没有&lt;stash&gt;给出，它将删除最新的一个</span></span><br><span class="line">    create                                 <span class="comment"># 创建一个存储条目（这是一个常规的提交对象）并返回它的对象名称，而不将它存储在ref命名空间的任何位置</span></span><br><span class="line">    store                                  <span class="comment"># 在存储引用中存储通过git stash create（这是一个悬挂的合并提交）创建的给定存储，更新存储引用日志</span></span><br></pre></td></tr></table></figure><h2 id="816-git-cherry-pick"><a class="markdownIt-Anchor" href="#816-git-cherry-pick"></a> 8.16. git cherry-pick</h2><p>把已经提交的记录合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把已经提交的记录合并到当前分支</span></span><br><span class="line">$ git cherry-pick &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git cherry-pick [--edit] [-n] [-m parent-number] [-s] [-x] [--ff]</span><br><span class="line">              [-S[&lt;keyid&gt;]] &lt;commit&gt;…​</span><br><span class="line">    git cherry-pick --<span class="built_in">continue</span></span><br><span class="line">    git cherry-pick --quit</span><br><span class="line">    git cherry-pick --abort</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    &lt;commit&gt;…​                                    <span class="comment"># 要获得一个更完整的拼写方法列表</span></span><br><span class="line">    -e, --edit                                   <span class="comment"># 使用这个选项，git cherry-pick会让你在提交之前编辑提交信息</span></span><br><span class="line">    -x                                           <span class="comment"># 在记录提交时，附加一条线，该行表示“(cherry从提交…)”到原始的提交消息，以指示该更改是从哪个提交的</span></span><br><span class="line">    -r                                           <span class="comment"># 它曾经是命令默认做-x 了上面描述，并且-r是禁用它</span></span><br><span class="line">    -m parent-number, --mainline parent-number   <span class="comment"># 通常你不能选择合并，因为你不知道合并的哪一边应该被认为是主线</span></span><br><span class="line">    -n, --no-commit                              <span class="comment"># 通常，该命令会自动创建一系列提交</span></span><br><span class="line">    -s, --signoff                                <span class="comment"># 在提交消息的末尾添加Signed-off-by行</span></span><br><span class="line">    -S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;]            <span class="comment"># GPG标志提交</span></span><br><span class="line">    --ff                                         <span class="comment"># 如果当前的HEAD与樱桃挑选的提交的父对象相同，则将执行快速转发此提交</span></span><br><span class="line">    --allow-empty                                <span class="comment"># 默认情况下，樱桃选择一个空的提交将失败，表明需要显式调用git commit --allow-empty</span></span><br><span class="line">    --allow-empty-message                        <span class="comment"># 默认情况下，用空信息挑选提交将失败</span></span><br><span class="line">    --keep-redundant-commits                     <span class="comment"># 如果在当前的历史中，如果提交的是cherry选择了重复提交，那么它将变为空的</span></span><br><span class="line">    --strategy=&lt;strategy&gt;                        <span class="comment"># 使用给定的合并策略。只能使用一次</span></span><br><span class="line">    -X&lt;option&gt;, --strategy-option=&lt;option&gt;       <span class="comment"># 将合并策略特定选项传递给合并策略</span></span><br><span class="line">    --<span class="built_in">continue</span>                                   <span class="comment"># 继续使用.git/sequencer中的信息进行操作</span></span><br><span class="line">    --quit                                       <span class="comment"># 忘记当前正在进行的操作</span></span><br><span class="line">    --abort                                      <span class="comment"># 取消操作并返回到预序列状态</span></span><br></pre></td></tr></table></figure><h2 id="817-git-add"><a class="markdownIt-Anchor" href="#817-git-add"></a> 8.17. git add</h2><p>把要提交的文件的信息添加到暂存区中。当使用 git commit 时，将依据暂存区中的内容来进行文件的提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把指定的文件添加到暂存区中</span></span><br><span class="line">$ git add &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除的文件到暂存区中</span></span><br><span class="line">$ git add -u [&lt;文件路径&gt;]</span><br><span class="line">$ git add --update [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加所有修改、已删除、新增的文件到暂存区中，省略 &lt;文件路径&gt; 即为当前目录</span></span><br><span class="line">$ git add -A [&lt;文件路径&gt;]</span><br><span class="line">$ git add --all [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看所有修改、已删除但没有提交的文件，进入一个子命令系统</span></span><br><span class="line">$ git add -i [&lt;文件路径&gt;]</span><br><span class="line">$ git add --interactive [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git add [--verbose | -v] [--dry-run | -n] [--force | -f] [--interactive | -i] [--patch | -p]</span><br><span class="line">        [--edit | -e] [--[no-]all | --[no-]ignore-removal | [--update | -u]]</span><br><span class="line">        [--intent-to-add | -N] [--refresh] [--ignore-errors] [--ignore-missing] [--renormalize]</span><br><span class="line">        [--chmod=(+|-)x] [--] [&lt;pathspec&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -v, --verbose                   <span class="comment"># 详细</span></span><br><span class="line">    -n, --dry-run                   <span class="comment"># 不要实际添加文件, 只显示它们是否存在和/或将被忽略</span></span><br><span class="line">    -f, --force                     <span class="comment"># 允许添加被忽略的文件</span></span><br><span class="line">    -i, --interactive               <span class="comment"># 在工作树中交互添加修改的内容到索引</span></span><br><span class="line">    -p, --patch                     <span class="comment"># 在索引和工作树之间交互地选择补丁块, 并将它们添加到索引中</span></span><br><span class="line">    -e, --edit                      <span class="comment"># 在编辑器中打开差异与索引并让用户编辑它。编辑器关闭后, 调整大块头并将补丁应用到索引</span></span><br><span class="line">    -u, --update                    <span class="comment"># 更新已存在匹配&lt;pathspec&gt;条目的索引。这会删除和修改索引条目以匹配工作树, 但不会添加新文件</span></span><br><span class="line">    -A, --all, --no-ignore-removal  <span class="comment"># 更新索引不仅在工作树具有匹配&lt;pathspec&gt;的文件的位置, 而且索引已经有条目的位置这会添加，修改和删除索引条目以匹配工作树</span></span><br><span class="line">    --no-all, --ignore-removal      <span class="comment"># 通过添加索引未知的新文件和工作树中修改的文件来更新索引, 但忽略已从工作树中删除的文件当没有使用&lt;pathspec&gt;时，该选项是无操作的</span></span><br><span class="line">    -N, --intent-to-add             <span class="comment"># 只记录路径将在稍后添加的事实。路径条目放置在没有内容的索引中</span></span><br><span class="line">    --refresh                       <span class="comment"># 不要添加文件，而只需刷新索引中的stat()信息</span></span><br><span class="line">    --ignore-errors                 <span class="comment"># 如果某些文件因索引错误而无法添加, 请不要中止操作，而是继续添加其他文件</span></span><br><span class="line">    --ignore-missing                <span class="comment"># 该选项只能与--dry-run一起使用。用户可检查是否有给定的文件被忽略, 不管是否已存在于工作树中</span></span><br><span class="line">    --no-warn-embedded-repo         <span class="comment"># 默认情况下, git add向嵌入式存储库添加索引时会发出警告, 而不用git submodule add其中创建条目.gitmodules。该选项将会禁止警告</span></span><br><span class="line">    --renormalize                   <span class="comment"># 将新鲜的&quot;干净&quot;过程应用于所有跟踪的文件, 以强制将其再次添加到索引</span></span><br><span class="line">    --chmod=(+|-)x                  <span class="comment"># 覆盖添加文件的可执行位。可执行位仅在索引中更改, 磁盘上的文件保持不变。</span></span><br><span class="line">    --                              <span class="comment"># 此选项可用于将命令行选项与文件列表分开</span></span><br><span class="line">    &lt;pathspec&gt;…                     <span class="comment"># 要从中添加内容的文件。*.c可以给Fileglobs（例如）添加所有匹配的文件</span></span><br></pre></td></tr></table></figure><h2 id="818-git-commit"><a class="markdownIt-Anchor" href="#818-git-commit"></a> 8.18. git commit</h2><p>将暂存区中的文件提交到本地仓库中。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库，调用文本编辑器输入该次提交的描述信息</span></span><br><span class="line">$ git commit</span><br><span class="line"></span><br><span class="line"><span class="comment"># 把暂存区中的文件提交到本地仓库中并添加描述信息</span></span><br><span class="line">$ git commit -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 把所有修改、已删除的文件提交到本地仓库中</span></span><br><span class="line"><span class="comment"># 不包括未被版本库跟踪的文件，等同于先调用了 &quot;git add -u&quot;</span></span><br><span class="line">$ git commit -a -m <span class="string">&quot;&lt;提交的描述信息&gt;&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 修改上次提交的描述信息</span></span><br><span class="line">$ git commit --amend</span><br><span class="line"></span><br><span class="line"><span class="comment">#自动将日期添加到消息</span></span><br><span class="line">$ git commit -m <span class="string">&quot;updated files at `date +&#x27;%Y-%m-%d %H:%M:%S&#x27;`&quot;</span></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git commit [-a | --interactive | --patch] [-s] [-v] [-u&lt;mode&gt;] [--amend]</span><br><span class="line">       [--dry-run] [(-c | -C | --fixup | --squash) &lt;commit&gt;]</span><br><span class="line">       [-F &lt;file&gt; | -m &lt;msg&gt;] [--reset-author] [--allow-empty]</span><br><span class="line">       [--allow-empty-message] [--no-verify] [-e] [--author=&lt;author&gt;]</span><br><span class="line">       [--date=&lt;date&gt;] [--cleanup=&lt;mode&gt;] [--[no-]status]</span><br><span class="line">       [-i | -o] [-S[&lt;keyid&gt;]] [--] [&lt;file&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a, --all                               <span class="comment"># 告诉命令自动对已被修改和删除的文件进行分段处理，但没有告知Git的新文件不受影响</span></span><br><span class="line">    -p, --patch                             <span class="comment"># 使用交互式补丁选择界面来选择要提交的更改</span></span><br><span class="line">    -C &lt;commit&gt;, --reuse-message=&lt;commit&gt;   <span class="comment"># 取一个现有的提交对象，并在创建提交时重用日志消息和作者信息（包括时间戳）</span></span><br><span class="line">    -c &lt;commit&gt;, --reedit-message=&lt;commit&gt;  <span class="comment"># 像-C一样，但-c调用了编辑器，以便用户可以进一步编辑提交消息</span></span><br><span class="line">    --fixup=&lt;commit&gt;                        <span class="comment"># 构建一个提交消息以供使用rebase --autosquash。提交消息将成为指定提交的主题行，其前缀为“fixup！”</span></span><br><span class="line">    --squash=&lt;commit&gt;                       <span class="comment"># 构建一个提交消息以供使用rebase --autosquash。提交消息主题行取自指定的提交，前缀为“squash！”</span></span><br><span class="line">    --reset-author                          <span class="comment"># 当与-C / -c / - 修改选项一起使用时，或者在冲突樱桃挑选后提交时，声明结果提交的作者现在属于提交者</span></span><br><span class="line">    --short                                 <span class="comment"># 进行干运行时，请以短格式输出</span></span><br><span class="line">    --branch                                <span class="comment"># 甚至以短格式显示分支和跟踪信息</span></span><br><span class="line">    --porcelain                             <span class="comment"># 进行干式运行时，请将输出信号以瓷器准备好的格式输出</span></span><br><span class="line">    --long                                  <span class="comment"># 进行干式运行时，请以长格式输出</span></span><br><span class="line">    -z, --null                              <span class="comment"># 显示short或porcelain状态输出时，逐字打印文件名并用NUL而不是LF结束输入。如果没有给出格式，则表示--porcelain输出格式</span></span><br><span class="line">    -F &lt;file&gt;, --file=&lt;file&gt;                <span class="comment"># 从给定的文件中获取提交消息。使用-从标准输入中读取消息</span></span><br><span class="line">    --author=&lt;author&gt;                       <span class="comment"># 覆盖提交作者。使用标准A U Thor &lt;author@example.com&gt;格式指定明确的作者</span></span><br><span class="line">    --date=&lt;date&gt;                           <span class="comment"># 覆盖提交中使用的作者日期</span></span><br><span class="line">    -m &lt;msg&gt;, --message=&lt;msg&gt;               <span class="comment"># 使用给定的&lt;msg&gt;作为提交消息</span></span><br><span class="line">    -t &lt;file&gt;, --template=&lt;file&gt;            <span class="comment"># 编辑提交消息时，使用给定文件中的内容启动编辑器</span></span><br><span class="line">    -s, --signoff                           <span class="comment"># 提交日志消息结尾处的提交者添加Signed-off-by行</span></span><br><span class="line">    -n, --no-verify                         <span class="comment"># 该选项绕过预先提交和提交msg钩子</span></span><br><span class="line">    --allow-empty                           <span class="comment"># 通常记录具有与其唯一父提交完全相同的树的提交是个错误，并且该命令阻止您提交此类提交</span></span><br><span class="line">    --allow-empty-message                   <span class="comment"># 像--allow-empty这个命令主要供外国SCM接口脚本使用。它允许你使用空的提交消息创建一个提交，而不使用像git-commit-tree [1]命令 </span></span><br><span class="line">    --cleanup=&lt;mode&gt;                        <span class="comment"># 这个选项决定了在提交之前应该如何清理提供的提交消息。所述&lt;模式&gt;可以是strip， whitespace，verbatim，scissors或default</span></span><br><span class="line">    strip                                   <span class="comment"># 删除前导和尾随空行，尾随空白，评论和折叠连续的空行</span></span><br><span class="line">    whitespace                              <span class="comment"># 同strip除#commentary不会被删除</span></span><br><span class="line">    verbatim                                <span class="comment"># 根本不要改变信息</span></span><br><span class="line">    scissors                                <span class="comment"># 相同whitespace，除了一切从（并包括）下面找到的行被截短，如果消息是要被编辑</span></span><br><span class="line">    default                                 <span class="comment"># 就strip好像要编辑的消息一样。否则whitespace</span></span><br><span class="line">    -e, --edit                              <span class="comment"># 从文件提取的消息-F，命令行 -m和从提交对象中取出的消息-C通常用作未修改的提交日志消息</span></span><br><span class="line">    --no-edit                               <span class="comment"># 使用选定的提交消息而不启动编辑器。例如，git commit --amend --no-edit修改提交而不更改其提交消息</span></span><br><span class="line">    --amend                                 <span class="comment"># 通过创建一个新的提交来替换当前分支的提示</span></span><br><span class="line">    --no-post-rewrite                       <span class="comment"># 绕过重写挂钩</span></span><br><span class="line">    -i, --include                           <span class="comment"># 在到目前为止的阶段性内容提交之前，请在命令行上指定路径的内容。这通常不是你想要的，除非你正在完成一个冲突的合并。</span></span><br><span class="line">    -o, --only                              <span class="comment"># 通过获取命令行中指定路径的更新工作树内容来进行提交，而忽略已为其他路径执行的任何内容</span></span><br><span class="line">    -u[&lt;mode&gt;], --untracked-files[=&lt;mode&gt;]  <span class="comment"># 显示未跟踪的文件。模式可选的(默认为全部), 并用于指定未跟踪文件的处理; </span></span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　 当-u未被使用时，默认是正常的，即显示未跟踪的文件和目录。所述&lt;模式&gt;可以是no， normal，all</span><br><span class="line">    -v, --verbose                           <span class="comment"># 显示HEAD提交与提交消息模板底部提交的内容之间的统一差异，以帮助用户通过提醒提交具有哪些更改来描述提交</span></span><br><span class="line">    -q, --quiet                             <span class="comment"># 禁止提交摘要消息</span></span><br><span class="line">    --dry-run                               <span class="comment"># 不要创建提交,而是显示要提交的路径列表,包含将保留未提交的本地更改的路径以及未跟踪的路径</span></span><br><span class="line">    --status                                <span class="comment"># 使用编辑器准备提交消息时，在提交消息模板中包含git-status [1]的输出。默认为打开，但可用于覆盖配置变量commit.status。</span></span><br><span class="line">    --no-status                             <span class="comment"># 使用编辑器准备默认提交消息时，不要在提交消息模板中包含git-status [1]的输出。</span></span><br><span class="line">    -S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;]       <span class="comment"># GPG标志提交。该keyid参数是可选的，并且默认为提交者身份</span></span><br><span class="line">    --no-gpg-sign                           <span class="comment"># commit.gpgSign设置为强制每个提交进行签名的计数器配置变量</span></span><br><span class="line">    --                                      <span class="comment"># 不要将更多的参数解释为选项</span></span><br><span class="line">    &lt;file&gt;…                                 <span class="comment"># 当在命令行上给出文件时，该命令将提交指定文件的内容，而不记录已经执行的更改</span></span><br></pre></td></tr></table></figure><h2 id="819-git-fetch"><a class="markdownIt-Anchor" href="#819-git-fetch"></a> 8.19. git fetch</h2><p>从远程仓库获取最新的版本到本地的 tmp 分支上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 将远程仓库所有分支的最新版本全部取回到本地</span></span><br><span class="line">$ git fetch &lt;远程仓库的别名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将远程仓库指定分支的最新版本取回到本地</span></span><br><span class="line">$ git fetch &lt;远程主机名&gt; &lt;分支名&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git fetch [&lt;options&gt;] [&lt;repository&gt; [&lt;refspec&gt;…]]</span><br><span class="line">    git fetch [&lt;options&gt;] &lt;group&gt;</span><br><span class="line">    git fetch --multiple [&lt;options&gt;] [(&lt;repository&gt; | &lt;group&gt;)…]</span><br><span class="line">    git fetch --all [&lt;options&gt;]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    --all                                    <span class="comment"># 取回所有遥控器</span></span><br><span class="line">    -a, --append                             <span class="comment"># 追加refs的ref名称和对象名称到现有的内容.git/FETCH_HEAD。</span></span><br><span class="line">    --depth=&lt;depth&gt;                          <span class="comment"># 将提取限制为从每个远程分支历史记录的提示中指定的提交数量</span></span><br><span class="line">    --deepen=&lt;depth&gt;                         <span class="comment"># 与--depth相似，只是它指定了来自当前浅边界而不是每个远程分支历史记录的提示的提交数</span></span><br><span class="line">    --shallow-since=&lt;date&gt;                   <span class="comment"># 加深或缩短浅储存库的历史记录，以便在&lt;date&gt;之后包含所有可访问的提交</span></span><br><span class="line">    --shallow-exclude=&lt;revision&gt;             <span class="comment"># 加深或缩短浅储存库的历史记录，以排除可从指定的远程分支或标记访问的提交</span></span><br><span class="line">    --unshallow                              <span class="comment"># 如果源存储库已完成，请将浅层存储库转换为完整存储库，以消除浅存储库施加的所有限制</span></span><br><span class="line">    --update-shallow                         <span class="comment"># 默认情况下，从浅仓库中获取时， git fetch拒绝需要更新.git/shallow的引用</span></span><br><span class="line">    --dry-run                                <span class="comment"># 显示将做什么，不做任何改变</span></span><br><span class="line">    -f, --force                              <span class="comment"># 当git fetch与&lt;rbranch&gt;:&lt;lbranch&gt; refspec一起使用时，它拒绝更新本地分支， </span></span><br><span class="line">                                               &lt;lbranch&gt;除非&lt;rbranch&gt;它获取的远程分支是子孙的后代&lt;lbranch&gt;</span><br><span class="line">    -k, --keep                               <span class="comment"># 保持下载的包</span></span><br><span class="line">    --multiple                               <span class="comment"># 允许指定多个&lt;repository&gt;和&lt;group&gt;参数</span></span><br><span class="line">    -p, --prune                              <span class="comment"># 在提取之前，请删除远程不再存在的所有远程跟踪参考</span></span><br><span class="line">    -P, --prune-tags                         <span class="comment"># 在获取之前，删除--prune已启用的远程不再存在的所有本地标记</span></span><br><span class="line">    -n, --no-tags                            <span class="comment"># 默认情况下，指向从远程存储库下载的对象的标签将在本地获取并存储</span></span><br><span class="line">    --refmap=&lt;refspec&gt;                       <span class="comment"># 在获取命令行中列出的ref时，使用指定的refspec（可以多次提供）将ref映射到远程跟踪分支，而不是remote.*.fetch远程存储库的配置变量的值 </span></span><br><span class="line">    -t, --tags                               <span class="comment"># 从远程获取所有标签（即，将远程标签获取 refs/tags/*到具有相同名称的本地标签中），除此之外的任何其他内容都将被提取</span></span><br><span class="line">    --recurse-submodules[=yes|on-demand|no]  <span class="comment"># 此选项控制是否以及在什么条件下也应提取填充的子模块的新提交</span></span><br><span class="line">    -j, --<span class="built_in">jobs</span>=&lt;n&gt;                           <span class="comment"># 用于提取子模块的并行子项的数量</span></span><br><span class="line">    --no-recurse-submodules                  <span class="comment"># 禁用递归获取子模块（这与使用该--recurse-submodules=no选项具有相同的效果）</span></span><br><span class="line">    --submodule-prefix=&lt;path&gt;                <span class="comment"># 在信息消息（如“获取子模块foo”）中打印路径前加上&lt;path&gt;</span></span><br><span class="line">    --recurse-submodules-default=[yes|on-demand] <span class="comment"># 此选项在内部用于为--recurse-submodules选项临时提供非负的默认值</span></span><br><span class="line">    -u, --update-head-ok                         <span class="comment"># 默认情况下，git fetch拒绝更新与当前分支对应的头部</span></span><br><span class="line">    --upload-pack &lt;upload-pack&gt;                  <span class="comment"># 当给定时，并且从git fetch-pack处理要从中获取的存储库，--exec=&lt;upload-pack&gt;将传递给该命令以指定在另一端运行的命令的非默认路径</span></span><br><span class="line">    -q, --quiet                                  <span class="comment"># 通过 - 安静的git-fetch-pack和沉默任何其他内部使用的git命令</span></span><br><span class="line">    -v, --verbose                                <span class="comment"># 详细</span></span><br><span class="line">    --progress                                   <span class="comment"># 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q</span></span><br><span class="line">    -4, --ipv4                                   <span class="comment"># 仅使用IPv4地址，忽略IPv6地址</span></span><br><span class="line">    -6, --ipv6                                   <span class="comment"># 仅使用IPv6地址，忽略IPv4地址</span></span><br><span class="line">    &lt;repository&gt;                                 <span class="comment"># 作为提取或拉取操作源的“远程”存储库</span></span><br><span class="line">    &lt;group&gt;                                      <span class="comment"># 名称指的是存储库列表，作为配置文件中的远程数据&lt;group&gt;的值</span></span><br><span class="line">    &lt;refspec&gt;                                    <span class="comment"># 指定要获取哪些引用以及哪些本地引用要更新</span></span><br></pre></td></tr></table></figure><h2 id="820-git-merge"><a class="markdownIt-Anchor" href="#820-git-merge"></a> 8.20. git merge</h2><p>合并分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把指定的分支合并到当前所在的分支下</span></span><br><span class="line">$ git merge &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git merge [-n] [--<span class="built_in">stat</span>] [--no-commit] [--squash] [--[no-]edit]</span><br><span class="line">        [-s &lt;strategy&gt;] [-X &lt;strategy-option&gt;] [-S[&lt;keyid&gt;]]</span><br><span class="line">        [--[no-]allow-unrelated-histories]</span><br><span class="line">        [--[no-]rerere-autoupdate] [-m &lt;msg&gt;] [&lt;commit&gt;…]</span><br><span class="line">    git merge --abort</span><br><span class="line">    git merge --<span class="built_in">continue</span></span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    --commit, --no-commit                       <span class="comment"># 执行合并并提交结果。这个选项可以用来覆盖--no-commit</span></span><br><span class="line">    -e, --edit, --no-edit                       <span class="comment"># 在提交成功的机械合并之前调用编辑器来进一步编辑自动生成的合并消息，以便用户可以解释并验证合并</span></span><br><span class="line">    --ff                                        <span class="comment"># 当合并解析为快进时，只更新分支指针，而不创建合并提交。这是默认行为</span></span><br><span class="line">    --no-ff                                     <span class="comment"># 即使合并解析为快进，也可以创建合并提交。这是合并注释标记时的默认行为</span></span><br><span class="line">    --ff-only                                   <span class="comment"># 拒绝合并并以非零状态退出，除非当前HEAD已更新或合并可以解决为快进</span></span><br><span class="line">    -S[&lt;keyid&gt;], --gpg-sign[=&lt;keyid&gt;]           <span class="comment"># GPG-签署合并提交</span></span><br><span class="line">    --<span class="built_in">log</span>[=&lt;n&gt;], --no-log                       <span class="comment"># 除了分支名称之外，还可以用来自至多&lt;n&gt;实际提交的单行描述来填充日志消息</span></span><br><span class="line">    --signoff, --no-signoff                     <span class="comment"># 提交日志消息结尾处的提交者添加Signed-off-by行</span></span><br><span class="line">    --<span class="built_in">stat</span>, -n, --no-stat                       <span class="comment"># 在合并结束时显示diffstat。diffstat也由配置选项merge.stat控制</span></span><br><span class="line">    --squash, --no-squash                       <span class="comment"># 生成工作树和索引状态，就像发生真正的合并一样，但实际上并未进行提交，移动HEAD或记录$GIT_DIR/MERGE_HEAD </span></span><br><span class="line">    -s &lt;strategy&gt;, --strategy=&lt;strategy&gt;        <span class="comment"># 使用给定的合并策略; 可以多次提供，以按照他们应该尝试的顺序指定它们</span></span><br><span class="line">    -X &lt;option&gt;, --strategy-option=&lt;option&gt;     <span class="comment"># 将合并策略特定选项传递给合并策略</span></span><br><span class="line">    --verify-signatures, --no-verify-signatures <span class="comment"># 验证被合并的分支的提示提交是否使用有效密钥进行签名，即具有有效uid的密钥：在默认信任模型中，</span></span><br><span class="line">                                                  这意味着签名密钥已由可信密钥签名。如果侧分支的提示提交未使用有效密钥进行签名，则会中止合并</span><br><span class="line">    --summary, --no-summary                     <span class="comment"># 同义词--stat和--no-stat; 这些已被弃用，并将在未来被删除</span></span><br><span class="line">    -q, --quiet                                 <span class="comment"># 安静地操作。意味着 - 没有进步</span></span><br><span class="line">    -v, --verbose                               <span class="comment"># 详细</span></span><br><span class="line">    --progress, --no-progress                   <span class="comment"># 明确地打开/关闭进度。如果没有指定，如果标准错误连接到终端，则显示进度</span></span><br><span class="line">    --allow-unrelated-histories                 <span class="comment"># 默认情况下，git merge命令拒绝合并不共享祖先的历史记录</span></span><br><span class="line">    -m &lt;msg&gt;                                    <span class="comment"># 设置要用于合并提交的提交消息（以防创建）</span></span><br><span class="line">    --[no-]rerere-autoupdate                    <span class="comment"># 如果可能的话，允许rerere机制用自动冲突解决的结果更新索引</span></span><br><span class="line">    --abort                                     <span class="comment"># 中止当前的冲突解决过程，并尝试重新构建预合并状态</span></span><br><span class="line">    --<span class="built_in">continue</span>                                  <span class="comment"># 经过git的合并，由于停止冲突，那么可以得出结论：通过运行合并混帐合并--continue</span></span><br><span class="line">    &lt;commit&gt;…                                   <span class="comment"># 提交, 通常其他分支, 合并到我们的分支</span></span><br></pre></td></tr></table></figure><h2 id="821-git-mergetool"><a class="markdownIt-Anchor" href="#821-git-mergetool"></a> 8.21. git mergetool</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git mergetool [--tool=&lt;tool&gt;] [-y | --[no-]prompt] [&lt;file&gt;…]</span><br><span class="line">    </span><br><span class="line">选项：</span><br><span class="line">    -t &lt;tool&gt;, --tool=&lt;tool&gt;  # 使用&lt;tool&gt;指定的合并解析程序。有效值包括emerge，gvimdiff，kdiff3，meld，vimdiff和tortoisemerge。 运行git mergetool --tool-help 有效的&lt;工具&gt;设置列表</span><br><span class="line">    --tool-help               # 打印可能使用的合并工具列表--tool</span><br><span class="line">    -y, --no-prompt           # 在每次调用合并解析程序之前不要提示。如果通过--tool或 merge.tool配置变量显式指定合并解析程序(默认值)</span><br><span class="line">    --prompt                  # 在每次调用合并解决方案之前提示，以使用户有机会跳过该路径</span><br><span class="line">    -O&lt;orderfile&gt;             # 按照&lt;orderfile&gt;中指定的顺序处理文件，每行有一个shell glob模式</span><br></pre></td></tr></table></figure><h2 id="822-git-diff"><a class="markdownIt-Anchor" href="#822-git-diff"></a> 8.22. git diff</h2><p>比较版本之间的差异。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 比较当前文件和暂存区中文件的差异，显示没有暂存起来的更改</span></span><br><span class="line">$ git diff</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较暂存区中的文件和上次提交时的差异</span></span><br><span class="line">$ git diff --cached</span><br><span class="line">$ git diff --staged</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较当前文件和上次提交时的差异</span></span><br><span class="line">$ git diff HEAD</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看从指定的版本之后改动的内容</span></span><br><span class="line">$ git diff &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 比较两个分支之间的差异</span></span><br><span class="line">$ git diff &lt;分支名称&gt; &lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看两个分支分开后各自的改动内容</span></span><br><span class="line">$ git diff &lt;分支名称&gt;...&lt;分支名称&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git diff [options] [&lt;commit&gt;] [--] [&lt;path&gt;…]</span><br><span class="line">    git diff [options] --cached [&lt;commit&gt;] [--] [&lt;path&gt;…]</span><br><span class="line">    git diff [options] &lt;commit&gt; &lt;commit&gt; [--] [&lt;path&gt;…]</span><br><span class="line">    git diff [options] &lt;blob&gt; &lt;blob&gt;</span><br><span class="line">    git diff [options] [--no-index] [--] &lt;path&gt; &lt;path&gt;</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -p, -u, --patch                                     <span class="comment"># 生成补丁, 这是默认设置</span></span><br><span class="line">    -s, --no-patch                                      <span class="comment"># 抑制差异输出。对于像git show这样的命令很有用，默认显示补丁，或取消效果--patch</span></span><br><span class="line">    -U&lt;n&gt;, --unified=&lt;n&gt;                                <span class="comment"># 使用&lt;n&gt;行上下文生成差异，而不是通常的三行。意味着-p</span></span><br><span class="line">    --raw                                               <span class="comment"># 以原始格式生成差异</span></span><br><span class="line">    --patch-with-raw                                    <span class="comment"># 原始的同义词-p --raw</span></span><br><span class="line">    --indent-heuristic, --no-indent-heuristic           <span class="comment"># 为了帮助调试和调整实验启发式, 改变差异边界以使修补程序更易于阅读, 默认关闭</span></span><br><span class="line">    --minimal                                           <span class="comment"># 花费额外的时间来确保生成最小可能的差异</span></span><br><span class="line">    --patience                                          <span class="comment"># 使用&quot;耐心差异&quot;算法生成差异</span></span><br><span class="line">    --histogram                                         <span class="comment"># 使用&quot;直方图差异&quot;算法生成差异</span></span><br><span class="line">    --diff-algorithm=&#123;patience|minimal|histogram|myers&#125; <span class="comment"># 选择一种差异算法</span></span><br><span class="line">        default, myers                                  <span class="comment"># 基本的贪婪diff算法, 默认设置</span></span><br><span class="line">        minimal                                         <span class="comment"># 花费额外的时间来确保生成最小可能的差异</span></span><br><span class="line">        patience                                        <span class="comment"># 生成补丁时使用&quot;耐心差异&quot;算法</span></span><br><span class="line">        histogram                                       <span class="comment"># 该算法将耐心算法扩展为&quot;支持低出现率的通用元素&quot;</span></span><br><span class="line">    --<span class="built_in">stat</span>[=&lt;width&gt;[,&lt;name-width&gt;[,&lt;count&gt;]]]           <span class="comment"># 生成一个diffstat</span></span><br><span class="line">    --numstat                                           <span class="comment"># 类似--stat，但显示十进制表示法中添加和删除的行数以及不带缩写的路径名。 对于二进制文件，输出两个-而不是说 0 0</span></span><br><span class="line">    --shortstat                                         <span class="comment"># 只输出--stat包含修改文件总数的格式的最后一行, 以及添加和删除行的数量</span></span><br><span class="line">    --dirstat[=&lt;param1,param2,…&gt;]                       <span class="comment"># 输出每个子目录的相对变化量分布。--dirstat可以通过传递逗号分隔的参数列表来定制行为</span></span><br><span class="line">        changes                                         <span class="comment"># 通过计算已从源中删除或添加到目标的行来计算dirstat数字</span></span><br><span class="line">        lines                                           <span class="comment"># 通过执行常规基于行的差异分析来计算dirstat数字，并将删除/添加的行数相加</span></span><br><span class="line">        files                                           <span class="comment"># 通过计算更改的文件数量来计算dirstat数字</span></span><br><span class="line">        cumulative                                      <span class="comment"># 计数父目录的子目录中的更改</span></span><br><span class="line">        &lt;<span class="built_in">limit</span>&gt;                                         <span class="comment"># 整数参数指定截断百分比（默认为3％）。输出中不显示贡献小于此百分比的目录</span></span><br><span class="line">    --summary                                           <span class="comment"># 输出扩展头信息的精简摘要，如创建，重命名和模式更改</span></span><br><span class="line">    --patch-with-stat                                   <span class="comment"># 同义词- p - stat</span></span><br><span class="line">    -z                                                  <span class="comment"># 当--raw，--numstat，--name-only或--name-status已给出，不Munge时间路径名，并使用完全无效的输出字段终止符</span></span><br><span class="line">    --name-only                                         <span class="comment"># 仅显示已更改文件的名称</span></span><br><span class="line">    --name-status                                       <span class="comment"># 仅显示已更改文件的名称和状态</span></span><br><span class="line">    --submodule[=&lt;format&gt;]                              <span class="comment"># 指定如何显示子模块中的差异</span></span><br><span class="line">    --color[=&lt;when&gt;]                                    <span class="comment"># 显示有色差异</span></span><br><span class="line">    --no-color                                          <span class="comment"># 关闭有色差异</span></span><br><span class="line">    --word-diff[=&lt;mode&gt;]                                <span class="comment"># 显示一个单词diff，使用&lt;mode&gt;分隔已更改的单词。默认: 空格分隔</span></span><br><span class="line">    color                                               <span class="comment"># 仅使用颜色突出显示更改的词</span></span><br><span class="line">    plain                                               <span class="comment"># 将单词显示为[-removed-]和&#123;+added+&#125;。如果输入中出现分隔符，则不会尝试跳过分隔符，因此输出可能不明确</span></span><br><span class="line">    porcelain                                           <span class="comment"># 使用专门用于脚本消费的基于行的格式</span></span><br><span class="line">    none                                                <span class="comment"># 再次禁用字差异</span></span><br><span class="line">    --word-diff-regex=&lt;regex&gt;                           <span class="comment"># 使用&lt;regex&gt;来决定一个单词是什么，而不是将非空白的运行视为一个单词</span></span><br><span class="line">    --color-words[=&lt;regex&gt;]                             <span class="comment"># 相当于--word-diff=color加号</span></span><br><span class="line">    --no-renames                                        <span class="comment"># 关闭重命名检测，即使配置文件提供了默认设置</span></span><br><span class="line">    --check                                             <span class="comment"># 警告如果更改引入冲突标记或空白错误。认为空白错误由core.whitespace 配置控制。</span></span><br><span class="line">    --ws-error-highlight=&lt;kind&gt;                         <span class="comment"># 按&lt;颜色&gt;指定的颜色突出显示由&lt;颜色&gt;指定的行上的空白错误color.diff.whitespace</span></span><br><span class="line">    --full-index                                        <span class="comment"># 在生成补丁格式输出时，在“索引”行上显示完整的映像前和映像后blob对象名称，而不是第一批字符</span></span><br><span class="line">    --binary                                            <span class="comment"># 除了--full-index输出可以应用的二进制差异git-apply</span></span><br><span class="line">    --abbrev[=&lt;n&gt;]                                      <span class="comment"># 不是在diff-raw格式输出和diff-tree标题行中显示完整的40字节十六进制对象名称，只显示部分前缀</span></span><br><span class="line">    -B[&lt;n&gt;][/&lt;m&gt;], --break-rewrites[=[&lt;n&gt;][/&lt;m&gt;]]       <span class="comment"># 将完全重写更改分解为删除和创建对</span></span><br><span class="line">    -M[&lt;n&gt;], --find-renames[=&lt;n&gt;]                       <span class="comment"># 检测重命名</span></span><br><span class="line">    -C[&lt;n&gt;], --find-copies[=&lt;n&gt;]                        <span class="comment"># 检测副本以及重命名</span></span><br><span class="line">    --find-copies-harder                                <span class="comment"># 出于性能原因，默认情况下，-C只有当副本的原始文件在相同的变更集中被修改时，选项才会查找副本</span></span><br><span class="line">    -D, --irreversible-delete                           <span class="comment"># 省略原图像进行删除，即仅打印标题，但不打印原像和之间的差异/dev/null</span></span><br><span class="line">    -l&lt;num&gt;                                             <span class="comment"># 在-M和-C选项需要为O（n ^ 2）的处理时间，其中n是/复制目标潜在的重命名的数目如果重命名/复制目标的数量超过指定的数量，则此选项可防止重命名/复制检测运行</span></span><br><span class="line">    --diff-filter=[(A|C|D|M|R|T|U|X|B)…[*]]             <span class="comment"># 选择仅添加(A), 复制(C), 删除(D), 修改(M), 重命名(R), 其类型(即常规文件, 符号链接, 子模块, ...)更改(T), Unmerged(U), 未知(X)或已配对Broken(B)</span></span><br><span class="line">                                                          可以使用任何过滤字符的组合(包括无)当*（全部或无）添加到组合中时，如果有任何文件与比较中的其他条件匹配，则选择所有路径; 如果没有与其他标准匹配的文件，则不会选择任何内容</span><br><span class="line">    -S&lt;string&gt;                                          <span class="comment"># 查找改变文件中指定字符串出现次数（即添加/删除）的差异</span></span><br><span class="line">    -G&lt;regex&gt;                                           <span class="comment"># 寻找补丁文本包含与&lt;regex&gt;匹配的添加/删除行的差异</span></span><br><span class="line">    --pickaxe-all                                       <span class="comment"># 当-S或-G发现更改时，显示该更改集中的所有更改，而不仅仅是包含&lt;string&gt;中的更改的文件</span></span><br><span class="line">    --pickaxe-regex                                     <span class="comment"># 将给定的&lt;string&gt; -S视为扩展的POSIX正则表达式进行匹配</span></span><br><span class="line">    -O&lt;orderfile&gt;                                       <span class="comment"># 控制文件在输出中出现的顺序</span></span><br><span class="line">    -R                                                  <span class="comment"># 交换两个输入; 即显示索引或磁盘文件与树内容的差异</span></span><br><span class="line">    --relative[=&lt;path&gt;]                                 <span class="comment"># 从项目的子目录运行时，可以通过此选项告知排除目录外的更改并显示与其相关的路径名</span></span><br><span class="line">    -a, --text                                          <span class="comment"># 将所有文件视为文本</span></span><br><span class="line">    --ignore-space-at-eol                               <span class="comment"># 忽略EOL中的空白变化</span></span><br><span class="line">    -b, --ignore-space-change                           <span class="comment"># 忽略空白量的变化。这会忽略行结束处的空白，并认为一个或多个空白字符的所有其他序列是等价的</span></span><br><span class="line">    -w, --ignore-all-space                              <span class="comment"># 比较行时忽略空格。即使一行有空白，而另一行没有空白，这也会忽略差异</span></span><br><span class="line">    --ignore-blank-lines                                <span class="comment"># 忽略其行全部空白的更改</span></span><br><span class="line">    --inter-hunk-context=&lt;lines&gt;                        <span class="comment"># 显示差异hunk之间的上下文，直到指定的行数，从而融合彼此接近的hunk</span></span><br><span class="line">    -W, --function-context                              <span class="comment"># 显示整个周围的变化功能</span></span><br><span class="line">    --exit-code                                         <span class="comment"># 用类似于diff（1）的代码退出程序。也就是说，如果存在差异，则1退出，0表示没有差异</span></span><br><span class="line">    --quiet                                             <span class="comment"># 禁用程序的所有输出。意味着--exit-code</span></span><br><span class="line">    --ext-diff                                          <span class="comment"># 允许执行一个外部比较助手</span></span><br><span class="line">    --no-ext-diff                                       <span class="comment"># 禁止外部差异驱动程序</span></span><br><span class="line">    --textconv, --no-textconv                           <span class="comment"># 在比较二进制文件时，允许（或不允许）运行外部文本转换过滤器</span></span><br><span class="line">    --ignore-submodules[=&lt;when&gt;]                        <span class="comment"># 忽略差异代中子模块的更改。&lt;when&gt;可以是“none”，“untracked”，“dirty”或“all”，这是默认设置</span></span><br><span class="line">    --src-prefix=&lt;prefix&gt;                               <span class="comment"># 显示给定的源前缀而不是“a /”</span></span><br><span class="line">    --dst-prefix=&lt;prefix&gt;                               <span class="comment"># 显示给定的目的地前缀而不是“b /”</span></span><br><span class="line">    --no-prefix                                         <span class="comment"># 不要显示任何来源或目的地前缀</span></span><br><span class="line">    --line-prefix=&lt;prefix&gt;                              <span class="comment"># 为每行输出预留一个额外的前缀</span></span><br><span class="line">    --ita-invisible-in-index                            <span class="comment"># 默认情况下，由“git add -N”添加的条目显示为“git diff”中的现有空文件和“git diff --cached”中的新文件</span></span><br><span class="line">    -1 --base, -2 --ours, -3 --theirs                   <span class="comment"># 比较工作树与“基本”版本（阶段＃1），“我们的分支”（阶段＃2）或“他们的分支”（阶段＃3）</span></span><br><span class="line">    -0                                                  <span class="comment"># 忽略差异输出未合并的条目并只显示“未合并”。仅在将工作树与索引进行比较时才能使用</span></span><br><span class="line">    &lt;path&gt;…                                             <span class="comment"># 给出的&lt;paths&gt;参数用于将diff限制为指定的路径</span></span><br></pre></td></tr></table></figure><h2 id="823-git-pull"><a class="markdownIt-Anchor" href="#823-git-pull"></a> 8.23. git pull</h2><p>从远程仓库获取最新版本并合并到本地。<br />首先会执行 <code>git fetch</code>，然后执行 <code>git merge</code>，把获取的分支的 HEAD 合并到当前分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 从远程仓库获取最新版本。</span></span><br><span class="line">$ git pull</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git pull [options] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -q, --quiet                                    <span class="comment"># 这被传递给底层的git-fetch，以便在传输过程中压制报告，并在合并过程中将潜在的git-merge压制成静噪输出</span></span><br><span class="line">    -v, --verbose                                  <span class="comment"># 通过--verbose git-fetch和git-merge</span></span><br><span class="line">    --[no-]recurse-submodules[=yes|on-demand|no]   <span class="comment"># 该选项控制是否应该提取和更新所有已填充子模块的新提交</span></span><br><span class="line"></span><br><span class="line">与合并有关的选项：</span><br><span class="line">    --commit， --no-commit      　　　　　　　　      <span class="comment"># 执行合并并提交结果</span></span><br><span class="line">    -e, --edit, --no-edit                          <span class="comment"># 在提交成功的机械合并之前调用编辑器来进一步编辑自动生成的合并消息，以便用户可以解释并验证合并</span></span><br><span class="line">    --ff                                           <span class="comment"># 当合并解析为快进时，只更新分支指针，而不创建合并提交。这是默认行为</span></span><br><span class="line">    --no-ff                                        <span class="comment"># 即使合并解析为快进，也可以创建合并提交</span></span><br><span class="line">    --ff-only                                      <span class="comment"># 拒绝合并并以非零状态退出，除非电流HEAD已经是最新的或合并可以解决为快进</span></span><br><span class="line">    --<span class="built_in">log</span>[=&lt;n&gt;], --no-log                          <span class="comment"># 除了分支名称之外，还可以用来自至多&lt;n&gt;实际提交的单行描述来填充日志消息</span></span><br><span class="line">    --<span class="built_in">stat</span>, -n, --no-stat                          <span class="comment"># 在合并结束时显示diffstat。diffstat也由配置选项merge.stat控制</span></span><br><span class="line">    --squash, --no-squash                          <span class="comment"># 生成工作树和索引状态，就像发生真正的合并（合并信息除外）一样，但实际上并未进行提交，</span></span><br><span class="line">                                                     移动HEAD或记录<span class="variable">$GIT_DIR</span>/MERGE_HEAD （以导致下一个git commit命令创建合并提交）</span><br><span class="line">    -s &lt;strategy&gt;, --strategy=&lt;strategy&gt;           <span class="comment"># 使用给定的合并策略; 可以多次提供，以按照他们应该尝试的顺序指定它们</span></span><br><span class="line">    -X &lt;option&gt;, --strategy-option=&lt;option&gt;        <span class="comment"># 将合并策略特定选项传递给合并策略</span></span><br><span class="line">    --verify-signatures, --no-verify-signatures    <span class="comment"># 验证被合并的分支的提示提交是否使用有效密钥进行签名，即具有有效uid的密钥：在默认信任模型中，这意味着签名密钥已由可信密钥签名</span></span><br><span class="line">    --allow-unrelated-histories                    <span class="comment"># 默认情况下，git merge命令拒绝合并不共享祖先的历史记录</span></span><br><span class="line">    -r, --rebase[=<span class="literal">false</span>|<span class="literal">true</span>|preserve|interactive] <span class="comment"># 如果为true，则在获取后重新绑定上游分支顶部的当前分支</span></span><br><span class="line">    --no-rebase                                    <span class="comment"># 早先覆盖--rebase</span></span><br><span class="line">    --autostash, --no-autostash                    <span class="comment"># 在开始rebase之前，如果需要，将局部修改隐藏起来，并在完成时应用存储条目</span></span><br><span class="line"></span><br><span class="line">与抓取相关的选项:</span><br><span class="line">    --all                                          <span class="comment"># 取回所有遥控器</span></span><br><span class="line">    -a, --append                                   <span class="comment"># 追加refs的ref名称和对象名称到现有的内容.git/FETCH_HEAD</span></span><br><span class="line">    --depth=&lt;depth&gt;                                <span class="comment"># 将提取限制为从每个远程分支历史记录的提示中指定的提交数量</span></span><br><span class="line">    --deepen=&lt;depth&gt;                               <span class="comment"># 与--depth相似，只是它指定了来自当前浅边界而不是每个远程分支历史记录的提示的提交数</span></span><br><span class="line">    --shallow-since=&lt;date&gt;                         <span class="comment"># 加深或缩短浅储存库的历史记录，以便在&lt;date&gt;之后包含所有可访问的提交</span></span><br><span class="line">    --shallow-exclude=&lt;revision&gt;                   <span class="comment"># 加深或缩短浅储存库的历史记录，以排除可从指定的远程分支或标记访问的提交</span></span><br><span class="line">    --unshallow                                    <span class="comment"># 如果源存储库已完成，请将浅层存储库转换为完整存储库，以消除浅存储库施加的所有限制</span></span><br><span class="line">    --update-shallow                               <span class="comment"># 默认情况下，从浅仓库中获取时， git fetch拒绝需要更新.git/shallow的引用</span></span><br><span class="line">    -f, --force                                    <span class="comment"># 当git fetch与&lt;rbranch&gt;:&lt;lbranch&gt; refspec一起使用时，它拒绝更新本地分支，&lt;lbranch&gt;除非&lt;rbranch&gt;它获取的远程分支是子孙的后代&lt;lbranch&gt;</span></span><br><span class="line">    -k, --keep                                     <span class="comment"># 保持下载的包</span></span><br><span class="line">    --no-tags                                      <span class="comment"># 默认情况下，指向从远程存储库下载的对象的标签将在本地​​获取并存储</span></span><br><span class="line">    -u, --update-head-ok                           <span class="comment"># 默认情况下，git fetch拒绝更新与当前分支对应的头部</span></span><br><span class="line">    --upload-pack &lt;upload-pack&gt;                    <span class="comment"># 当给定时，并且从git fetch-pack处理要从中获取的存储库，--exec=&lt;upload-pack&gt;将传递给该命令以指定在另一端运行的命令的非默认路径</span></span><br><span class="line">    --progress                                     <span class="comment"># 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q</span></span><br><span class="line">    -4, --ipv4                                     <span class="comment"># 仅使用IPv4地址，忽略IPv6地址</span></span><br><span class="line">    -6, --ipv6                                     <span class="comment"># 仅使用IPv6地址，忽略IPv4地址</span></span><br><span class="line">    &lt;repository&gt;                                   <span class="comment"># 作为提取或拉取操作源的“远程”存储库</span></span><br><span class="line">    &lt;refspec&gt;                                      <span class="comment"># 指定要获取哪些引用以及哪些本地引用要更新</span></span><br></pre></td></tr></table></figure><h2 id="824-git-push"><a class="markdownIt-Anchor" href="#824-git-push"></a> 8.24. git push</h2><p>把本地仓库的提交推送到远程仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 把本地仓库的分支推送到远程仓库的指定分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;本地分支名&gt;:&lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的远程仓库的分支</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; :&lt;远程分支名&gt;</span><br><span class="line">$ git push &lt;远程仓库的别名&gt; --delete &lt;远程分支名&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 语法选项参数</span></span><br><span class="line"><span class="variable">$git</span> push </span><br><span class="line">        [--all | --mirror | --tags] </span><br><span class="line">        [--follow-tags] [--atomic] </span><br><span class="line">        [-n | --dry-run] </span><br><span class="line">        [--receive-pack=&lt;git-receive-pack&gt;]</span><br><span class="line">        [--repo=&lt;repository&gt;] </span><br><span class="line">        [-f | --force] </span><br><span class="line">        [-d | --delete] </span><br><span class="line">        [--prune] </span><br><span class="line">        [-v | --verbose]</span><br><span class="line">        [-u | --set-upstream] </span><br><span class="line">        [--push-option=&lt;string&gt;]</span><br><span class="line">        [--[no-]signed|--sign=(<span class="literal">true</span>|<span class="literal">false</span>|if-asked)]</span><br><span class="line">        [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]]</span><br><span class="line">        [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…]]</span><br><span class="line">        </span><br><span class="line">语法：</span><br><span class="line">    git push [--all | --mirror | --tags] [--follow-tags] [--atomic] [-n | --dry-run] [--receive-pack=&lt;git-receive-pack&gt;]</span><br><span class="line">           [--repo=&lt;repository&gt;] [-f | --force] [-d | --delete] [--prune] [-v | --verbose]</span><br><span class="line">           [-u | --set-upstream] [--push-option=&lt;string&gt;]</span><br><span class="line">           [--[no-]signed|--signed=(<span class="literal">true</span>|<span class="literal">false</span>|if-asked)]</span><br><span class="line">           [--force-with-lease[=&lt;refname&gt;[:&lt;expect&gt;]]]</span><br><span class="line">           [--no-verify] [&lt;repository&gt; [&lt;refspec&gt;…​]]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    &lt;repository&gt;                                    <span class="comment"># 作为推送操作目标的“远程”存储库</span></span><br><span class="line">    &lt;refspec&gt;…​                                      <span class="comment"># 用什么源对象指定要更新的目标引用</span></span><br><span class="line">    --all                                           <span class="comment"># 推送所有分支（即参考下refs/heads/）; 不能与其他&lt;refspec&gt;一起使用</span></span><br><span class="line">    --prune                                         <span class="comment"># 删除没有本地副本的远程分支</span></span><br><span class="line">    --mirror                                        <span class="comment"># 代替命名每个裁判推的，指定了下的所有参考文献refs/（包括但不限于refs/heads/，refs/remotes/和refs/tags/）被镜像到远程存储库</span></span><br><span class="line">    -n, --dry-run                                   <span class="comment"># 除了实际发送更新之外，请做其他事</span></span><br><span class="line">    --porcelain                                     <span class="comment"># 生成机器可读的输出</span></span><br><span class="line">    --delete                                        <span class="comment"># 所有列出的ref都从远程存储库中删除</span></span><br><span class="line">    --tags                                          <span class="comment"># refs/tags除了在命令行中明确列出的refspecs之外，所有refs 都将被推送</span></span><br><span class="line">    --follow-tags                                   <span class="comment"># 推送所有没有此选项时将被推送的引用，并且推送refs/tags远程引用中缺少的带注释的标签，但指向可从所推送的引用访问的提交标识</span></span><br><span class="line">    --[no-]signed, --signed=(<span class="literal">true</span>|<span class="literal">false</span>|if-asked)   <span class="comment"># GPG-签署推送请求以更新接收端的refs，以便通过钩子检查和/或记录</span></span><br><span class="line">    --[no-]atomic                                   <span class="comment"># 如果可用，请在远程端使用原子事务</span></span><br><span class="line">    -o &lt;option&gt;, --push-option=&lt;option&gt;             <span class="comment"># 将给定的字符串传送给服务器，服务器将它们传递给预接收以及接收后挂接</span></span><br><span class="line">    --receive-pack=&lt;git-receive-pack&gt;, --<span class="built_in">exec</span>=&lt;git-receive-pack&gt;          <span class="comment"># 远程端上git-receive-pack程序的路径</span></span><br><span class="line">    --[no-]force-with-lease, --force-with-lease=&lt;refname&gt;,      </span><br><span class="line">    --force-with-lease=&lt;refname&gt;:&lt;expect&gt;                                 <span class="comment"># 如果远程ref的当前值是期望值，则此选项将覆盖此限制</span></span><br><span class="line">    -f, --force                                                           <span class="comment"># 通常，该命令拒绝更新远程ref，该远程ref不是用于覆盖它的本地ref的祖先</span></span><br><span class="line">    --repo=&lt;repository&gt;                                                   <span class="comment"># 该选项等同于&lt;repository&gt;参数。如果两者都指定，则命令行参数优先</span></span><br><span class="line">    -u, --set-upstream                                                    <span class="comment"># 对于最新或成功推送的每个分支，添加无参数git-pull [1]和其他命令使用的上游（跟踪）引用</span></span><br><span class="line">    --[no-]thin                                                           <span class="comment"># 这些选项被传递给git-send-pack [1]</span></span><br><span class="line">    -q, --quiet                                                           <span class="comment"># 抑制所有输出，包括更新的引用列表，除非发生错误</span></span><br><span class="line">    -v, --verbose                                                         <span class="comment"># 运行详细</span></span><br><span class="line">    --progress                                                            <span class="comment"># 当连接到终端时，默认情况下，标准错误流中会报告进度状态，除非指定-q</span></span><br><span class="line">    --no-recurse-submodules, --recurse-submodules=check|on-demand|only|no <span class="comment"># 可用于所有子模块提交的修改被推到远程跟踪分支上</span></span><br><span class="line">    --[no-]verify                                                         <span class="comment"># 切换预推钩。默认值：验证，使钩子有机会阻止推送</span></span><br><span class="line">    -4, --ipv4                                                            <span class="comment"># 仅使用IPv4地址，忽略IPv6地址</span></span><br><span class="line">    -6, --ipv6                                                            <span class="comment"># 仅使用IPv6地址，忽略IPv4地址</span></span><br></pre></td></tr></table></figure><h2 id="825-git-log"><a class="markdownIt-Anchor" href="#825-git-log"></a> 8.25. git log</h2><p>显示提交的记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印所有的提交记录</span></span><br><span class="line">$ git <span class="built_in">log</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印从第一次提交到指定的提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 打印指定数量的最新提交的记录</span></span><br><span class="line">$ git <span class="built_in">log</span> -&lt;指定的数量&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git <span class="built_in">log</span> [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…]</span><br><span class="line">    </span><br><span class="line">选项：</span><br><span class="line">    --follow                                                     <span class="comment"># 继续列出除重命名之外的文件历史记录（仅适用于单个文件）</span></span><br><span class="line">    --no-decorate, --decorate[=short|full|auto|no]               <span class="comment"># 打印出任何提交的ref名称</span></span><br><span class="line">    --decorate-refs=&lt;pattern&gt;, --decorate-refs-exclude=&lt;pattern&gt; <span class="comment"># 如果没有--decorate-refs给出，假装所有参考文献都包含在内</span></span><br><span class="line">    --<span class="built_in">source</span>                                                     <span class="comment"># 打印在每个提交到达的命令行上给出的ref名称</span></span><br><span class="line">    --use-mailmap                                                <span class="comment"># 使用邮件地图文件将作者和提交者姓名和电子邮件地址映射到规范的实名和电子邮件地址</span></span><br><span class="line">    --full-diff                                                  <span class="comment"># 没有此标志，git log -p &lt;path&gt;...显示提交触摸指定的路径，并且差异关于相同指定的路径</span></span><br><span class="line">    --log-size                                                   <span class="comment"># 在每个提交的输出中包含一行“log size &lt;number&gt;”，其中&lt;number&gt;是该提交消息的长度（以字节为单位）</span></span><br><span class="line">    -L &lt;start&gt;,&lt;end&gt;:&lt;file&gt;, -L :&lt;funcname&gt;:&lt;file&gt;               <span class="comment"># 跟踪&lt;file&gt;中由“&lt;start&gt;，&lt;end&gt;”（或函数名称regex &lt;funcname&gt;）给出的行范围的演变</span></span><br><span class="line">    &lt;revision range&gt;                                             <span class="comment"># 仅显示指定修订范围内的提交</span></span><br><span class="line">    [\--] &lt;path&gt;…                                                <span class="comment"># 仅显示足以解释如何匹配指定路径的文件的提交</span></span><br><span class="line">    </span><br><span class="line">提交限制：                                        </span><br><span class="line">    -&lt;number&gt;, -n &lt;number&gt;, --max-count=&lt;number&gt;         <span class="comment"># 限制提交输出的数量</span></span><br><span class="line">    --skip=&lt;number&gt;                                      <span class="comment"># 在开始显示提交输出之前跳过数字提交</span></span><br><span class="line">    --since=&lt;date&gt;, --after=&lt;date&gt;                       <span class="comment"># 显示比特定日期更近的提交</span></span><br><span class="line">    --until=&lt;date&gt;, --before=&lt;date&gt;                      <span class="comment"># 显示比特定日期更早的提交</span></span><br><span class="line">    --author=&lt;pattern&gt;, --committer=&lt;pattern&gt;            <span class="comment"># 将提交输出限制为与指定模式（正则表达式）匹配的作者/提交者标题行</span></span><br><span class="line">    --grep-reflog=&lt;pattern&gt;                              <span class="comment"># 将提交输出限制为具有与指定模式（正则表达式）匹配的reflog条目的提交输出</span></span><br><span class="line">    --grep=&lt;pattern&gt;                                     <span class="comment"># 将提交输出限制为符合指定模式（正则表达式）的日志消息</span></span><br><span class="line">    --all-match                                          <span class="comment"># 将提交输出限制为匹配所有给定的提交--grep，而不是至少匹配一个提交</span></span><br><span class="line">    --invert-grep                                        <span class="comment"># 将提交输出限制为与日志消息不匹配的模式--grep=&lt;pattern&gt;</span></span><br><span class="line">    -i, --regexp-ignore-case                             <span class="comment"># 匹配正则表达式限制模式而不考虑字母大小写</span></span><br><span class="line">    --basic-regexp                                       <span class="comment"># 考虑限制模式是基本的正则表达式; 这是默认值</span></span><br><span class="line">    -E, --extended-regexp                                <span class="comment"># 考虑限制模式是扩展正则表达式而不是默认的基本正则表达式</span></span><br><span class="line">    -F, --fixed-strings                                  <span class="comment"># 考虑限制模式为固定字符串（不要将模式解释为正则表达式）</span></span><br><span class="line">    -P, --perl-regexp                                    <span class="comment"># 考虑限制模式是与Perl兼容的正则表达式</span></span><br><span class="line">    --remove-empty                                       <span class="comment"># 当给定的路径从树上消失时停止</span></span><br><span class="line">    --merges                                             <span class="comment"># 仅打印合并提交。这完全一样--min-parents=2</span></span><br><span class="line">    --no-merges                                          <span class="comment"># 不要打印与多个父代的提交。这完全一样--max-parents=1</span></span><br><span class="line">    --min-parents=&lt;number&gt;, --max-parents=&lt;number&gt;       <span class="comment"># 仅显示至少（或至多）多次父级提交的提交</span></span><br><span class="line">    --no-min-parents, --no-max-parents                   <span class="comment"># --no-min-parents并--no-max-parents重新设置这些限制（无限制）</span></span><br><span class="line">    --first-parent                                       <span class="comment"># 在查看合并提交后，只跟踪第一个父提交</span></span><br><span class="line">    --not                                                <span class="comment"># 反转的意思^前缀（或缺乏）的所有后续修订说明符，到下一个--not</span></span><br><span class="line">    --all                                                <span class="comment"># 假设所有的参考文件refs/，以及HEAD命令行都列为&lt;commit&gt;</span></span><br><span class="line">    --branches[=&lt;pattern&gt;]                               <span class="comment"># 假设所有的参数refs/heads都在命令行上列为&lt;commit&gt;。如果给定&lt;pattern&gt;，则将分支限制为与给定shell glob匹配的分支</span></span><br><span class="line">    --tags[=&lt;pattern&gt;]                                   <span class="comment"># 假设所有的参数refs/tags都在命令行上列为&lt;commit&gt;。如果给出&lt;pattern&gt;，则将标记限制为与给定shell glob相匹配的标记</span></span><br><span class="line">    --remotes[=&lt;pattern&gt;]                                <span class="comment"># 假设所有的参数refs/remotes都在命令行上列为&lt;commit&gt;。如果给出&lt;pattern&gt;，则将远程跟踪分支限制为与给定shell glob匹配的分支</span></span><br><span class="line">    --glob=&lt;glob-pattern&gt;                                <span class="comment"># 假设所有与shell glob &lt;glob-pattern&gt;匹配的ref 在命令行中都以&lt;commit&gt;列出。前导refs /，如果缺失，将自动添加前缀</span></span><br><span class="line">    --exclude=&lt;glob-pattern&gt;                             <span class="comment"># 不包括裁判匹配&lt;水珠图案&gt;，未来--all， --branches，--tags，--remotes，或--glob原本考虑</span></span><br><span class="line">    --reflog                                             <span class="comment"># 假设所有reflog提到的对象都在命令行中列为&lt;commit&gt;</span></span><br><span class="line">    --single-worktree                                    <span class="comment"># 默认情况下，所有工作的树木将被下面的选项时，有一个以上--all，--reflog和 --indexed-objects。该选项强制他们仅检查当前工作树</span></span><br><span class="line">    --ignore-missing                                     <span class="comment"># 在输入中看到一个无效的对象名称时，假装没有给出错误的输入</span></span><br><span class="line">    --bisect                                             <span class="comment"># 假装好坏的二等分参考文献refs/bisect/bad 被列出，并且仿佛它被跟随，--not并且良好的平分参考refs/bisect/good-*命令行</span></span><br><span class="line">    --stdin                                              <span class="comment"># 除了命令行上列出的&lt;commit&gt;之外，还可以从标准输入中读取它们。如果--看到分隔符，请停止读取提交并开始读取路径以限制结果</span></span><br><span class="line">    --cherry-mark                                        <span class="comment"># 像--cherry-pick（见下面）但标记等价提交=而不是省略它们，而不等价的提交+</span></span><br><span class="line">    --cherry-pick                                        <span class="comment"># 当提交集合受到对称差异限制时，省略任何提交引入与“另一侧”上的另一个提交相同的更改的提交</span></span><br><span class="line">    --left-only, --right-only                            <span class="comment"># 列表仅在对称差异的相应侧提交，即只有那些将被标记&lt;为resp的列表。&gt;通过 --left-right</span></span><br><span class="line">    --cherry                                             <span class="comment"># 的代名词--right-only --cherry-mark --no-merges; 有用的是将输出限制在我们这边的提交中，并将那些已经应用到</span></span><br><span class="line">                                                           分叉历史的另一边的标记标记为 git <span class="built_in">log</span> --cherry upstream...mybranch类似于 git cherry upstream mybranch</span><br><span class="line">    -g, --walk-reflogs                                   <span class="comment"># 而不是走提交祖先链，将reflog条目从最近的一条走到更旧的条目</span></span><br><span class="line">    --merge                                              <span class="comment"># 合并失败后，显示引用文件有冲突并且不存在于所有合并头上</span></span><br><span class="line">    --boundary                                           <span class="comment"># 输出排除边界提交。边界提交以前缀-</span></span><br><span class="line">    </span><br><span class="line">历史简化：</span><br><span class="line">    &lt;paths&gt;                                              <span class="comment"># 提交修改给定的&lt;路径&gt;被选中</span></span><br><span class="line">    --simplify-by-decoration                             <span class="comment"># 由某个分支或标签引用的提交被选中</span></span><br><span class="line">        Default mode                                     <span class="comment"># 将历史简化为解释树的最终状态的最简单历史记录</span></span><br><span class="line">        --full-history                                   <span class="comment"># 与默认模式相同，但不修剪某些历史记录</span></span><br><span class="line">        --dense                                          <span class="comment"># 只显示选定的提交，另外一些提供有意义的历史记录</span></span><br><span class="line">        --sparse                                         <span class="comment"># 显示简化历史记录中的所有提交</span></span><br><span class="line">        --simplify-merges                                <span class="comment"># 附加选项可--full-history从结果历史记录中删除一些不必要的合并，因为没有选定的提交对此合并作出贡献</span></span><br><span class="line">        --ancestry-path                                  <span class="comment"># 当给定一个范围提交的显示（例如commit1..commit2 或commit2 ^ commit1），</span></span><br><span class="line">                                                           只直接存在于之间的祖先链显示提交commit1和 commit2，即提交属于的两个后代commit1，和祖先commit2</span><br><span class="line"></span><br><span class="line">提交订单：                                                </span><br><span class="line">    --date-order                                         <span class="comment"># 在显示所有孩子之前不显示父母，但在提交时间戳顺序中显示提交</span></span><br><span class="line">    --author-date-order                                  <span class="comment"># 在显示所有孩子之前不显示父母，但以作者时间戳顺序显示提交</span></span><br><span class="line">    --topo-order                                         <span class="comment"># 在显示所有孩子之前不要显示父母，并且避免在多行历史记录中混合显示提交</span></span><br><span class="line">    --reverse                                            <span class="comment"># 以相反顺序输出选择显示的提交。不能与之结合 --walk-reflogs</span></span><br><span class="line"></span><br><span class="line">对象遍历：                                                    </span><br><span class="line">    --no-walk[=(sorted|unsorted)]                        <span class="comment"># 只显示给定的提交，但不要遍历其祖先。如果指定了范围，则这不起作用。如果提供了参数 unsorted，</span></span><br><span class="line">　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　　 则提交按照它们在命令行上的顺序显示。否则（如sorted没有给参数），提交按提交时间以反向时间顺序显示。不能与之结合--graph</span><br><span class="line">    --do-walk                                            <span class="comment"># 覆盖以前--no-walk</span></span><br><span class="line"></span><br><span class="line">提交格式：                                                </span><br><span class="line">    --pretty[=&lt;format&gt;], --format=&lt;format&gt;               <span class="comment"># 漂亮地打印在提交日志的内容在给定的格式，其中&lt;格式&gt;可以是一个ONELINE，短，中等，充分，更全面的，电子邮件，原料，格式：&lt;字符串&gt; 和tformat：&lt;字符串&gt;        </span></span><br><span class="line">    --abbrev-commit                                      <span class="comment"># 不显示完整的40字节十六进制提交对象名称，只显示部分前缀</span></span><br><span class="line">    --no-abbrev-commit                                   <span class="comment"># 显示完整的40字节十六进制提交对象名称。这种否定 --abbrev-commit和暗示它的选项如“--oneline”</span></span><br><span class="line">    --oneline                                            <span class="comment"># 这是一起使用的“--pretty = oneline --abbrev-commit”的缩写</span></span><br><span class="line">    --encoding=&lt;encoding&gt;                                <span class="comment"># 提交对象在其编码头中记录用于日志消息的编码; 这个选项可以用来告诉命令在用户首选的编码中重新编写提交日志消息</span></span><br><span class="line">    --expand-tabs=&lt;n&gt;, --expand-tabs, --no-expand-tabs   <span class="comment"># 在输出中显示日志消息之前，执行一个选项卡扩展（将每个选项卡用足够的空格替换，以填充日志消息中的倍数为&lt;n&gt;的下一个显示列）</span></span><br><span class="line">    --notes[=&lt;treeish&gt;]                                  <span class="comment"># 在显示提交日志消息时，显示注释提交的注释</span></span><br><span class="line">    --no-notes                                           <span class="comment"># 不要显示笔记</span></span><br><span class="line">    --show-signature                                     <span class="comment"># 通过签名传递gpg --verify并显示输出来检查签名提交对象的有效性</span></span><br><span class="line">    --relative-date                                      <span class="comment"># 的同义词--date=relative</span></span><br><span class="line">    --date=&lt;format&gt;                                      <span class="comment"># 仅对以人可读格式显示的日期生效，例如在使用时--pretty。log.dateconfig变量为log命令的--date选项设置一个默认值</span></span><br><span class="line">    --parents                                            <span class="comment"># 也打印提交的父母（以“commit parent ...”的形式）</span></span><br><span class="line">    --children                                           <span class="comment"># 也打印提交的子代（以“commit child ...”的形式）</span></span><br><span class="line">    --left-right                                         <span class="comment"># 标记可以从中提交提交的对称差异的哪一侧。来自左侧的提交将以前面的&lt;和前面的提交&gt;。如果合并--boundary，那些提交前缀为-</span></span><br><span class="line">    --graph                                              <span class="comment"># 在输出的左侧绘制提交历史记录的基于文本的图形表示</span></span><br><span class="line">    --show-linear-break[=&lt;barrier&gt;]                      <span class="comment"># 当不使用--graph时，所有历史分支都会变平，这使得很难看到两个连续的提交不属于线性分支</span></span><br><span class="line"></span><br><span class="line">区分格式：                                                </span><br><span class="line">    -c                                                   <span class="comment"># 使用此选项，合并提交的差异输出会同时显示每个父级与合并结果的差异，而不是显示父级与每次结果之间的pairwise差异</span></span><br><span class="line">    --cc                                                 <span class="comment"># 这个标志意味着这个-c选项，并通过省略父母内容只有两个变体的无趣hunk来进一步压缩补丁输出，并且合并结果不加修改地选择其中的一个</span></span><br><span class="line">    -m                                                   <span class="comment"># 这个标志使得合并提交显示了像常规提交一样的完整差异; 对于每个合并父项，会生成一个单独的日志条目和diff</span></span><br><span class="line">    -r                                                   <span class="comment"># 显示递归差异</span></span><br><span class="line">    -t                                                   <span class="comment"># 在diff输出中显示树对象。这意味着-r</span></span><br></pre></td></tr></table></figure><h2 id="826-git-reset"><a class="markdownIt-Anchor" href="#826-git-reset"></a> 8.26. git reset</h2><p>还原提交记录。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重置暂存区，但文件不受影响</span></span><br><span class="line"><span class="comment"># 相当于将用 &quot;git add&quot; 命令更新到暂存区的内容撤出暂存区，可以指定文件</span></span><br><span class="line"><span class="comment"># 没有指定 commit ID 则默认为当前 HEAD</span></span><br><span class="line">$ git reset [&lt;文件路径&gt;]</span><br><span class="line">$ git reset --mixed [&lt;文件路径&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line">$ git reset &lt;commit ID&gt;</span><br><span class="line">$ git reset --mixed &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件未修改</span></span><br><span class="line"><span class="comment"># 相当于调用 &quot;git reset --mixed&quot; 命令后又做了一次 &quot;git add&quot;</span></span><br><span class="line">$ git reset --soft &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将 HEAD 的指向改变，撤销到指定的提交记录，文件也修改了</span></span><br><span class="line">$ git reset --hard &lt;commit ID&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git reset [-q] [&lt;tree-ish&gt;] [--] &lt;paths&gt;…</span><br><span class="line">    git reset (--patch | -p) [&lt;tree-ish&gt;] [--] [&lt;paths&gt;…]</span><br><span class="line">    git reset [--soft | --mixed [-N] | --hard | --merge | --keep] [-q] [&lt;commit&gt;]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -q, --quiet      <span class="comment"># 保持安静，只报告错误</span></span><br><span class="line">    --soft           <span class="comment"># 根本不触摸索引文件或工作树（但将头重置为&lt;commit&gt;，就像所有模式一样）</span></span><br><span class="line">    --mixed          <span class="comment"># 重置索引而不是工作树（即，保存更改的文件但未标记为提交）并报告尚未更新的内容。这是默认操作</span></span><br><span class="line">    --hard           <span class="comment"># 重置索引和工作树。放弃自&lt;commit&gt;以来对工作树中跟踪文件所做的任何更改</span></span><br><span class="line">    --merge          <span class="comment"># 重置索引并更新工作树中&lt;commit&gt;和HEAD之间不同的文件，但保留索引和工作树之间不同的文件（即没有添加更改的文件）如果&lt;commit&gt;和索引之间的文件有不同的变化，则重置会中止</span></span><br><span class="line">    --keep           <span class="comment"># 重置索引条目并更新工作树中&lt;commit&gt;和HEAD之间不同的文件。如果&lt;commit&gt;和HEAD之间的文件有本地更改，则重置会中止</span></span><br></pre></td></tr></table></figure><h2 id="827-git-revert"><a class="markdownIt-Anchor" href="#827-git-revert"></a> 8.27. git revert</h2><p>生成一个新的提交来撤销某次提交，此次提交之前的所有提交都会被保留。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 生成一个新的提交来撤销某次提交</span></span><br><span class="line">$ git revert &lt;commit ID&gt;</span><br></pre></td></tr></table></figure><h2 id="828-git-tag"><a class="markdownIt-Anchor" href="#828-git-tag"></a> 8.28. git tag</h2><p>操作标签的命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 打印所有的标签</span></span><br><span class="line">$ git tag</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加轻量标签，指向提交对象的引用，可以指定之前的提交记录</span></span><br><span class="line">$ git tag &lt;标签名称&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 添加带有描述信息的附注标签，可以指定之前的提交记录</span></span><br><span class="line">$ git tag -a &lt;标签名称&gt; -m &lt;标签描述信息&gt; [&lt;commit ID&gt;]</span><br><span class="line"></span><br><span class="line"><span class="comment"># 切换到指定的标签</span></span><br><span class="line">$ git checkout &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看标签的信息</span></span><br><span class="line">$ git show &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除指定的标签</span></span><br><span class="line">$ git tag -d &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将指定的标签提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; &lt;标签名称&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 将本地所有的标签全部提交到远程仓库</span></span><br><span class="line">$ git push &lt;远程仓库的别名&gt; -tags</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git tag [-a | -s | -u &lt;keyid&gt;] [-f] [-m &lt;msg&gt; | -F &lt;file&gt;] [-e]</span><br><span class="line">        &lt;tagname&gt; [&lt;commit&gt; | &lt;object&gt;]</span><br><span class="line">    git tag -d &lt;tagname&gt;…</span><br><span class="line">    git tag [-n[&lt;num&gt;]] -l [--contains &lt;commit&gt;] [--no-contains &lt;commit&gt;]</span><br><span class="line">        [--points-at &lt;object&gt;] [--column[=&lt;options&gt;] | --no-column]</span><br><span class="line">        [--create-reflog] [--sort=&lt;key&gt;] [--format=&lt;format&gt;]</span><br><span class="line">        [--[no-]merged [&lt;commit&gt;]] [&lt;pattern&gt;…]</span><br><span class="line">    git tag -v [--format=&lt;format&gt;] &lt;tagname&gt;…</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -a, --annotate                          <span class="comment"># 制作一个未签名的带注释的标签对象</span></span><br><span class="line">    -s, --sign                              <span class="comment"># 使用默认的电子邮件地址密钥创建一个GPG签名的标签</span></span><br><span class="line">    -u &lt;keyid&gt;, --local-user=&lt;keyid&gt;        <span class="comment"># 使用给定的密钥创建一个GPG签名的标签</span></span><br><span class="line">    -f, --force                             <span class="comment"># 用给定名称替换现有标签（而不是失败）</span></span><br><span class="line">    -d, --delete                            <span class="comment"># 用给定名称删除现有标签</span></span><br><span class="line">    -v, --verify                            <span class="comment"># 验证给定标签名称的GPG签名</span></span><br><span class="line">    -n&lt;num&gt;                                 <span class="comment"># &lt;num&gt;指定在使用-l时打印多少行（如果有）。意味着--list</span></span><br><span class="line">    -l, --list                              <span class="comment"># 列表标签</span></span><br><span class="line">    --sort=&lt;key&gt;                            <span class="comment"># 根据给定的关键字进行排序。前缀-按值的降序进行排序</span></span><br><span class="line">    -i, --ignore-case                       <span class="comment"># 排序和过滤标签不区分大小写</span></span><br><span class="line">    --column[=&lt;options&gt;], --no-column       <span class="comment"># 在列中显示标签列表</span></span><br><span class="line">    --contains [&lt;commit&gt;]                   <span class="comment"># 只列出包含指定提交的标签（如果未指定，则为HEAD）。意味着--list</span></span><br><span class="line">    --no-contains [&lt;commit&gt;]                <span class="comment"># 只列出不包含指定提交的标签（如果未指定，则为HEAD）。意味着--list</span></span><br><span class="line">    --merged [&lt;commit&gt;]                     <span class="comment"># 仅列出可从提交的提交（HEAD如果未指定）可访问的列表标记，与之不兼容--no-merged</span></span><br><span class="line">    --no-merged [&lt;commit&gt;]                  <span class="comment"># 仅列出其提交无法从指定提交（HEAD如果未指定）到达的标记，与之不兼容--merged</span></span><br><span class="line">    --points-at &lt;object&gt;                    <span class="comment"># 只列出给定对象的标签（HEAD，如果未指定）。意味着--list</span></span><br><span class="line">    -m &lt;msg&gt;, --message=&lt;msg&gt;               <span class="comment"># 使用给定的标签消息（而不是提示）</span></span><br><span class="line">    -F &lt;file&gt;, --file=&lt;file&gt;                <span class="comment"># 从给定的文件中获取标签消息。使用-从标准输入中读取消息。</span></span><br><span class="line">    -e, --edit                              <span class="comment"># 从带有-F和命令行的 文件中获取的消息-m通常用作未经修改的标记消息</span></span><br><span class="line">    --cleanup=&lt;mode&gt;                        <span class="comment"># 该选项设置标签消息的清理方式</span></span><br><span class="line">    --create-reflog                         <span class="comment"># 为标签创建一个reflog</span></span><br><span class="line">    &lt;tagname&gt;                               <span class="comment"># 要创建，删除或描述的标记的名称</span></span><br><span class="line">    &lt;commit&gt;, &lt;object&gt;                      <span class="comment"># 新标签将引用的对象，通常是提交。默认为HEAD</span></span><br><span class="line">    &lt;format&gt;                                <span class="comment"># %(fieldname)从显示的标记ref和指向的对象中插入一个字符串</span></span><br></pre></td></tr></table></figure><h2 id="829-git-worktree"><a class="markdownIt-Anchor" href="#829-git-worktree"></a> 8.29. git worktree</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git worktree add [-f] [--detach] [--checkout] [--lock] [-b &lt;new-branch&gt;] &lt;path&gt; [&lt;commit-ish&gt;]</span><br><span class="line">    git worktree list [--porcelain]</span><br><span class="line">    git worktree lock [--reason &lt;string&gt;] &lt;worktree&gt;</span><br><span class="line">    git worktree move &lt;worktree&gt; &lt;new-path&gt;</span><br><span class="line">    git worktree prune [-n] [-v] [--expire &lt;expire&gt;]</span><br><span class="line">    git worktree remove [--force] &lt;worktree&gt;</span><br><span class="line">    git worktree unlock &lt;worktree&gt;</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    add &lt;path&gt; [&lt;commit-ish&gt;]          # 创建&lt;path&gt;并签&lt;commit-ish&gt;出</span><br><span class="line">    list                               # 列出每个工作树的详细信息</span><br><span class="line">    lock                               # 如果工作树位于便携式设备或网络共享上，且该共享并非始终挂载，请将其锁定以防止其管理文件被自动修剪</span><br><span class="line">    move                               # 将工作树移到新位置</span><br><span class="line">    prune                              # 修剪$ GIT_DIR / worktrees中的修剪树信息</span><br><span class="line">    remove                             # 删除一棵工作树。只有干净的工作树（没有未跟踪的文件，并且没有修改跟踪的文件）可以被删除</span><br><span class="line">    unlock                             # 解锁一个工作树，允许它被修剪，移动或删除</span><br><span class="line">    -f, --force                        # 默认情况下，add拒绝创建一个新的工作树，当它 &lt;commit-ish&gt;是一个分支名称并且已经被另一个工作树签出并remove拒绝删除不干净的工作树时</span><br><span class="line">    -b &lt;new-branch&gt;, -B &lt;new-branch&gt;   # 用add，创建一个名为&lt;new-branch&gt;起始处 的新分支&lt;commit-ish&gt;，并检查&lt;new-branch&gt;新的工作树</span><br><span class="line">    --detach                           # 随着add，在新的工作树中分离HEAD</span><br><span class="line">    --[no-]checkout                    # 默认情况下，add检查出来&lt;commit-ish&gt;，但--no-checkout可以用来抑制，以进行自定义，如配置稀疏结帐结帐</span><br><span class="line">    --[no-]guess-remote                # 与worktree add &lt;path&gt;没有，&lt;commit-ish&gt;而不是创建从HEAD一个新的分支，如果存在在恰好一个远程匹配的                                         基本名称的跟踪分支&lt;path&gt;，立足于远程跟踪分支的新分支，并标记远程跟踪分支为“上游”来自新的分支</span><br><span class="line">    --[no-]track                       # 创建新分支时，如果&lt;commit-ish&gt;是分支，则将其标记为新分支中的“上游”</span><br><span class="line">    --lock                             # 创建后保持工作树锁定</span><br><span class="line">    -n, --dry-run                      # 随着prune，不要删除任何东西; 只是报告它会删除什么</span><br><span class="line">    --porcelain                        # 使用list，输出脚本的易于解析的格式</span><br><span class="line">    -v, --verbose                      # 随着prune，报告所有清除</span><br><span class="line">    --expire &lt;time&gt;                    # 使用时prune，只会使&lt;age&gt;以前的未使用的工作树过期</span><br><span class="line">    --reason &lt;string&gt;                  # 随着lock，为什么工作树被锁定的解释</span><br><span class="line">    &lt;worktree&gt;                         # 工作树可以通过相对路径或绝对路径来标识</span><br></pre></td></tr></table></figure><h2 id="830-git-submodule"><a class="markdownIt-Anchor" href="#830-git-submodule"></a> 8.30. git submodule</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git submodule [--quiet] add [&lt;options&gt;] [--] &lt;repository&gt; [&lt;path&gt;]</span><br><span class="line">    git submodule [--quiet] status [--cached] [--recursive] [--] [&lt;path&gt;…]</span><br><span class="line">    git submodule [--quiet] init [--] [&lt;path&gt;…]</span><br><span class="line">    git submodule [--quiet] deinit [-f|--force] (--all|[--] &lt;path&gt;…)</span><br><span class="line">    git submodule [--quiet] update [&lt;options&gt;] [--] [&lt;path&gt;…]</span><br><span class="line">    git submodule [--quiet] summary [&lt;options&gt;] [--] [&lt;path&gt;…]</span><br><span class="line">    git submodule [--quiet] foreach [--recursive] &lt;<span class="built_in">command</span>&gt;</span><br><span class="line">    git submodule [--quiet] sync [--recursive] [--] [&lt;path&gt;…]</span><br><span class="line">    git submodule [--quiet] absorbgitdirs [--] [&lt;path&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -q, --quiet                <span class="comment"># 只打印错误消息</span></span><br><span class="line">    --all                      <span class="comment"># 该选项仅对deinit命令有效。取消注册工作树中的所有子模块</span></span><br><span class="line">    -b, --branch               <span class="comment"># 将存储库的分支添加为子模块</span></span><br><span class="line">    -f, --force                <span class="comment"># 该选项仅适用于添加，删除和更新命令。在运行add时，允许添加一个否则忽略的子模块路径。</span></span><br><span class="line">    --cached                   <span class="comment"># 该选项仅对状态和汇总命令有效。些命令通常使用在子模块HEAD中找到的提交，但使用此选项时，将使用存储在索引中的提交。</span></span><br><span class="line">    --files                    <span class="comment"># 该选项仅对汇总命令有效。当使用此选项时，此命令会将索引中的提交与子模块HEAD中的提交进行比较。</span></span><br><span class="line">    -n, --summary-limit        <span class="comment"># 该选项仅对汇总命令有效。限制摘要大小（总共显示的提交数量）</span></span><br><span class="line">    --remote                   <span class="comment"># 该选项仅对更新命令有效。使用子模块的远程跟踪分支的状态，而不是使用超级项目的已记录的SHA-1来更新子模块</span></span><br><span class="line">    -N, --no-fetch             <span class="comment"># 该选项仅对更新命令有效。不要从远程站点获取新的对象。</span></span><br><span class="line">    --checkout                 <span class="comment"># 该选项仅对更新命令有效。检查子模块中分离的HEAD上超级项目中记录的提交。</span></span><br><span class="line">    --merge                    <span class="comment"># 该选项仅对更新命令有效。将超级项目中记录的提交合并到子模块的当前分支中。</span></span><br><span class="line">    --rebase                   <span class="comment"># 该选项仅对更新命令有效。将当前分支重新映射到超级项目中记录的提交。</span></span><br><span class="line">    --init                     <span class="comment"># 该选项仅对更新命令有效。在更新之前，初始化尚未调用“git子模块初始化”的所有子模块。</span></span><br><span class="line">    --name                     <span class="comment"># 该选项仅对add命令有效。它将子模块的名称设置为给定字符串，而不是默认其路径。</span></span><br><span class="line">    --reference &lt;repository&gt;   <span class="comment"># 该选项仅适用于添加和更新命令。这些命令有时需要克隆远程存储库。</span></span><br><span class="line">    --recursive                <span class="comment"># 此选项仅适用于foreach，更新，状态和同步命令。递归地遍历子模块。</span></span><br><span class="line">    --depth                    <span class="comment"># 该选项对添加和更新命令有效。创建一个 历史记录截断为指定修订版数的浅表副本。</span></span><br><span class="line">    --[no-]recommend-shallow   <span class="comment"># 该选项仅对更新命令有效。默认情况下，子模块的初始克隆将使用submodule.&lt;name&gt;.shallow由.gitmodules文件提供的建议 。</span></span><br><span class="line">    -j &lt;n&gt;, --<span class="built_in">jobs</span> &lt;n&gt;         <span class="comment"># 该选项仅对更新命令有效。与多个作业并行克隆新子模块。默认为submodule.fetchJobs选项。</span></span><br><span class="line">    &lt;path&gt;…                    <span class="comment"># 子模块的路径。指定时，将限制该命令仅对在指定路径中找到的子模块进行操作。</span></span><br></pre></td></tr></table></figure><h2 id="831-git-show"><a class="markdownIt-Anchor" href="#831-git-show"></a> 8.31. git show</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git show [options] [&lt;object&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    &lt;object&gt;…                                           <span class="comment"># 要显示的对象的名称（默认为HEAD）</span></span><br><span class="line">    --pretty[=&lt;format&gt;], --format=&lt;format&gt;              <span class="comment"># 漂亮地打印在提交日志的内容在给定的格式</span></span><br><span class="line">    --abbrev-commit                                     <span class="comment"># 不显示完整的40字节十六进制提交对象名称，只显示部分前缀</span></span><br><span class="line">    --no-abbrev-commit                                  <span class="comment"># 显示完整的40字节十六进制提交对象名称</span></span><br><span class="line">    --oneline                                           <span class="comment"># 这是一起使用的“--pretty = oneline --abbrev-commit”的缩写</span></span><br><span class="line">    --encoding=&lt;encoding&gt;                               <span class="comment"># 提交对象在其编码头中记录用于日志消息的编码; 这个选项可以用来告诉命令在用户首选的编码中重新编写提交日志消息</span></span><br><span class="line">    --expand-tabs=&lt;n&gt;, --expand-tabs, --no-expand-tabs  <span class="comment"># 在输出中显示日志消息之前，执行一个选项卡扩展（将每个选项卡用足够的空格替换，以填充日志消息中的倍数为&lt;n&gt;的下一个显示列）</span></span><br><span class="line">    --notes[=&lt;treeish&gt;]                                 <span class="comment"># 在显示提交日志消息时，显示注释提交的注释（请参阅git-notes [1]）</span></span><br><span class="line">    --no-notes                                          <span class="comment"># 不要显示笔记</span></span><br><span class="line">    --show-signature                                    <span class="comment"># 通过签名传递gpg --verify并显示输出来检查签名提交对象的有效性</span></span><br></pre></td></tr></table></figure><h2 id="832-git-shortlog"><a class="markdownIt-Anchor" href="#832-git-shortlog"></a> 8.32. git shortlog</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git <span class="built_in">log</span> --pretty=short | git shortlog [&lt;options&gt;]</span><br><span class="line">    git shortlog [&lt;options&gt;] [&lt;revision range&gt;] [[\--] &lt;path&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -n, --numbered                         <span class="comment"># 根据每个作者的提交数量而不是作者字母顺序对输出进行排序</span></span><br><span class="line">    -s, --summary                          <span class="comment"># 禁止提交描述并仅提供提交计数摘要</span></span><br><span class="line">    -e, --email                            <span class="comment"># 显示每位作者的电子邮件地址</span></span><br><span class="line">    --format[=&lt;format&gt;]                    <span class="comment"># 使用一些其他信息来描述每个提交，而不是提交主题</span></span><br><span class="line">    -c, --committer                        <span class="comment"># 收集并显示提交者身份而不是作者</span></span><br><span class="line">    -w[&lt;width&gt;[,&lt;indent1&gt;[,&lt;indent2&gt;]]]    <span class="comment"># 通过包装每行的输入线来包装输出width</span></span><br><span class="line">    &lt;revision range&gt;                       <span class="comment"># 仅显示指定修订范围内的提交</span></span><br><span class="line">    [\--] &lt;path&gt;…                          <span class="comment"># 只考虑足以解释如何匹配指定路径的文件的提交</span></span><br></pre></td></tr></table></figure><h2 id="833-git-describe"><a class="markdownIt-Anchor" href="#833-git-describe"></a> 8.33. git describe</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git describe [--all] [--tags] [--contains] [--abbrev=&lt;n&gt;] [&lt;commit-ish&gt;…]</span><br><span class="line">    git describe [--all] [--tags] [--contains] [--abbrev=&lt;n&gt;] --dirty[=&lt;mark&gt;]</span><br><span class="line">    git describe &lt;blob&gt;</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    &lt;commit-ish&gt;…                        <span class="comment"># 提交对象名称来描述。如果省略，则默认为HEAD</span></span><br><span class="line">    --dirty[=&lt;mark&gt;], --broken[=&lt;mark&gt;]  <span class="comment"># 描述工作树的状态。当工作树与HEAD匹配时，输出与“git describe HEAD”相同</span></span><br><span class="line">    --all                                <span class="comment"># 不要只使用带注释的标签，而应使用refs/名称空间中的任何参考</span></span><br><span class="line">    --tags                               <span class="comment"># 不要只使用带注释的标签，而要使用refs/tags名称空间中的任何标签</span></span><br><span class="line">    --contains                           <span class="comment"># 不是找到提交之前的标签，而是找到提交之后的标签，因此包含它。自动暗示 - 标签</span></span><br><span class="line">    --abbrev=&lt;n&gt;                         <span class="comment"># 使用默认的7位十六进制数字作为缩写对象名称，而不是使用&lt;n&gt;数字或根据需要的数字来组成一个唯一的对象名称</span></span><br><span class="line">    --candidates=&lt;n&gt;                     <span class="comment"># 而不是只考虑最近的10个标签作为描述输入提交的候选者，而是考虑到候选者</span></span><br><span class="line">    --exact-match                        <span class="comment"># 只输出完全匹配（一个标签直接引用提供的提交）。这是--candidates = 0的同义词。</span></span><br><span class="line">    --debug                              <span class="comment"># 精确地显示正在使用的搜索策略的信息以标准错误。标签名称仍将打印到标准输出。</span></span><br><span class="line">    --long                               <span class="comment"># 即使与标签匹配，始终输出长格式（标签，提交数量和缩写提交名称）</span></span><br><span class="line">    --match &lt;pattern&gt;                    <span class="comment"># 只考虑与给定glob(7)模式匹配的标签，不包括“refs/tags/”前缀</span></span><br><span class="line">    --exclude &lt;pattern&gt;                  <span class="comment"># 不要考虑与给定glob(7)模式匹配的标签，不包括“refs/tags/”前缀</span></span><br><span class="line">    --always                             <span class="comment"># 显示唯一缩写的提交对象作为后备</span></span><br><span class="line">    --first-parent                       <span class="comment"># 在查看合并提交后，只跟踪第一个父提交</span></span><br></pre></td></tr></table></figure><h3 id="8331-git-apply"><a class="markdownIt-Anchor" href="#8331-git-apply"></a> 8.33.1. git apply</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">语法：</span><br><span class="line">    git apply [--<span class="built_in">stat</span>] [--numstat] [--summary] [--check] [--index] [--3way]</span><br><span class="line">          [--apply] [--no-add] [--build-fake-ancestor=&lt;file&gt;] [-R | --reverse]</span><br><span class="line">          [--allow-binary-replacement | --binary] [--reject] [-z]</span><br><span class="line">          [-p&lt;n&gt;] [-C&lt;n&gt;] [--inaccurate-eof] [--recount] [--cached]</span><br><span class="line">          [--ignore-space-change | --ignore-whitespace]</span><br><span class="line">          [--whitespace=(nowarn|warn|fix|error|error-all)]</span><br><span class="line">          [--exclude=&lt;path&gt;] [--include=&lt;path&gt;] [--directory=&lt;root&gt;]</span><br><span class="line">          [--verbose] [--unsafe-paths] [&lt;patch&gt;…]</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    &lt;patch&gt;…                                    <span class="comment"># 从中读取补丁的文件。 -可用于从标准输入读取</span></span><br><span class="line">    --<span class="built_in">stat</span>                                      <span class="comment"># 输出diffstat代替输入补丁。关闭“适用”。</span></span><br><span class="line">    --numstat                                   <span class="comment"># --stat与之类似，但显示十进制表示法中添加和删除的行数以及不带缩写的路径名，以使其更加机器友好</span></span><br><span class="line">    --summary                                   <span class="comment"># 输出从git diff扩展头获取的信息的精简摘要，而不是应用该修补程序。关闭“适用”。</span></span><br><span class="line">    --check                                     <span class="comment"># 而不是应用修补程序，查看修补程序是否适用于当前工作树和/或索引文件并检测错误。关闭“适用”。</span></span><br><span class="line">    --index                                     <span class="comment"># 何时--check生效或应用修补程序，请确保修补程序适用于当前索引文件记录的内容</span></span><br><span class="line">    --cached                                    <span class="comment"># 在不接触工作树的情况下应用补丁</span></span><br><span class="line">    -3, --3way                                  <span class="comment"># 如果修补程序不能干净地应用，如果修补程序记录它应该应用的斑点的标识，则回退到3路合并，                                                  并且我们在本地可以使用这些斑点，可能会在工作树中的文件中留下冲突标记供用户解决</span></span><br><span class="line">    --build-fake-ancestor=&lt;file&gt;                <span class="comment"># 较新的git diff输出已经 为每个blob 嵌入了索引信息，以帮助识别修补程序适用的原始版本</span></span><br><span class="line">    -R, --reverse                               <span class="comment"># 反向应用补丁</span></span><br><span class="line">    --reject                                    <span class="comment"># 对于原子性，git默认应用会失败整个修补程序，并且在某些不适用的情况下不会触及工作树</span></span><br><span class="line">    -z                                          <span class="comment"># 何时--numstat给出，请勿使用路径名，但使用NUL终止的机器可读格式</span></span><br><span class="line">    -p&lt;n&gt;                                       <span class="comment"># 从传统差异路径中删除&lt;n&gt;引导斜杠。默认值是1。</span></span><br><span class="line">    -C&lt;n&gt;                                       <span class="comment"># 确保每次更改之前和之后至少有&lt;n&gt;行周围环境匹配</span></span><br><span class="line">    --unidiff-zero                              <span class="comment"># 默认情况下，git apply期望所应用的修补程序是一个至少包含一行上下文的统一差异</span></span><br><span class="line">    --apply                                     <span class="comment"># 如果您使用上面标记为“关闭应用 ”的任何选项 ，则git应用读取并输出所请求的信息，而不实际应用修补程序</span></span><br><span class="line">    --no-add                                    <span class="comment"># 应用修补程序时，忽略修补程序添加的内容</span></span><br><span class="line">    --allow-binary-replacement, --binary        <span class="comment"># 从历史上看，我们不允许在未经用户明确许可的情况下应用二进制补丁，并且此标志是实现此目的的方式</span></span><br><span class="line">    --exclude=&lt;path-pattern&gt;                    <span class="comment"># 不要将更改应用于与给定路径模式匹配的文件</span></span><br><span class="line">    --include=&lt;path-pattern&gt;                    <span class="comment"># 将更改应用于与给定路径模式匹配的文件</span></span><br><span class="line">    --ignore-space-change, --ignore-whitespace  <span class="comment"># 应用修补程序时，如果需要，请忽略上下文行中空白的更改</span></span><br><span class="line">    --whitespace=&lt;action&gt;                       <span class="comment"># 应用修补程序时，检测具有空白错误的新行或修改过的行</span></span><br><span class="line">    --inaccurate-eof                            <span class="comment"># 在某些情况下，diff的某些版本不能在文件末尾正确检测到缺失的新行</span></span><br><span class="line">    -v, --verbose                               <span class="comment"># 将进展报告给stderr。默认情况下，只会打印有关当前正在应用的修补程序的消息</span></span><br><span class="line">    --recount                                   <span class="comment"># 不要相信大块头中的行数，但通过检查补丁来推断它们</span></span><br><span class="line">    --directory=&lt;root&gt;                          <span class="comment"># 将&lt;root&gt;加入所有文件名。如果还传递了“-p”参数，则在应用新根之前应用该参数</span></span><br><span class="line">    --unsafe-paths                              <span class="comment"># 默认情况下，影响工作区域以外的补丁被拒绝为错误</span></span><br></pre></td></tr></table></figure><h2 id="834-git-mv"><a class="markdownIt-Anchor" href="#834-git-mv"></a> 8.34. git mv</h2><p>重命名文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 重命名指定的文件或者文件夹</span></span><br><span class="line">$ git mv &lt;源文件/文件夹&gt; &lt;目标文件/文件夹&gt;</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git mv &lt;options&gt;… &lt;args&gt;…</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    -f, --force             <span class="comment"># 即使目标存在，也要强制重命名或移动文件</span></span><br><span class="line">    -k                      <span class="comment"># 跳过移动或重命名会导致错误情况的操作</span></span><br><span class="line">    -n, --dry-run           <span class="comment"># 没做什么; 只显示会发生什么</span></span><br><span class="line">    -v, --verbose           <span class="comment"># 报告移动文件的名称</span></span><br></pre></td></tr></table></figure><h2 id="835-git-rm"><a class="markdownIt-Anchor" href="#835-git-rm"></a> 8.35. git rm</h2><p>删除文件或者文件夹。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 移除跟踪指定的文件，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git rm &lt;文件路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件夹，并从本地仓库的文件夹中删除</span></span><br><span class="line">$ git rm -r &lt;文件夹路径&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment"># 移除跟踪指定的文件，在本地仓库的文件夹中保留该文件</span></span><br><span class="line">$ git rm --cached</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line">    git rm [-f | --force] [-n] [-r] [--cached] [--ignore-unmatch] [--quiet] [--] &lt;file&gt;…</span><br><span class="line"></span><br><span class="line">选项：</span><br><span class="line">    &lt;file&gt;…                 <span class="comment"># 要删除的文件</span></span><br><span class="line">    -f, --force             <span class="comment"># 覆盖最新的检查</span></span><br><span class="line">    -n, --dry-run           <span class="comment"># 切勿删除任何文件。相反，只需显示它们是否存在于索引中，否则将被命令删除</span></span><br><span class="line">    -r                      <span class="comment"># 当给出主目录名时允许递归删除</span></span><br><span class="line">    --                      <span class="comment"># 此选项可用于将命令行选项与文件列表分开，（当文件名可能被误认为是命令行选项时很有用）</span></span><br><span class="line">    --cached                <span class="comment"># 使用此选项可以取消仅从索引中删除路径的情况。工作树文件，无论是否修改，都将被单独保留</span></span><br><span class="line">    --ignore-unmatch        <span class="comment"># 即使没有匹配的文件，也可以用零状态退出</span></span><br><span class="line">    -q, --quiet             <span class="comment"># 该选项禁止输出</span></span><br></pre></td></tr></table></figure><h2 id="836-git操作场景示例"><a class="markdownIt-Anchor" href="#836-git操作场景示例"></a> 8.36. Git操作场景示例</h2><h3 id="8361-删除掉本地不存在的远程分支"><a class="markdownIt-Anchor" href="#8361-删除掉本地不存在的远程分支"></a> 8.36.1. 删除掉本地不存在的远程分支</h3><p>多人合作开发时，如果远程的分支被其他开发删除掉，在本地执行 <code>git branch --all</code> 依然会显示该远程分支，可使用下列的命令进行删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 使用 pull 命令，添加 -p 参数</span></span><br><span class="line">$ git pull -p</span><br><span class="line"></span><br><span class="line"><span class="comment"># 等同于下面的命令</span></span><br><span class="line">$ git fetch -p</span><br><span class="line">$ git fetch --prune origin</span><br></pre></td></tr></table></figure><h1 id="9-错误提示"><a class="markdownIt-Anchor" href="#9-错误提示"></a> 9. 错误提示</h1><p><strong>&quot;Updates were rejected because the remote contains work that you do&quot;</strong></p><p>此错误提示遇到过的有有两种情况：</p><ol><li><p>当你所推送的文件内有子<code>.git</code>分支，也就是可能你下载别人的包下来放在你的此文件夹内使用的时候，从远程仓库同时down下来有<code>.git</code>文件，所以此时Git会认为你在本地有新的分支，因为从原理上一个<code>.git</code>仓库准许有一个<code>.git</code>配置文件夹。<br /><strong>解决办法</strong>：删除多余的<code>.git</code>配置文件夹即可</p></li><li><p>当你所推送的本地仓库与远程仓库不匹配时，也就是说远程仓库的信息在远程自己手动更改过文件，或者有其他用户更改过文件，没有同步的话就会存在冲突。<br /><strong>解决办法</strong>：先用<strong>pull</strong>命令把本地仓库的变化连接到远程仓库主分支，同步远端仓库的变化，然后再进行<strong>push</strong>操作，或者在push 后直接加上 <strong>–force的选项 / -f或者参数</strong>，选择强制覆盖远程仓库的信息变化记录;</p><p>也就是：</p><ol><li>git init //初始化仓库</li><li>git add .(文件name) //添加文件到本地仓库</li><li>git commit -m “first commit” //添加文件描述信息</li><li>git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支</li><li>git pull origin master // 把本地仓库的变化连接到远程仓库主分支</li><li>git push -u origin master //把本地仓库的文件推送到远程仓库</li></ol><p>或者：</p><ol><li>git init //初始化仓库</li><li>git add .(文件name) //添加文件到本地仓库</li><li>git commit -m “first commit” //添加文件描述信息</li><li>git remote add origin + 远程仓库地址 //链接远程仓库，创建主分支</li><li>git push -f origin master //把本地仓库的文件推送到远程仓库</li></ol></li></ol>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>emoji备忘录</title>
      <link href="/posts/948fb0b8.html"/>
      <url>/posts/948fb0b8.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><p><strong>使用格式</strong>: <code>:raw:</code></p><h1 id="1-people"><a class="markdownIt-Anchor" href="#1-people"></a> 1. People</h1><table><thead><tr><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th></tr></thead><tbody><tr><td>😄</td><td>smile</td><td>💜</td><td>purple_heart</td><td>🙆</td><td>ok_woman</td></tr><tr><td>😆</td><td>laughing</td><td>❤️</td><td>heart</td><td>🙅</td><td>no_good</td></tr><tr><td>😊</td><td>blush</td><td>💚</td><td>green_heart</td><td>💁</td><td>information_desk_person</td></tr><tr><td>😃</td><td>smiley</td><td>💔</td><td>broken_heart</td><td>🙋</td><td>raising_hand</td></tr><tr><td>☺️</td><td>relaxed</td><td>💓</td><td>heartbeat</td><td>👰</td><td>bride_with_veil</td></tr><tr><td>😏</td><td>smirk</td><td>💗</td><td>heartpulse</td><td>🙎</td><td>person_with_pouting_face</td></tr><tr><td>😍</td><td>heart_eyes</td><td>💕</td><td>two_hearts</td><td>🙍</td><td>person_frowning</td></tr><tr><td>😘</td><td>kissing_heart</td><td>💞</td><td>revolving_hearts</td><td>🙇</td><td>bow</td></tr><tr><td>😚</td><td>kissing_closed_eyes</td><td>💘</td><td>cupid</td><td>💑</td><td>couple_with_heart</td></tr><tr><td>😳</td><td>flushed</td><td>💖</td><td>sparkling_heart</td><td>💆</td><td>massage</td></tr><tr><td>😌</td><td>relieved</td><td>✨</td><td>sparkles</td><td>💇</td><td>haircut</td></tr><tr><td>😆</td><td>satisfied</td><td>⭐️</td><td>star</td><td>💅</td><td>nail_care</td></tr><tr><td>😁</td><td>grin</td><td>🌟</td><td>star2</td><td>👦</td><td>boy</td></tr><tr><td>😉</td><td>wink</td><td>💫</td><td>dizzy</td><td>👧</td><td>girl</td></tr><tr><td>😜</td><td>stuck_out_tongue_winking_eye</td><td>💥</td><td>boom</td><td>👩</td><td>woman</td></tr><tr><td>😝</td><td>stuck_out_tongue_closed_eyes</td><td>💥</td><td>collision</td><td>👨</td><td>man</td></tr><tr><td>😀</td><td>grinning</td><td>💢</td><td>anger</td><td>👶</td><td>baby</td></tr><tr><td>😗</td><td>kissing</td><td>❗️</td><td>exclamation</td><td>👵</td><td>older_woman</td></tr><tr><td>😙</td><td>kissing_smiling_eyes</td><td>❓</td><td>question</td><td>👴</td><td>older_man</td></tr><tr><td>😛</td><td>stuck_out_tongue</td><td>❕</td><td>grey_exclamation</td><td>👱</td><td>person_with_blond_hair</td></tr><tr><td>😴</td><td>sleeping</td><td>❔</td><td>grey_question</td><td>👲</td><td>man_with_gua_pi_mao</td></tr><tr><td>😟</td><td>worried</td><td>💤</td><td>zzz</td><td>👳</td><td>man_with_turban</td></tr><tr><td>😦</td><td>frowning</td><td>💨</td><td>dash</td><td>👷</td><td>construction_worker</td></tr><tr><td>😧</td><td>anguished</td><td>💦</td><td>sweat_drops</td><td>👮</td><td>cop</td></tr><tr><td>😮</td><td>open_mouth</td><td>🎶</td><td>notes</td><td>👼</td><td>angel</td></tr><tr><td>😬</td><td>grimacing</td><td>🎵</td><td>musical_note</td><td>👸</td><td>princess</td></tr><tr><td>😕</td><td>confused</td><td>🔥</td><td>fire</td><td>😺</td><td>smiley_cat</td></tr><tr><td>😯</td><td>hushed</td><td>💩</td><td>hankey</td><td>😸</td><td>smile_cat</td></tr><tr><td>😑</td><td>expressionless</td><td>💩</td><td>poop</td><td>😻</td><td>heart_eyes_cat</td></tr><tr><td>😒</td><td>unamused</td><td>💩</td><td>shit</td><td>😽</td><td>kissing_cat</td></tr><tr><td>😅</td><td>sweat_smile</td><td>👍</td><td>1</td><td>😼</td><td>smirk_cat</td></tr><tr><td>😓</td><td>sweat</td><td>👍</td><td>thumbsup</td><td>🙀</td><td>scream_cat</td></tr><tr><td>😥</td><td>disappointed_relieved</td><td>👎</td><td>-1</td><td>😿</td><td>crying_cat_face</td></tr><tr><td>😩</td><td>weary</td><td>👎</td><td>thumbsdown</td><td>😹</td><td>joy_cat</td></tr><tr><td>😔</td><td>pensive</td><td>👌</td><td>ok_hand</td><td>😾</td><td>pouting_cat</td></tr><tr><td>😞</td><td>disappointed</td><td>👊</td><td>punch</td><td>👹</td><td>japanese_ogre</td></tr><tr><td>😖</td><td>confounded</td><td>👊</td><td>facepunch</td><td>👺</td><td>japanese_goblin</td></tr><tr><td>😨</td><td>fearful</td><td>✊</td><td>fist</td><td>🙈</td><td>see_no_evil</td></tr><tr><td>😰</td><td>cold_sweat</td><td>✌️</td><td>v</td><td>🙉</td><td>hear_no_evil</td></tr><tr><td>😣</td><td>persevere</td><td>👋</td><td>wave</td><td>🙊</td><td>speak_no_evil</td></tr><tr><td>😢</td><td>cry</td><td>✋</td><td>hand</td><td>💂</td><td>guardsman</td></tr><tr><td>😭</td><td>sob</td><td>✋</td><td>raised_hand</td><td>💀</td><td>skull</td></tr><tr><td>😂</td><td>joy</td><td>👐</td><td>open_hands</td><td>🐾</td><td>feet</td></tr><tr><td>😲</td><td>astonished</td><td>☝️</td><td>point_up</td><td>👄</td><td>lips</td></tr><tr><td>😱</td><td>scream</td><td>👇</td><td>point_down</td><td>💋</td><td>kiss</td></tr><tr><td>😫</td><td>tired_face</td><td>👈</td><td>point_left</td><td>💧</td><td>droplet</td></tr><tr><td>😠</td><td>angry</td><td>👉</td><td>point_right</td><td>👂</td><td>ear</td></tr><tr><td>😡</td><td>rage</td><td>🙌</td><td>raised_hands</td><td>👀</td><td>eyes</td></tr><tr><td>😤</td><td>triumph</td><td>🙏</td><td>pray</td><td>👃</td><td>nose</td></tr><tr><td>😪</td><td>sleepy</td><td>👆</td><td>point_up_2</td><td>👅</td><td>tongue</td></tr><tr><td>😋</td><td>yum</td><td>👏</td><td>clap</td><td>💌</td><td>love_letter</td></tr><tr><td>😷</td><td>mask</td><td>💪</td><td>muscle</td><td>👤</td><td>bust_in_silhouette</td></tr><tr><td>😎</td><td>sunglasses</td><td>🤘</td><td>metal</td><td>👥</td><td>busts_in_silhouette</td></tr><tr><td>😵</td><td>dizzy_face</td><td>🖕</td><td>fu</td><td>💬</td><td>speech_balloon</td></tr><tr><td>👿</td><td>imp</td><td>🏃</td><td>runner</td><td>💭</td><td>thought_balloon</td></tr><tr><td>😈</td><td>smiling_imp</td><td>🏃</td><td>running</td><td></td><td></td></tr><tr><td>😐</td><td>neutral_face</td><td>👫</td><td>couple</td><td></td><td></td></tr><tr><td>😶</td><td>no_mouth</td><td>👪</td><td>family</td><td></td><td></td></tr><tr><td>😇</td><td>innocent</td><td>👬</td><td>two_men_holding_hands</td><td></td><td></td></tr><tr><td>👽</td><td>alien</td><td>👭</td><td>two_women_holding_hands</td><td></td><td></td></tr><tr><td>💛</td><td>yellow_heart</td><td>💃</td><td>dancer</td><td></td><td></td></tr><tr><td>💙</td><td>blue_heart</td><td>👯</td><td>dancers</td><td></td><td></td></tr></tbody></table><h1 id="2-nature"><a class="markdownIt-Anchor" href="#2-nature"></a> 2. Nature</h1><table><thead><tr><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th></tr></thead><tbody><tr><td>☀️</td><td>sunny</td><td>🐛</td><td>bug</td><td>🍁</td><td>maple_leaf</td></tr><tr><td>☔️</td><td>umbrella</td><td>🐝</td><td>honeybee</td><td>🍃</td><td>leaves</td></tr><tr><td>☁️</td><td>cloud</td><td>🐜</td><td>ant</td><td>🍂</td><td>fallen_leaf</td></tr><tr><td>❄️</td><td>snowflake</td><td>🐞</td><td>beetle</td><td>🌿</td><td>herb</td></tr><tr><td>⛄️</td><td>snowman</td><td>🐌</td><td>snail</td><td>🍄</td><td>mushroom</td></tr><tr><td>⚡️</td><td>zap</td><td>🐙</td><td>octopus</td><td>🌵</td><td>cactus</td></tr><tr><td>🌀</td><td>cyclone</td><td>🐠</td><td>tropical_fish</td><td>🌴</td><td>palm_tree</td></tr><tr><td>🌁</td><td>foggy</td><td>🐟</td><td>fish</td><td>🌲</td><td>evergreen_tree</td></tr><tr><td>🌊</td><td>ocean</td><td>🐳</td><td>whale</td><td>🌳</td><td>deciduous_tree</td></tr><tr><td>🐱</td><td>cat</td><td>🐋</td><td>whale2</td><td>🌰</td><td>chestnut</td></tr><tr><td>🐶</td><td>dog</td><td>🐬</td><td>dolphin</td><td>🌱</td><td>seedling</td></tr><tr><td>🐭</td><td>mouse</td><td>🐄</td><td>cow2</td><td>🌼</td><td>blossom</td></tr><tr><td>🐹</td><td>hamster</td><td>🐏</td><td>ram</td><td>🌾</td><td>ear_of_rice</td></tr><tr><td>🐰</td><td>rabbit</td><td>🐀</td><td>rat</td><td>🐚</td><td>shell</td></tr><tr><td>🐺</td><td>wolf</td><td>🐃</td><td>water_buffalo</td><td>🌐</td><td>globe_with_meridians</td></tr><tr><td>🐸</td><td>frog</td><td>🐅</td><td>tiger2</td><td>🌞</td><td>sun_with_face</td></tr><tr><td>🐯</td><td>tiger</td><td>🐇</td><td>rabbit2</td><td>🌝</td><td>full_moon_with_face</td></tr><tr><td>🐨</td><td>koala</td><td>🐉</td><td>dragon</td><td>🌚</td><td>new_moon_with_face</td></tr><tr><td>🐻</td><td>bear</td><td>🐐</td><td>goat</td><td>🌑</td><td>new_moon</td></tr><tr><td>🐷</td><td>pig</td><td>🐓</td><td>rooster</td><td>🌒</td><td>waxing_crescent_moon</td></tr><tr><td>🐽</td><td>pig_nose</td><td>🐕</td><td>dog2</td><td>🌓</td><td>first_quarter_moon</td></tr><tr><td>🐮</td><td>cow</td><td>🐖</td><td>pig2</td><td>🌔</td><td>waxing_gibbous_moon</td></tr><tr><td>🐗</td><td>boar</td><td>🐁</td><td>mouse2</td><td>🌕</td><td>full_moon</td></tr><tr><td>🐵</td><td>monkey_face</td><td>🐂</td><td>ox</td><td>🌖</td><td>waning_gibbous_moon</td></tr><tr><td>🐒</td><td>monkey</td><td>🐲</td><td>dragon_face</td><td>🌗</td><td>last_quarter_moon</td></tr><tr><td>🐴</td><td>horse</td><td>🐡</td><td>blowfish</td><td>🌘</td><td>waning_crescent_moon</td></tr><tr><td>🐎</td><td>racehorse</td><td>🐊</td><td>crocodile</td><td>🌜</td><td>last_quarter_moon_with_face</td></tr><tr><td>🐫</td><td>camel</td><td>🐪</td><td>dromedary_camel</td><td>🌛</td><td>first_quarter_moon_with_face</td></tr><tr><td>🐑</td><td>sheep</td><td>🐆</td><td>leopard</td><td>🌙</td><td>crescent_moon</td></tr><tr><td>🐘</td><td>elephant</td><td>🐈</td><td>cat2</td><td>🌍</td><td>earth_africa</td></tr><tr><td>🐼</td><td>panda_face</td><td>🐩</td><td>poodle</td><td>🌎</td><td>earth_americas</td></tr><tr><td>🐍</td><td>snake</td><td>🐾</td><td>paw_prints</td><td>🌏</td><td>earth_asia</td></tr><tr><td>🐦</td><td>bird</td><td>💐</td><td>bouquet</td><td>🌋</td><td>volcano</td></tr><tr><td>🐤</td><td>baby_chick</td><td>🌸</td><td>cherry_blossom</td><td>🌌</td><td>milky_way</td></tr><tr><td>🐥</td><td>hatched_chick</td><td>🌷</td><td>tulip</td><td>⛅️</td><td>partly_sunny</td></tr><tr><td>🐣</td><td>hatching_chick</td><td>🍀</td><td>four_leaf_clover</td><td></td><td></td></tr><tr><td>🐔</td><td>chicken</td><td>🌹</td><td>rose</td><td></td><td></td></tr><tr><td>🐧</td><td>penguin</td><td>🌻</td><td>sunflower</td><td></td><td></td></tr><tr><td>🐢</td><td>turtle</td><td>🌺</td><td>hibiscus</td><td></td><td></td></tr></tbody></table><h1 id="3-objects"><a class="markdownIt-Anchor" href="#3-objects"></a> 3. Objects</h1><table><thead><tr><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th></tr></thead><tbody><tr><td>🎍</td><td>bamboo</td><td>📯</td><td>postal_horn</td><td>🎸</td><td>guitar</td></tr><tr><td>💝</td><td>gift_heart</td><td>📪</td><td>mailbox_closed</td><td>👞</td><td>shoe</td></tr><tr><td>🎎</td><td>dolls</td><td>📬</td><td>mailbox_with_mail</td><td>👡</td><td>sandal</td></tr><tr><td>🎒</td><td>school_satchel</td><td>📭</td><td>mailbox_with_no_mail</td><td>👠</td><td>high_heel</td></tr><tr><td>🎓</td><td>mortar_board</td><td>📦</td><td>package</td><td>💄</td><td>lipstick</td></tr><tr><td>🎏</td><td>flags</td><td>🚪</td><td>door</td><td>👢</td><td>boot</td></tr><tr><td>🎆</td><td>fireworks</td><td>🚬</td><td>smoking</td><td>👕</td><td>shirt</td></tr><tr><td>🎇</td><td>sparkler</td><td>💣</td><td>bomb</td><td>👕</td><td>tshirt</td></tr><tr><td>🎐</td><td>wind_chime</td><td>🔫</td><td>gun</td><td>👔</td><td>necktie</td></tr><tr><td>🎑</td><td>rice_scene</td><td>🔪</td><td>hocho</td><td>👚</td><td>womans_clothes</td></tr><tr><td>🎃</td><td>jack_o_lantern</td><td>💊</td><td>pill</td><td>👗</td><td>dress</td></tr><tr><td>👻</td><td>ghost</td><td>💉</td><td>syringe</td><td>🎽</td><td>running_shirt_with_sash</td></tr><tr><td>🎅</td><td>santa</td><td>📄</td><td>page_facing_up</td><td>👖</td><td>jeans</td></tr><tr><td>🎄</td><td>christmas_tree</td><td>📃</td><td>page_with_curl</td><td>👘</td><td>kimono</td></tr><tr><td>🎁</td><td>gift</td><td>📑</td><td>bookmark_tabs</td><td>👙</td><td>bikini</td></tr><tr><td>🔔</td><td>bell</td><td>📊</td><td>bar_chart</td><td>🎀</td><td>ribbon</td></tr><tr><td>🔕</td><td>no_bell</td><td>📈</td><td>chart_with_upwards_trend</td><td>🎩</td><td>tophat</td></tr><tr><td>🎋</td><td>tanabata_tree</td><td>📉</td><td>chart_with_downwards_trend</td><td>👑</td><td>crown</td></tr><tr><td>🎉</td><td>tada</td><td>📜</td><td>scroll</td><td>👒</td><td>womans_hat</td></tr><tr><td>🎊</td><td>confetti_ball</td><td>📋</td><td>clipboard</td><td>👞</td><td>mans_shoe</td></tr><tr><td>🎈</td><td>balloon</td><td>📆</td><td>calendar</td><td>🌂</td><td>closed_umbrella</td></tr><tr><td>🔮</td><td>crystal_ball</td><td>📅</td><td>date</td><td>💼</td><td>briefcase</td></tr><tr><td>💿</td><td>cd</td><td>📇</td><td>card_index</td><td>👜</td><td>handbag</td></tr><tr><td>📀</td><td>dvd</td><td>📁</td><td>file_folder</td><td>👝</td><td>pouch</td></tr><tr><td>💾</td><td>floppy_disk</td><td>📂</td><td>open_file_folder</td><td>👛</td><td>purse</td></tr><tr><td>📷</td><td>camera</td><td>✂️</td><td>scissors</td><td>👓</td><td>eyeglasses</td></tr><tr><td>📹</td><td>video_camera</td><td>📌</td><td>pushpin</td><td>🎣</td><td>fishing_pole_and_fish</td></tr><tr><td>🎥</td><td>movie_camera</td><td>📎</td><td>paperclip</td><td>☕️</td><td>coffee</td></tr><tr><td>💻</td><td>computer</td><td>✒️</td><td>black_nib</td><td>🍵</td><td>tea</td></tr><tr><td>📺</td><td>tv</td><td>✏️</td><td>pencil2</td><td>🍶</td><td>sake</td></tr><tr><td>📱</td><td>iphone</td><td>📏</td><td>straight_ruler</td><td>🍼</td><td>baby_bottle</td></tr><tr><td>☎️</td><td>phone</td><td>📐</td><td>triangular_ruler</td><td>🍺</td><td>beer</td></tr><tr><td>☎️</td><td>telephone</td><td>📕</td><td>closed_book</td><td>🍻</td><td>beers</td></tr><tr><td>📞</td><td>telephone_receiver</td><td>📗</td><td>green_book</td><td>🍸</td><td>cocktail</td></tr><tr><td>📟</td><td>pager</td><td>📘</td><td>blue_book</td><td>🍹</td><td>tropical_drink</td></tr><tr><td>📠</td><td>fax</td><td>📙</td><td>orange_book</td><td>🍷</td><td>wine_glass</td></tr><tr><td>💽</td><td>minidisc</td><td>📓</td><td>notebook</td><td>🍴</td><td>fork_and_knife</td></tr><tr><td>📼</td><td>vhs</td><td>📔</td><td>notebook_with_decorative_cover</td><td>🍕</td><td>pizza</td></tr><tr><td>🔉</td><td>sound</td><td>📒</td><td>ledger</td><td>🍔</td><td>hamburger</td></tr><tr><td>🔈</td><td>speaker</td><td>📚</td><td>books</td><td>🍟</td><td>fries</td></tr><tr><td>🔇</td><td>mute</td><td>🔖</td><td>bookmark</td><td>🍗</td><td>poultry_leg</td></tr><tr><td>📢</td><td>loudspeaker</td><td>📛</td><td>name_badge</td><td>🍖</td><td>meat_on_bone</td></tr><tr><td>📣</td><td>mega</td><td>🔬</td><td>microscope</td><td>🍝</td><td>spaghetti</td></tr><tr><td>⌛️</td><td>hourglass</td><td>🔭</td><td>telescope</td><td>🍛</td><td>curry</td></tr><tr><td>⏳</td><td>hourglass_flowing_sand</td><td>📰</td><td>newspaper</td><td>🍤</td><td>fried_shrimp</td></tr><tr><td>⏰</td><td>alarm_clock</td><td>🏈</td><td>football</td><td>🍱</td><td>bento</td></tr><tr><td>⌚️</td><td>watch</td><td>🏀</td><td>basketball</td><td>🍣</td><td>sushi</td></tr><tr><td>📻</td><td>radio</td><td>⚽️</td><td>soccer</td><td>🍥</td><td>fish_cake</td></tr><tr><td>📡</td><td>satellite</td><td>⚾️</td><td>baseball</td><td>🍙</td><td>rice_ball</td></tr><tr><td>➿</td><td>loop</td><td>🎾</td><td>tennis</td><td>🍘</td><td>rice_cracker</td></tr><tr><td>🔍</td><td>mag</td><td>🎱</td><td>8ball</td><td>🍚</td><td>rice</td></tr><tr><td>🔎</td><td>mag_right</td><td>🏉</td><td>rugby_football</td><td>🍜</td><td>ramen</td></tr><tr><td>🔓</td><td>unlock</td><td>🎳</td><td>bowling</td><td>🍲</td><td>stew</td></tr><tr><td>🔒</td><td>lock</td><td>⛳️</td><td>golf</td><td>🍢</td><td>oden</td></tr><tr><td>🔏</td><td>lock_with_ink_pen</td><td>🚵</td><td>mountain_bicyclist</td><td>🍡</td><td>dango</td></tr><tr><td>🔐</td><td>closed_lock_with_key</td><td>🚴</td><td>bicyclist</td><td>🥚</td><td>egg</td></tr><tr><td>🔑</td><td>key</td><td>🏇</td><td>horse_racing</td><td>🍞</td><td>bread</td></tr><tr><td>💡</td><td>bulb</td><td>🏂</td><td>snowboarder</td><td>🍩</td><td>doughnut</td></tr><tr><td>🔦</td><td>flashlight</td><td>🏊</td><td>swimmer</td><td>🍮</td><td>custard</td></tr><tr><td>🔆</td><td>high_brightness</td><td>🏄</td><td>surfer</td><td>🍦</td><td>icecream</td></tr><tr><td>🔅</td><td>low_brightness</td><td>🎿</td><td>ski</td><td>🍨</td><td>ice_cream</td></tr><tr><td>🔌</td><td>electric_plug</td><td>♠️</td><td>spades</td><td>🍧</td><td>shaved_ice</td></tr><tr><td>🔋</td><td>battery</td><td>♥️</td><td>hearts</td><td>🎂</td><td>birthday</td></tr><tr><td>📲</td><td>calling</td><td>♣️</td><td>clubs</td><td>🍰</td><td>cake</td></tr><tr><td>✉️</td><td>email</td><td>♦️</td><td>diamonds</td><td>🍪</td><td>cookie</td></tr><tr><td>📫</td><td>mailbox</td><td>💎</td><td>gem</td><td>🍫</td><td>chocolate_bar</td></tr><tr><td>📮</td><td>postbox</td><td>💍</td><td>ring</td><td>🍬</td><td>candy</td></tr><tr><td>🛀</td><td>bath</td><td>🏆</td><td>trophy</td><td>🍭</td><td>lollipop</td></tr><tr><td>🛁</td><td>bathtub</td><td>🎼</td><td>musical_score</td><td>🍯</td><td>honey_pot</td></tr><tr><td>🚿</td><td>shower</td><td>🎹</td><td>musical_keyboard</td><td>🍎</td><td>apple</td></tr><tr><td>🚽</td><td>toilet</td><td>🎻</td><td>violin</td><td>🍏</td><td>green_apple</td></tr><tr><td>🔧</td><td>wrench</td><td>👾</td><td>space_invader</td><td>🍊</td><td>tangerine</td></tr><tr><td>🔩</td><td>nut_and_bolt</td><td>🎮</td><td>video_game</td><td>🍋</td><td>lemon</td></tr><tr><td>🔨</td><td>hammer</td><td>🃏</td><td>black_joker</td><td>🍒</td><td>cherries</td></tr><tr><td>💺</td><td>seat</td><td>🎴</td><td>flower_playing_cards</td><td>🍇</td><td>grapes</td></tr><tr><td>💰</td><td>moneybag</td><td>🎲</td><td>game_die</td><td>🍉</td><td>watermelon</td></tr><tr><td>💴</td><td>yen</td><td>🎯</td><td>dart</td><td>🍓</td><td>strawberry</td></tr><tr><td>💵</td><td>dollar</td><td>🀄️</td><td>mahjong</td><td>🍑</td><td>peach</td></tr><tr><td>💷</td><td>pound</td><td>🎬</td><td>clapper</td><td>🍈</td><td>melon</td></tr><tr><td>💶</td><td>euro</td><td>📝</td><td>memo</td><td>🍌</td><td>banana</td></tr><tr><td>💳</td><td>credit_card</td><td>📝</td><td>pencil</td><td>🍐</td><td>pear</td></tr><tr><td>💸</td><td>money_with_wings</td><td>📖</td><td>book</td><td>🍍</td><td>pineapple</td></tr><tr><td>📧</td><td>e-mail</td><td>🎨</td><td>art</td><td>🍠</td><td>sweet_potato</td></tr><tr><td>📥</td><td>inbox_tray</td><td>🎤</td><td>microphone</td><td>🍆</td><td>eggplant</td></tr><tr><td>📤</td><td>outbox_tray</td><td>🎧</td><td>headphones</td><td>🍅</td><td>tomato</td></tr><tr><td>✉️</td><td>envelope</td><td>🎺</td><td>trumpet</td><td>🌽</td><td>corn</td></tr><tr><td>📨</td><td>incoming_envelope</td><td>🎷</td><td>saxophone</td><td></td><td></td></tr></tbody></table><h1 id="4-places"><a class="markdownIt-Anchor" href="#4-places"></a> 4. Places</h1><table><thead><tr><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th></tr></thead><tbody><tr><td>🏠</td><td>house</td><td>⛵️</td><td>sailboat</td><td>🚝</td><td>monorail</td></tr><tr><td>🏡</td><td>house_with_garden</td><td>🚣</td><td>rowboat</td><td>🚃</td><td>railway_car</td></tr><tr><td>🏫</td><td>school</td><td>⚓️</td><td>anchor</td><td>🚎</td><td>trolleybus</td></tr><tr><td>🏢</td><td>office</td><td>🚀</td><td>rocket</td><td>🎫</td><td>ticket</td></tr><tr><td>🏣</td><td>post_office</td><td>✈️</td><td>airplane</td><td>⛽️</td><td>fuelpump</td></tr><tr><td>🏥</td><td>hospital</td><td>🚁</td><td>helicopter</td><td>🚦</td><td>vertical_traffic_light</td></tr><tr><td>🏦</td><td>bank</td><td>🚂</td><td>steam_locomotive</td><td>🚥</td><td>traffic_light</td></tr><tr><td>🏪</td><td>convenience_store</td><td>🚊</td><td>tram</td><td>⚠️</td><td>warning</td></tr><tr><td>🏩</td><td>love_hotel</td><td>🚞</td><td>mountain_railway</td><td>🚧</td><td>construction</td></tr><tr><td>🏨</td><td>hotel</td><td>🚲</td><td>bike</td><td>🔰</td><td>beginner</td></tr><tr><td>💒</td><td>wedding</td><td>🚡</td><td>aerial_tramway</td><td>🏧</td><td>atm</td></tr><tr><td>⛪️</td><td>church</td><td>🚟</td><td>suspension_railway</td><td>🎰</td><td>slot_machine</td></tr><tr><td>🏬</td><td>department_store</td><td>🚠</td><td>mountain_cableway</td><td>🚏</td><td>busstop</td></tr><tr><td>🏤</td><td>european_post_office</td><td>🚜</td><td>tractor</td><td>💈</td><td>barber</td></tr><tr><td>🌇</td><td>city_sunrise</td><td>🚙</td><td>blue_car</td><td>♨️</td><td>hotsprings</td></tr><tr><td>🌆</td><td>city_sunset</td><td>🚘</td><td>oncoming_automobile</td><td>🏁</td><td>checkered_flag</td></tr><tr><td>🏯</td><td>japanese_castle</td><td>🚗</td><td>car</td><td>🎌</td><td>crossed_flags</td></tr><tr><td>🏰</td><td>european_castle</td><td>🚗</td><td>red_car</td><td>🏮</td><td>izakaya_lantern</td></tr><tr><td>⛺️</td><td>tent</td><td>🚕</td><td>taxi</td><td>🗿</td><td>moyai</td></tr><tr><td>🏭</td><td>factory</td><td>🚖</td><td>oncoming_taxi</td><td>🎪</td><td>circus_tent</td></tr><tr><td>🗼</td><td>tokyo_tower</td><td>🚛</td><td>articulated_lorry</td><td>🎭</td><td>performing_arts</td></tr><tr><td>🗾</td><td>japan</td><td>🚌</td><td>bus</td><td>📍</td><td>round_pushpin</td></tr><tr><td>🗻</td><td>mount_fuji</td><td>🚍</td><td>oncoming_bus</td><td>🚩</td><td>triangular_flag_on_post</td></tr><tr><td>🌄</td><td>sunrise_over_mountains</td><td>🚨</td><td>rotating_light</td><td>🇯🇵</td><td>jp</td></tr><tr><td>🌅</td><td>sunrise</td><td>🚓</td><td>police_car</td><td>🇰🇷</td><td>kr</td></tr><tr><td>🌠</td><td>stars</td><td>🚔</td><td>oncoming_police_car</td><td>🇨🇳</td><td>cn</td></tr><tr><td>🗽</td><td>statue_of_liberty</td><td>🚒</td><td>fire_engine</td><td>🇺🇸</td><td>us</td></tr><tr><td>🌉</td><td>bridge_at_night</td><td>🚑</td><td>ambulance</td><td>🇫🇷</td><td>fr</td></tr><tr><td>🎠</td><td>carousel_horse</td><td>🚐</td><td>minibus</td><td>🇪🇸</td><td>es</td></tr><tr><td>🌈</td><td>rainbow</td><td>🚚</td><td>truck</td><td>🇮🇹</td><td>it</td></tr><tr><td>🎡</td><td>ferris_wheel</td><td>🚋</td><td>train</td><td>🇷🇺</td><td>ru</td></tr><tr><td>⛲️</td><td>fountain</td><td>🚉</td><td>station</td><td>🇬🇧</td><td>gb</td></tr><tr><td>🎢</td><td>roller_coaster</td><td>🚆</td><td>train2</td><td>🇬🇧</td><td>uk</td></tr><tr><td>🚢</td><td>ship</td><td>🚅</td><td>bullettrain_front</td><td>🇩🇪</td><td>de</td></tr><tr><td>🚤</td><td>speedboat</td><td>🚄</td><td>bullettrain_side</td><td></td><td></td></tr><tr><td>⛵️</td><td>boat</td><td>🚈</td><td>light_rail</td><td></td><td></td></tr></tbody></table><h1 id="5-symbols"><a class="markdownIt-Anchor" href="#5-symbols"></a> 5. Symbols</h1><table><thead><tr><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th><th>emoji</th><th>raw</th></tr></thead><tbody><tr><td>1️⃣</td><td>one</td><td>🚭</td><td>no_smoking</td><td>🕥</td><td>clock1030</td></tr><tr><td>2️⃣</td><td>two</td><td>🅿️</td><td>parking</td><td>🕚</td><td>clock11</td></tr><tr><td>3️⃣</td><td>three</td><td>♿️</td><td>wheelchair</td><td>🕦</td><td>clock1130</td></tr><tr><td>4️⃣</td><td>four</td><td>🚇</td><td>metro</td><td>🕛</td><td>clock12</td></tr><tr><td>5️⃣</td><td>five</td><td>🛄</td><td>baggage_claim</td><td>🕧</td><td>clock1230</td></tr><tr><td>6️⃣</td><td>six</td><td>🉑</td><td>accept</td><td>🕑</td><td>clock2</td></tr><tr><td>7️⃣</td><td>seven</td><td>🚾</td><td>wc</td><td>🕝</td><td>clock230</td></tr><tr><td>8️⃣</td><td>eight</td><td>🚰</td><td>potable_water</td><td>🕒</td><td>clock3</td></tr><tr><td>9️⃣</td><td>nine</td><td>🚮</td><td>put_litter_in_its_place</td><td>🕞</td><td>clock330</td></tr><tr><td>🔟</td><td>keycap_ten</td><td>㊙️</td><td>secret</td><td>🕓</td><td>clock4</td></tr><tr><td>🔢</td><td>1234</td><td>㊗️</td><td>congratulations</td><td>🕟</td><td>clock430</td></tr><tr><td>0️⃣</td><td>zero</td><td>Ⓜ️</td><td>m</td><td>🕔</td><td>clock5</td></tr><tr><td>#️⃣</td><td>hash</td><td>🛂</td><td>passport_control</td><td>🕠</td><td>clock530</td></tr><tr><td>🔣</td><td>symbols</td><td>🛅</td><td>left_luggage</td><td>🕕</td><td>clock6</td></tr><tr><td>◀️</td><td>arrow_backward</td><td>🛃</td><td>customs</td><td>🕡</td><td>clock630</td></tr><tr><td>⬇️</td><td>arrow_down</td><td>🉐</td><td>ideograph_advantage</td><td>🕖</td><td>clock7</td></tr><tr><td>▶️</td><td>arrow_forward</td><td>🆑</td><td>cl</td><td>🕢</td><td>clock730</td></tr><tr><td>⬅️</td><td>arrow_left</td><td>🆘</td><td>sos</td><td>🕗</td><td>clock8</td></tr><tr><td>🔠</td><td>capital_abcd</td><td>🆔</td><td>id</td><td>🕣</td><td>clock830</td></tr><tr><td>🔡</td><td>abcd</td><td>🚫</td><td>no_entry_sign</td><td>🕘</td><td>clock9</td></tr><tr><td>🔤</td><td>abc</td><td>🔞</td><td>underage</td><td>🕤</td><td>clock930</td></tr><tr><td>↙️</td><td>arrow_lower_left</td><td>📵</td><td>no_mobile_phones</td><td>💲</td><td>heavy_dollar_sign</td></tr><tr><td>↘️</td><td>arrow_lower_right</td><td>🚯</td><td>do_not_litter</td><td>©️</td><td>copyright</td></tr><tr><td>➡️</td><td>arrow_right</td><td>🚱</td><td>non-potable_water</td><td>®️</td><td>registered</td></tr><tr><td>⬆️</td><td>arrow_up</td><td>🚳</td><td>no_bicycles</td><td>™️</td><td>tm</td></tr><tr><td>↖️</td><td>arrow_upper_left</td><td>🚷</td><td>no_pedestrians</td><td>❌</td><td>x</td></tr><tr><td>↗️</td><td>arrow_upper_right</td><td>🚸</td><td>children_crossing</td><td>❗️</td><td>heavy_exclamation_mark</td></tr><tr><td>⏬</td><td>arrow_double_down</td><td>⛔️</td><td>no_entry</td><td>‼️</td><td>bangbang</td></tr><tr><td>⏫</td><td>arrow_double_up</td><td>✳️</td><td>eight_spoked_asterisk</td><td>⁉️</td><td>interrobang</td></tr><tr><td>🔽</td><td>arrow_down_small</td><td>❇️</td><td>sparkle</td><td>⭕️</td><td>o</td></tr><tr><td>⤵️</td><td>arrow_heading_down</td><td>✴️</td><td>eight_pointed_black_star</td><td>✖️</td><td>heavy_multiplication_x</td></tr><tr><td>⤴️</td><td>arrow_heading_up</td><td>💟</td><td>heart_decoration</td><td>➕</td><td>heavy_plus_sign</td></tr><tr><td>↩️</td><td>leftwards_arrow_with_hook</td><td>🆚</td><td>vs</td><td>➖</td><td>heavy_minus_sign</td></tr><tr><td>↪️</td><td>arrow_right_hook</td><td>📳</td><td>vibration_mode</td><td>➗</td><td>heavy_division_sign</td></tr><tr><td>↔️</td><td>left_right_arrow</td><td>📴</td><td>mobile_phone_off</td><td>💮</td><td>white_flower</td></tr><tr><td>↕️</td><td>arrow_up_down</td><td>💹</td><td>chart</td><td>💯</td><td>100</td></tr><tr><td>🔼</td><td>arrow_up_small</td><td>💱</td><td>currency_exchange</td><td>✔️</td><td>heavy_check_mark</td></tr><tr><td>🔃</td><td>arrows_clockwise</td><td>♈️</td><td>aries</td><td>☑️</td><td>ballot_box_with_check</td></tr><tr><td>🔄</td><td>arrows_counterclockwise</td><td>♉️</td><td>taurus</td><td>🔘</td><td>radio_button</td></tr><tr><td>⏪</td><td>rewind</td><td>♊️</td><td>gemini</td><td>🔗</td><td>link</td></tr><tr><td>⏩</td><td>fast_forward</td><td>♋️</td><td>cancer</td><td>➰</td><td>curly_loop</td></tr><tr><td>ℹ️</td><td>information_source</td><td>♌️</td><td>leo</td><td>〰️</td><td>wavy_dash</td></tr><tr><td>🆗</td><td>ok</td><td>♍️</td><td>virgo</td><td>〽️</td><td>part_alternation_mark</td></tr><tr><td>🔀</td><td>twisted_rightwards_arrows</td><td>♎️</td><td>libra</td><td>🔱</td><td>trident</td></tr><tr><td>🔁</td><td>repeat</td><td>♏️</td><td>scorpius</td><td>▪️</td><td>black_small_square</td></tr><tr><td>🔂</td><td>repeat_one</td><td>♐️</td><td>sagittarius</td><td>▫️</td><td>white_small_square</td></tr><tr><td>🆕</td><td>new</td><td>♑️</td><td>capricorn</td><td>◾️</td><td>black_medium_small_square</td></tr><tr><td>🔝</td><td>top</td><td>♒️</td><td>aquarius</td><td>◽️</td><td>white_medium_small_square</td></tr><tr><td>🆙</td><td>up</td><td>♓️</td><td>pisces</td><td>◼️</td><td>black_medium_square</td></tr><tr><td>🆒</td><td>cool</td><td>⛎</td><td>ophiuchus</td><td>◻️</td><td>white_medium_square</td></tr><tr><td>🆓</td><td>free</td><td>🔯</td><td>six_pointed_star</td><td>⬛️</td><td>black_large_square</td></tr><tr><td>🆖</td><td>ng</td><td>❎</td><td>negative_squared_cross_mark</td><td>⬜️</td><td>white_large_square</td></tr><tr><td>🎦</td><td>cinema</td><td>🅰️</td><td>a</td><td>✅</td><td>white_check_mark</td></tr><tr><td>🈁</td><td>koko</td><td>🅱️</td><td>b</td><td>🔲</td><td>black_square_button</td></tr><tr><td>📶</td><td>signal_strength</td><td>🆎</td><td>ab</td><td>🔳</td><td>white_square_button</td></tr><tr><td>🈵</td><td>u6e80</td><td>🅾️</td><td>o2</td><td>⚫️</td><td>black_circle</td></tr><tr><td>:u7121:</td><td>u7121</td><td>💠</td><td>diamond_shape_with_a_dot_inside</td><td>⚪️</td><td>white_circle</td></tr><tr><td>:u7533:</td><td>u7533</td><td>♻️</td><td>recycle</td><td>🔴</td><td>red_circle</td></tr><tr><td>:u7a7a:</td><td>u7a7a</td><td>🔚</td><td>end</td><td>🔵</td><td>large_blue_circle</td></tr><tr><td>:u7981:</td><td>u7981</td><td>🔙</td><td>back</td><td>🔷</td><td>large_blue_diamond</td></tr><tr><td>🈂️</td><td>sa</td><td>🔛</td><td>on</td><td>🔶</td><td>large_orange_diamond</td></tr><tr><td>🚻</td><td>restroom</td><td>🔜</td><td>soon</td><td>🔹</td><td>small_blue_diamond</td></tr><tr><td>🚹</td><td>mens</td><td>🕐</td><td>clock1</td><td>🔸</td><td>small_orange_diamond</td></tr><tr><td>🚺</td><td>womens</td><td>🕜</td><td>clock130</td><td>🔺</td><td>small_red_triangle</td></tr><tr><td>🚼</td><td>baby_symbol</td><td>🕙</td><td>clock10</td><td>🔻</td><td>small_red_triangle_down</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git深层剖析</title>
      <link href="/posts/cb41abda.html"/>
      <url>/posts/cb41abda.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-git简介"><a class="markdownIt-Anchor" href="#1-git简介"></a> 1. Git简介</h1><p>Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大的项目。<br />Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的一个开放源码的版本控制软件。<br />Git 与常用的版本控制工具 CVS, Subversion 等不同，它采用了分布式版本库的方式，不必服务器端软件支持。<br />太多的废话不说了摆出相关的几个主流的服务商:<br /><a href="https://github.com"><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/git/github.jpg" alt="Github-Logo" /></a><br /><a href="https://gitee.com"><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/git/gitee.jpg" alt="Gitee-Logo" /></a></p><h1 id="2-工作流程"><a class="markdownIt-Anchor" href="#2-工作流程"></a> 2. 工作流程</h1><p>一般工作流程如下：</p><ul><li>克隆 Git 资源作为工作目录。</li><li>在克隆的资源上添加或修改文件。</li><li>如果其他人修改了，你可以更新资源。</li><li>在提交前查看修改。</li><li>提交修改。</li><li>在修改完成后，如果发现错误，可以撤回提交并再次修改并提交。</li></ul><h1 id="3-git-工作区-暂存区和版本库"><a class="markdownIt-Anchor" href="#3-git-工作区-暂存区和版本库"></a> 3. Git 工作区、暂存区和版本库</h1><h2 id="31-基本概念"><a class="markdownIt-Anchor" href="#31-基本概念"></a> 3.1. 基本概念</h2><p>我们先来理解下Git 工作区、暂存区和版本库概念</p><ul><li><strong>工作区</strong>：就是你在电脑里能看到的目录。</li><li><strong>暂存区</strong>：英文叫stage, 或index。一般存放在 “.git目录下” 下的index文件（.git/index）中，所以我们把暂存区有时也叫作索引（index）。</li><li><strong>版本库</strong>：工作区有一个隐藏目录.git，这个不算工作区，而是Git的版本库。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/git/git-construction.jpg" alt="Git结构示图" /><br />图中左侧为工作区，右侧为版本库。在版本库中标记为 “<strong>index</strong>” 的区域是暂存区（stage, index），标记为 “<strong>master</strong>” 的是 master 分支所代表的目录树。<br />图中我们可以看出此时 “HEAD” 实际是指向 <strong>master</strong> 分支的一个&quot;游标&quot;。所以图示的命令中出现 HEAD 的地方可以用 master 来替换。<br />图中的 <strong>objects</strong> 标识的区域为 Git 的对象库，实际位于 “<strong>.git/objects</strong>” 目录下，里面包含了创建的各种对象及内容。<br />当对工作区修改（或新增）的文件执行 “<strong>git add</strong>” 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。<br />当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。<br />当执行 “git reset HEAD” 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。<br />当执行 &quot;<strong>git rm --cached <file></strong>&quot; 命令时，会直接从暂存区删除文件，工作区则不做出改变。<br />当执行 “<strong>git checkout .</strong>” 或者 &quot;<strong>git checkout – <file></strong>&quot; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。<br />当执行 “git checkout HEAD .” 或者 &quot;<strong>git checkout HEAD <file></strong>&quot; 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p><h1 id="4-git-创建仓库"><a class="markdownIt-Anchor" href="#4-git-创建仓库"></a> 4. Git 创建仓库</h1><p>本章节我们将为大家介绍如何创建一个 Git 仓库。<br />你可以使用一个已经存在的目录作为Git仓库。</p><h2 id="41-git-init"><a class="markdownIt-Anchor" href="#41-git-init"></a> 4.1. git init</h2><p>Git 使用 git init 命令来初始化一个 Git 仓库，Git 的很多命令都需要在 Git 的仓库中运行，所以 git init 是使用 Git 的第一个命令。<br />在执行完成 git init 命令后，Git 仓库会生成一个 .git 目录，该目录包含了资源的所有元数据，其他的项目目录保持不变（不像 SVN 会在每个子目录生成 .svn 目录，Git 只在仓库的根目录生成 .git 目录）。</p><h3 id="411-使用方法"><a class="markdownIt-Anchor" href="#411-使用方法"></a> 4.1.1. 使用方法</h3><p>使用当前目录作为Git仓库，我们只需使它初始化。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init</span><br></pre></td></tr></table></figure><p>该命令执行完后会在当前目录生成一个 .git 目录。</p><p>使用我们指定目录作为Git仓库。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git init newrepo</span><br></pre></td></tr></table></figure><p>初始化后，会在 newrepo 目录下会出现一个名为 .git 的目录，所有 Git 需要的数据和资源都存放在这个目录中。</p><p>如果当前目录下有几个文件想要纳入版本控制，需要先用 git add 命令告诉 Git 开始对这些文件进行跟踪，然后提交：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ git add *.c</span><br><span class="line">$ git add README</span><br><span class="line">$ git commit -m <span class="string">&#x27;初始化项目版本&#x27;</span></span><br></pre></td></tr></table></figure><p>以上命令将目录下以 .c 结尾及 README 文件提交到仓库中。</p><h2 id="42-git-clone"><a class="markdownIt-Anchor" href="#42-git-clone"></a> 4.2. git clone</h2><p>我们使用 git clone 从现有 Git 仓库中拷贝项目（类似 svn checkout）。<br />克隆仓库的命令格式为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt;</span><br></pre></td></tr></table></figure><p>如果我们需要克隆到指定的目录，可以使用以下命令格式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> &lt;repo&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure><h3 id="421-参数说明"><a class="markdownIt-Anchor" href="#421-参数说明"></a> 4.2.1. 参数说明：</h3><p><strong>repo</strong>: Git 仓库。<br /><strong>directory</strong>: 本地目录。<br />比如，要克隆 Ruby 语言的 Git 代码仓库 Grit，可以用下面的命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git</span><br></pre></td></tr></table></figure><p>执行该命令后，会在当前目录下创建一个名为grit的目录，其中包含一个 .git 的目录，用于保存下载下来的所有版本记录。<br />如果要自己定义要新建的项目目录名称，可以在上面的命令末尾指定新的名字：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> git://github.com/schacon/grit.git mygrit</span><br></pre></td></tr></table></figure><h3 id="422-几种git-clone等价的写法"><a class="markdownIt-Anchor" href="#422-几种git-clone等价的写法"></a> 4.2.2. 几种git clone等价的写法</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> http://github.com/CosmosHua/locate new</span><br><span class="line">git <span class="built_in">clone</span> http://github.com/CosmosHua/locate.git new</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/CosmosHua/locate new</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/CosmosHua/locate.git new</span><br></pre></td></tr></table></figure><h3 id="423-几种不同的clone通讯协议"><a class="markdownIt-Anchor" href="#423-几种不同的clone通讯协议"></a> 4.2.3. 几种不同的clone通讯协议</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:fsliurujie/test.git         --SSH协议</span><br><span class="line">git <span class="built_in">clone</span> git://github.com/fsliurujie/test.git          --GIT协议</span><br><span class="line">git <span class="built_in">clone</span> https://github.com/fsliurujie/test.git      --HTTPS协议</span><br></pre></td></tr></table></figure><h1 id="5-配置账户信息"><a class="markdownIt-Anchor" href="#5-配置账户信息"></a> 5. 配置账户信息</h1><p>为了避免每次操作时输入账户名,我们配置好账户信息,当然也可以仔细去<strong>config</strong>文件里面修改</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config --global user.name <span class="string">&#x27;xxx&#x27;</span></span><br><span class="line">$ git config --global user.email xxxxxxxxx@xxx.com</span><br></pre></td></tr></table></figure><h1 id="6-基本操作"><a class="markdownIt-Anchor" href="#6-基本操作"></a> 6. 基本操作</h1><h2 id="61-获取与创建项目命令"><a class="markdownIt-Anchor" href="#61-获取与创建项目命令"></a> 6.1. 获取与创建项目命令</h2><h3 id="611-git-init"><a class="markdownIt-Anchor" href="#611-git-init"></a> 6.1.1. git init</h3><p>用 git init 在目录中创建新的 Git 仓库。 你可以在任何时候、任何目录中这么做，完全是本地化的。<br />下面就是你刚刚初始化后的文件目录结构:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ls -a</span><br><span class="line">.    ..    .git</span><br></pre></td></tr></table></figure><h3 id="612-git-clone"><a class="markdownIt-Anchor" href="#612-git-clone"></a> 6.1.2. git clone</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> git@github.com:xx用户名xx/xx仓库名xx.git</span><br></pre></td></tr></table></figure><h2 id="62-基本快照"><a class="markdownIt-Anchor" href="#62-基本快照"></a> 6.2. 基本快照</h2><h3 id="621-git-add"><a class="markdownIt-Anchor" href="#621-git-add"></a> 6.2.1. git add</h3><p>将该文件添加到缓存<br />添加所有文件–&gt; **git add . **</p><h3 id="622-git-status"><a class="markdownIt-Anchor" href="#622-git-status"></a> 6.2.2. git status</h3><p>git status 以查看在你上次提交之后是否有修改。<br />执行该命令的时候可以加 <strong>-s</strong> 参数，s是simple的意思,以获得简短的结果输出。如果没加该参数会详细输出内容。<br />“<strong>AM</strong>” 状态的意思是，这个文件在我们将它添加到缓存之后又有改动。,它提示我们将该文件更新<br />如果我们已经记录了快照。如果我们再执行 git status,就会提示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># On branch master</span></span><br><span class="line">nothing to commit (working directory clean)</span><br></pre></td></tr></table></figure><p>以上输出说明我们在最近一次提交之后，没有做任何改动，是一个&quot;working directory clean：干净的工作目录&quot;。</p><h3 id="623-git-diff"><a class="markdownIt-Anchor" href="#623-git-diff"></a> 6.2.3. git diff</h3><p>执行 git diff 来查看执行 git status 的结果的详细信息。<br />git diff 命令显示已写入缓存与已修改但尚未写入缓存的改动的区别。git diff 有两个主要的应用场景。</p><ul><li>尚未缓存的改动：git diff</li><li>查看已缓存的改动： git diff --cached</li><li>查看已缓存的与未缓存的所有改动：git diff HEAD</li><li>显示摘要而非整个 diff：git diff --stat</li></ul><p><strong>git status 显示你上次提交更新后的更改或者写入缓存的改动， 而 git diff 一行一行地显示这些改动具体是啥。</strong></p><h3 id="624-git-commit"><a class="markdownIt-Anchor" href="#624-git-commit"></a> 6.2.4. git commit</h3><p>如果你没有设置 <strong>-m</strong> 选项，Git 会尝试为你打开一个编辑器以填写提交信息。 如果 Git 在你对它的配置中找不到相关信息，默认会打开 vim。</p><p>如果你觉得 <strong>git add</strong> 提交缓存的流程太过繁琐，Git 也允许你用 <strong>-a</strong> 选项跳过这一步。</p><h3 id="625-git-reset-head"><a class="markdownIt-Anchor" href="#625-git-reset-head"></a> 6.2.5. git reset HEAD</h3><p><strong>git reset HEAD</strong> 命令用于取消已缓存的内容。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git reset HEAD xxxxx.xxx   ---&gt;取消xxxx.xxx的文件改动缓存</span><br></pre></td></tr></table></figure><h3 id="626-git-rm"><a class="markdownIt-Anchor" href="#626-git-rm"></a> 6.2.6. git rm</h3><p>如果只是简单地从工作目录中手工删除文件，运行 <code>git status</code> 时就会在 <code>Changes not staged for commit</code> 的提示。<br />要从 Git 中移除某个文件，就必须要从已跟踪文件清单中移除，然后提交。可以用以下命令完成此项工作</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm &lt;file&gt;</span><br></pre></td></tr></table></figure><p>如果删除之前修改过并且已经放到暂存区域的话，则必须要用强制删除选项 -f</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -f &lt;file&gt;</span><br></pre></td></tr></table></figure><p>如果把文件从暂存区域移除，但仍然希望保留在当前工作目录中，换句话说，仅是从跟踪清单中删除，使用 --cached 选项即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm --cached &lt;file&gt;</span><br></pre></td></tr></table></figure><p>不从工作区中删除文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git rm --cached xxxx.xx</span><br></pre></td></tr></table></figure><p>递归删除，递归删除整个目录中的所有子目录和文件：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git rm -r * </span><br></pre></td></tr></table></figure><h3 id="627-git-mv"><a class="markdownIt-Anchor" href="#627-git-mv"></a> 6.2.7. git mv</h3><p><code>git mv</code> 命令用于移动或重命名一个文件、目录、软连接。</p><h1 id="7-git-分支管理"><a class="markdownIt-Anchor" href="#7-git-分支管理"></a> 7. Git 分支管理</h1><p>几乎每一种版本控制系统都以某种形式支持分支。使用分支意味着你可以从开发主线上分离开来，然后在不影响主线的同时继续工作。<br />有人把 Git 的分支模型称为必杀技特性，而正是因为它，将 Git 从版本控制系统家族里区分出来。</p><h2 id="71-创建分支"><a class="markdownIt-Anchor" href="#71-创建分支"></a> 7.1. 创建分支</h2><p><code>git branch (branchname)</code></p><h2 id="72-列出分支"><a class="markdownIt-Anchor" href="#72-列出分支"></a> 7.2. 列出分支</h2><p><code>git branch</code><br />在上次提交更新之后创建了新分支，如果后来又有更新提交，然后又切换到了该分支，<strong>Git 将还原你的工作目录到你创建分支时候的样子。</strong></p><h2 id="73-切换分支"><a class="markdownIt-Anchor" href="#73-切换分支"></a> 7.3. 切换分支</h2><p><code>git checkout (branchname)</code><br />当你切换分支的时候，Git 会用该分支的最后提交的快照替换你的工作目录的内容，所以多个分支不需要多个目录。<br />我们也可以使用 <code>git checkout -b (branchname)</code> 命令来创建新分支并立即切换到该分支下，从而在该分支中操作。</p><h2 id="74-删除分支"><a class="markdownIt-Anchor" href="#74-删除分支"></a> 7.4. 删除分支</h2><p><code>git branch -d (branchname)</code></p><h2 id="75-合并分支"><a class="markdownIt-Anchor" href="#75-合并分支"></a> 7.5. 合并分支</h2><p><code>git merge</code><br />一旦某分支有了独立内容，你终究会希望将它合并回到你的主分支。<br />你可以多次合并到统一分支， 也可以选择在合并之后直接删除被并入的分支。</p><p>合并完后就可以删除分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git branch -d xxxx</span><br></pre></td></tr></table></figure><h2 id="76-合并冲突处理"><a class="markdownIt-Anchor" href="#76-合并冲突处理"></a> 7.6. 合并冲突处理</h2><p>冲突提示:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONFLICT (content): Merge conflict <span class="keyword">in</span> xxxxx.xxx</span><br></pre></td></tr></table></figure><h1 id="8-git-查看提交历史"><a class="markdownIt-Anchor" href="#8-git-查看提交历史"></a> 8. Git 查看提交历史</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>我们可以用<code>--oneline</code>选项来查看历史记录的简洁的版本。<br />我们还可以用<code>--graph</code>选项，查看历史中什么时候出现了分支、合并。<br />也可以用<code>--reverse</code>参数来逆向显示所有日志。<br />如果只想查找指定用户的提交日志可以使用命令：<code>git log --author</code><br />如果你要指定日期，可以执行几个选项：<code>--since</code>和<code>--before</code>，但是你也可以用<code>--until</code>和<code>--after</code>。</p><h1 id="9-git-tag标签"><a class="markdownIt-Anchor" href="#9-git-tag标签"></a> 9. Git tag标签</h1><p>当项目达到一个重要的阶段，并希望永远记住那个特别的提交快照，可以使用 <code>git tag</code> 给它打上标签。</p><p>我们可以用 <code>git tag -a v1.0.1</code> 命令给最新一次提交打上（HEAD）“v1.0.1&quot;的标签。<br /><code>-a</code> 选项意为&quot;创建一个带注解的标签”。 不用 <code>-a</code> 选项也可以执行的，但它不会记录这标签是啥时候打的，谁打的，也不会让你添加个标签的注解。 当我们执行 ·git log --decorate· 时，我们可以看到我们的标签了。</p><p>如果我们忘了给某个提交打标签，又将它发布了，我们可以给它追加标签。<br />例如，假设我们发布了提交 85fc7e7(上面实例最后一行)，但是那时候忘了给它打标签。 此时我们现在也可以：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag -a v0.9 (更新节点名,例如:85fc7e7)</span><br></pre></td></tr></table></figure><p>查看所有标签可以使用以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git tag</span><br></pre></td></tr></table></figure><p>指定标签信息命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -a &lt;tagname&gt; -m <span class="string">&quot;xxx标签xxx&quot;</span></span><br></pre></td></tr></table></figure><p>PGP签名标签命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag -s &lt;tagname&gt; -m <span class="string">&quot;xxx标签xxx&quot;</span></span><br></pre></td></tr></table></figure><h1 id="10-git-远程仓库github"><a class="markdownIt-Anchor" href="#10-git-远程仓库github"></a> 10. Git 远程仓库(Github)</h1><h2 id="101-添加远程库"><a class="markdownIt-Anchor" href="#101-添加远程库"></a> 10.1. 添加远程库</h2><p>要添加一个新的远程仓库，可以指定一个简单的名字，以便将来引用,命令格式如下：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add [shortname] [url]</span><br></pre></td></tr></table></figure><p>使用 <code>git remote -v</code> 查看远程库信息</p><p>由于本地 Git 仓库和 GitHub 仓库之间的传输是通过SSH加密的，所以我们需要配置验证信息：<br />使用以下命令生成 SSH Key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa -C <span class="string">&quot;youremail@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>验证是否成功，输入以下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ ssh -T git@github.com</span><br></pre></td></tr></table></figure><h2 id="102-查看当前的远程库"><a class="markdownIt-Anchor" href="#102-查看当前的远程库"></a> 10.2. 查看当前的远程库</h2><p>要查看当前配置有哪些远程仓库，可以用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote</span><br></pre></td></tr></table></figure><h2 id="103-提取远程仓库"><a class="markdownIt-Anchor" href="#103-提取远程仓库"></a> 10.3. 提取远程仓库</h2><p>Git 有两个命令用来提取远程仓库的更新。</p><ol><li>从远程仓库下载新分支与数据：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git fetch</span><br></pre></td></tr></table></figure><p>该命令执行完后需要执行git merge 远程分支到你所在的分支。<br />2. 从远端仓库提取数据并尝试合并到当前分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge</span><br></pre></td></tr></table></figure><p>该命令就是在执行 git fetch 之后紧接着执行 git merge 远程分支到你所在的任意分支。</p><p>假设你配置好了一个远程仓库，并且你想要提取更新的数据，你可以首先执行 git fetch [alias] 告诉 Git 去获取它有你没有的数据，然后你可以执行 git merge [alias]/[branch] 以将服务器上的任何更新（假设有人这时候推送到服务器了）合并到你的当前分支。</p><h2 id="104-推送到远程仓库"><a class="markdownIt-Anchor" href="#104-推送到远程仓库"></a> 10.4. 推送到远程仓库</h2><p>推送你的新分支与数据到某个远端仓库,将你的 [branch] 分支推送成为 [alias] 远程仓库上的 [branch] 分支:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push [<span class="built_in">alias</span>] [branch]</span><br></pre></td></tr></table></figure><h2 id="105-删除远程仓库"><a class="markdownIt-Anchor" href="#105-删除远程仓库"></a> 10.5. 删除远程仓库</h2><p>删除远程仓库你可以使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm [别名]</span><br></pre></td></tr></table></figure><h1 id="11-git-远程仓库gitee"><a class="markdownIt-Anchor" href="#11-git-远程仓库gitee"></a> 11. Git 远程仓库(Gitee)</h1><p>操作基本与github一致</p><h1 id="12-双远程仓库同步"><a class="markdownIt-Anchor" href="#12-双远程仓库同步"></a> 12. 双远程仓库同步</h1><p>先删除已关联的名为 origin 的远程库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote rm origin</span><br></pre></td></tr></table></figure><p>然后，先关联 GitHub 的远程库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add github git@github.com:tianqixin/runoob-git-test.git</span><br></pre></td></tr></table></figure><p>注意，远程库的名称叫 github，不叫 origin 了。<br />接着，再关联 Gitee 的远程库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add gitee git@gitee.com:imnoob/runoob-test.git</span><br></pre></td></tr></table></figure><p>同样注意，远程库的名称叫 gitee，不叫 origin。<br />现在，我们用 git remote -v 查看远程库信息，可以看到两个远程库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">git remote -v</span><br><span class="line">gitee    git@gitee.com:xxxx/xx.git (fetch)</span><br><span class="line">gitee    git@gitee.com:xxxx/xx.git (push)</span><br><span class="line">github    git@github.com:xxxx/xx.git (fetch)</span><br><span class="line">github    git@github.com:xxxx/xx.git (push)</span><br></pre></td></tr></table></figure><p>如果要推送到 GitHub，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push github master</span><br></pre></td></tr></table></figure><p>如果要推送到 Gitee，使用命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push gitee master</span><br></pre></td></tr></table></figure><p>这样一来，我们的本地库就可以同时与多个远程库实现互相同步,nice!</p>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Git快速使用</title>
      <link href="/posts/e22c3c3.html"/>
      <url>/posts/e22c3c3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-创建新仓库"><a class="markdownIt-Anchor" href="#1-创建新仓库"></a> 1. 创建新仓库</h1><p>创建新文件夹，打开，然后执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git init</span><br></pre></td></tr></table></figure><p>以创建新的 git 仓库。</p><h1 id="2-检出仓库"><a class="markdownIt-Anchor" href="#2-检出仓库"></a> 2. 检出仓库</h1><p>执行如下命令以创建一个本地仓库的克隆版本：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> /path/to/repository</span><br></pre></td></tr></table></figure><p>如果是远端服务器上的仓库，你的命令会是这个样子：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">clone</span> username@host:/path/to/repository/path/to/repository</span><br></pre></td></tr></table></figure><h1 id="3-工作流"><a class="markdownIt-Anchor" href="#3-工作流"></a> 3. 工作流</h1><p>你的本地仓库由 git 维护的三棵“树”组成。第一个是你的 <strong><code>工作目录</code></strong>，它持有实际文件；第二个是 <strong><code>缓存区（Index）</code></strong>，它像个缓存区域，临时保存你的改动；最后是 <strong><code>HEAD</code></strong>，指向你最近一次提交后的结果。<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/git/git-trees.jpg" alt="Git工作流示图" /></p><h1 id="4-添加与提交"><a class="markdownIt-Anchor" href="#4-添加与提交"></a> 4. 添加与提交</h1><p>你可以计划改动（把它们添加到缓存区），使用如下命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;&lt;br&gt;</span><br><span class="line">git add *</span><br></pre></td></tr></table></figure><p>这是 git 基本工作流程的第一步；使用如下命令以实际提交改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git commit -m <span class="string">&quot;代码提交信息&quot;</span></span><br></pre></td></tr></table></figure><p>现在，你的改动已经提交到了 <strong>HEAD</strong>，但是还没到你的远端仓库。</p><h1 id="5-推送改动"><a class="markdownIt-Anchor" href="#5-推送改动"></a> 5. 推送改动</h1><p>你的改动现在已经在本地仓库的 HEAD 中了。执行如下命令以将这些改动提交到远端仓库：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin master</span><br></pre></td></tr></table></figure><p>可以把 master 换成你想要推送的任何分支。<br />如果你还没有克隆现有仓库，并欲将你的仓库连接到某个远程服务器，你可以使用如下命令添加：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git remote add origin \&lt;server&gt;</span><br></pre></td></tr></table></figure><p>如此你就能够将你的改动推送到所添加的服务器上去了。</p><h1 id="6-分支"><a class="markdownIt-Anchor" href="#6-分支"></a> 6. 分支</h1><p>分支是用来将特性开发绝缘开来的。在你创建仓库的时候，master 是“默认的”。在其他分支上进行开发，完成后再将它们合并到主分支上。<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/git/git-branches.jpg" alt="Git分支示图" /><br />创建一个叫做“feature_x”的分支，并切换过去：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -b feature_x</span><br></pre></td></tr></table></figure><p>切换回主分支：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout master</span><br></pre></td></tr></table></figure><p>再把新建的分支删掉：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git branch -d feature_x</span><br></pre></td></tr></table></figure><p>除非你将分支推送到远端仓库，不然该分支就是 不为他人所见的：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push origin &lt;branch&gt;</span><br></pre></td></tr></table></figure><h1 id="7-更新与合并"><a class="markdownIt-Anchor" href="#7-更新与合并"></a> 7. 更新与合并</h1><p>要更新你的本地仓库至最新改动，执行：<br />git pull<br />以在你的工作目录中 获取（fetch） 并 合并（merge） 远端的改动。<br />要合并其他分支到你的当前分支（例如 master），执行：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git merge &lt;branch&gt;</span><br></pre></td></tr></table></figure><p>两种情况下，git 都会尝试去自动合并改动。不幸的是，自动合并并非次次都能成功，并可能导致 冲突（conflicts）。 这时候就需要你修改这些文件来人肉合并这些 冲突（conflicts） 了。改完之后，你需要执行如下命令以将它们标记为合并成功：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>在合并改动之前，也可以使用如下命令查看：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git diff &lt;source_branch&gt; &lt;target_branch&gt;</span><br></pre></td></tr></table></figure><h1 id="8-标签"><a class="markdownIt-Anchor" href="#8-标签"></a> 8. 标签</h1><p>在软件发布时创建标签，是被推荐的。这是个旧有概念，在 SVN 中也有。可以执行如下命令以创建一个叫做 1.0.0 的标签：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git tag 1.0.0 1b2e1d63ff</span><br></pre></td></tr></table></figure><p>1b2e1d63ff 是你想要标记的提交 ID 的前 10 位字符。使用如下命令获取提交 ID：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git <span class="built_in">log</span></span><br></pre></td></tr></table></figure><p>你也可以用该提交 ID 的少一些的前几位，只要它是唯一的。</p><h1 id="9-替换本地改动"><a class="markdownIt-Anchor" href="#9-替换本地改动"></a> 9. 替换本地改动</h1><p>假如你做错事（自然，这是不可能的），你可以使用如下命令替换掉本地改动：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git checkout -- &lt;filename&gt;</span><br></pre></td></tr></table></figure><p>此命令会使用 HEAD 中的最新内容替换掉你的工作目录中的文件。已添加到缓存区的改动，以及新文件，都不受影响。<br />假如你想要丢弃你所有的本地改动与提交，可以到服务器上获取最新的版本并将你本地主分支指向到它：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git fetch origin&lt;br&gt;</span><br><span class="line">git reset --hard origin/master</span><br></pre></td></tr></table></figure><h1 id="10-有用的贴士"><a class="markdownIt-Anchor" href="#10-有用的贴士"></a> 10. 有用的贴士</h1><p>内建的图形化 git：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">gitk</span><br></pre></td></tr></table></figure><p>彩色的 git 输出：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config color.ui <span class="literal">true</span></span><br></pre></td></tr></table></figure><p>显示历史记录时，只显示一行注释信息：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git config format.pretty oneline</span><br></pre></td></tr></table></figure><p>交互地添加文件至缓存区：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git add -i</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Git </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>markdown 代码块支持的语言</title>
      <link href="/posts/3b15753a.html"/>
      <url>/posts/3b15753a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h3 id="常用代码块语言类型关键字对照"><a class="markdownIt-Anchor" href="#常用代码块语言类型关键字对照"></a> 常用代码块语言类型关键字对照</h3><p>为了让代码更好的高亮显示，给代码块添加语言识别关键字。</p><table><thead><tr><th>名称</th><th>关键字</th><th>调用的js</th><th>说明</th></tr></thead><tbody><tr><td>AppleScript</td><td>applescript</td><td>shBrushAppleScript.js</td><td>-</td></tr><tr><td>ActionScript 3.0</td><td>actionscript3 , as3</td><td>shBrushAS3.js</td><td>-</td></tr><tr><td>Shell</td><td>bash , shell</td><td>shBrushBash.js</td><td>-</td></tr><tr><td>ColdFusion</td><td>coldfusion , cf</td><td>shBrushColdFusion.js</td><td>-</td></tr><tr><td>C</td><td>cpp , c</td><td>shBrushCpp.js</td><td>-</td></tr><tr><td>C#</td><td>c# , c-sharp , csharp</td><td>shBrushCSharp.js</td><td>-</td></tr><tr><td>CSS</td><td>css</td><td>shBrushCss.js</td><td>-</td></tr><tr><td>Delphi</td><td>delphi , pascal , pas</td><td>shBrushDelphi.js</td><td>-</td></tr><tr><td>diff&amp;patch</td><td>diff patch</td><td>shBrushDiff.js</td><td>用代码版本库时,遇到代码冲突,其语法就是这个.</td></tr><tr><td>Erlang</td><td>erl , erlang</td><td>shBrushErlang.js</td><td>-</td></tr><tr><td>Groovy</td><td>groovy</td><td>shBrushGroovy.js</td><td>-</td></tr><tr><td>Java</td><td>java</td><td>shBrushJava.js</td><td>-</td></tr><tr><td>JavaFX</td><td>jfx , javafx</td><td>shBrushJavaFX.js</td><td>-</td></tr><tr><td>JavaScript</td><td>js , jscript , javascript</td><td>shBrushJScript.js</td><td>-</td></tr><tr><td>JSON</td><td>json</td><td>-</td><td>-</td></tr><tr><td>Perl</td><td>perl , pl , Perl</td><td>shBrushPerl.js</td><td>-</td></tr><tr><td>PHP</td><td>php</td><td>shBrushPhp.js</td><td>-</td></tr><tr><td>text</td><td>text , plain</td><td>shBrushPlain.js</td><td>就是普通文本.</td></tr><tr><td>Python</td><td>py , python</td><td>shBrushPython.js</td><td>-</td></tr><tr><td>Ruby</td><td>ruby , rails , ror , rb</td><td>shBrushRuby.js</td><td>-</td></tr><tr><td>SASS&amp;SCSS</td><td>sass , scss</td><td>shBrushSass.js</td><td>-</td></tr><tr><td>Scala</td><td>scala</td><td>shBrushScala.js</td><td>-</td></tr><tr><td>SQL</td><td>sql</td><td>shBrushSql.js</td><td>-</td></tr><tr><td>Visual Basic</td><td>vb , vbnet</td><td>shBrushVb.js</td><td>-</td></tr><tr><td>XML</td><td>xml , xhtml , xslt , html</td><td>shBrushXml.js</td><td>-</td></tr><tr><td>Objective C</td><td>objc , obj-c</td><td>shBrushObjectiveC.js</td><td>-</td></tr><tr><td>F#</td><td>f# f-sharp , fsharp</td><td>shBrushFSharp.js</td><td>-</td></tr><tr><td>-</td><td>xpp , dynamics-xpp</td><td>shBrushDynamics.js</td><td>-</td></tr><tr><td>R</td><td>r , s , splus</td><td>shBrushR.js</td><td>-</td></tr><tr><td>matlab</td><td>matlab</td><td>shBrushMatlab.js</td><td>-</td></tr><tr><td>swift</td><td>swift</td><td>shBrushSwift.js</td><td>-</td></tr><tr><td>GO</td><td>go , golang</td><td>shBrushGo.js</td><td>-</td></tr></tbody></table>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Markdown 入手</title>
      <link href="/posts/551d7312.html"/>
      <url>/posts/551d7312.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-markdown简介"><a class="markdownIt-Anchor" href="#1-markdown简介"></a> 1. Markdown简介</h1><p>我把Markdown归类为一种编程语言,它使我们在双手不离开键盘的情况下，可以对文本进行一定程度的格式排版。因为我觉得这种文本编辑语言设计的初衷应该就是想用编程方式规范文本的合适,你看看Github里的一些页面就知道它有多美好了吧!</p><p>但很可惜的是:由于目前还没有一个权威机构对 Markdown 的语法进行规范，各应用厂商制作时遵循的 Markdown 语法也是不尽相同的。这个消息可能会给我们带来使用上的小小的困扰，但是这仍然无法阻挡我们优美的使用它的脚步，其中比较受到认可的是 GFM 标准，它是由著名代码托管网站 GitHub 所制定的，我们可以使用这个修改编辑器的规则更加通用的使用Mardown。</p><p>Markdown 是一种轻量级标记语言，它允许人们使用易读易写的纯文本格式编写文档。</p><p>Markdown 语言在 2004 由约翰·格鲁伯（英语：John Gruber）创建。</p><p>Markdown 编写的文档可以导出 HTML 、Word、图像、PDF、Epub 等多种格式的文档。</p><p>Markdown 编写的文档后缀为 .md, .markdown。</p><h1 id="2-markdown-应用"><a class="markdownIt-Anchor" href="#2-markdown-应用"></a> 2. Markdown 应用</h1><p>Markdown 能被使用来撰写电子书，如：Gitbook。</p><p>当前许多网站都广泛使用Markdown来撰写帮助文档或是用于论坛上发表消息。例如：GitHub、简书、reddit、Diaspora、Stack Exchange、OpenStreetMap 、SourceForge等。</p><h1 id="3-markdown-标题"><a class="markdownIt-Anchor" href="#3-markdown-标题"></a> 3. Markdown 标题</h1><h2 id="用和-标记一级和二级标题"><a class="markdownIt-Anchor" href="#用和-标记一级和二级标题"></a> 用’=‘和’-'标记一级和二级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">我用&#x27;=&#x27;展示的是一级标题</span><br><span class="line">=</span><br><span class="line"></span><br><span class="line">我用&#x27;-&#x27;展示的是二级标题</span><br><span class="line">-</span><br></pre></td></tr></table></figure><h2 id="用n-标记各级标题"><a class="markdownIt-Anchor" href="#用n-标记各级标题"></a> 用’#*n '标记各级标题</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="section"># 展示的是一级标题</span></span><br><span class="line"><span class="section">## 展示的是二级标题</span></span><br><span class="line"><span class="section">### 展示的是三级标题</span></span><br><span class="line"><span class="section">#### 展示的是四级标题</span></span><br><span class="line"><span class="section">##### 展示的是五级标题</span></span><br><span class="line"><span class="section">###### 展示的是六级标题</span></span><br></pre></td></tr></table></figure><h1 id="4-markdown-段落"><a class="markdownIt-Anchor" href="#4-markdown-段落"></a> 4. Markdown 段落</h1><h2 id="分段"><a class="markdownIt-Anchor" href="#分段"></a> 分段</h2><p>Markdown 段落没有特殊的格式，直接编写文字就好，段落的换行是使用两个以上空格加上回车。当然也可以在段落后面使用一个空行来表示重新开始一个段落。</p><h2 id="字体"><a class="markdownIt-Anchor" href="#字体"></a> 字体</h2><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="emphasis">*斜体文本*</span></span><br><span class="line"><span class="emphasis">_斜体文本_</span></span><br><span class="line"><span class="strong">**粗体文本**</span></span><br><span class="line"><span class="strong">__粗体文本__</span></span><br><span class="line"><span class="strong">**<span class="emphasis">*粗斜体文本<span class="strong">**<span class="emphasis">*</span></span></span></span></span><br><span class="line"><span class="emphasis"><span class="strong"><span class="emphasis"><span class="strong"><span class="strong">__<span class="emphasis">_粗斜体文本<span class="strong">__<span class="emphasis">_</span></span></span></span></span></span></span></span></span><br></pre></td></tr></table></figure><h2 id="分隔线"><a class="markdownIt-Anchor" href="#分隔线"></a> 分隔线</h2><p>你可以在一行中用三个以上的星号、减号、底线来建立一个分隔线，行内不能有其他东西。你也可以在星号或是减号中间插入空格。下面每种写法都可以建立分隔线：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">*</span> <span class="emphasis">* *</span></span></span><br><span class="line"><span class="strong"></span></span><br><span class="line"><span class="strong">**</span><span class="strong">**<span class="emphasis">*</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">- - -</span></span></span><br><span class="line"><span class="emphasis"><span class="strong"></span></span></span><br><span class="line"><span class="emphasis"><span class="strong">----------</span></span></span><br></pre></td></tr></table></figure><h2 id="删除线"><a class="markdownIt-Anchor" href="#删除线"></a> 删除线</h2><p>如果段落上的文字要添加删除线，只需要在文字的两端加上两个波浪线 ~~ 即可，实例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">RUNOOB.COM</span><br><span class="line">GOOGLE.COM</span><br><span class="line">~~BAIDU.COM~~</span><br></pre></td></tr></table></figure><h2 id="下划线"><a class="markdownIt-Anchor" href="#下划线"></a> 下划线</h2><p>下划线可以通过 HTML 的 &lt;u&gt; 标签来实现：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">u</span>&gt;</span></span>带下划线文本<span class="xml"><span class="tag">&lt;/<span class="name">u</span>&gt;</span></span></span><br></pre></td></tr></table></figure><h2 id="脚注"><a class="markdownIt-Anchor" href="#脚注"></a> 脚注</h2><p>脚注是对文本的补充说明。需要将光标移至该文本才会触发弹出显示,普通状态并不会显示。<br />Markdown 脚注的格式如下:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[^要注明的文本]</span><br></pre></td></tr></table></figure><h1 id="5-markdown-列表"><a class="markdownIt-Anchor" href="#5-markdown-列表"></a> 5. Markdown 列表</h1><p>Markdown 支持有序列表和无序列表。<br />无序列表使用星号(<code>*</code>)、加号(<code>+</code>)或是减号(<code>-</code>)作为列表标记：</p><p>列表嵌套<br />列表嵌套只需在子列表中的选项添加四个空格即可：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">1.</span> 第一项：</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第一项嵌套的第二个元素</span><br><span class="line"><span class="bullet">2.</span> 第二项：</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第一个元素</span><br><span class="line"><span class="bullet">    -</span> 第二项嵌套的第二个元素</span><br></pre></td></tr></table></figure><p>效果:</p><ol><li>第一项：<ul><li>第一项嵌套的第一个元素</li><li>第一项嵌套的第二个元素</li></ul></li><li>第二项：<ul><li>第二项嵌套的第一个元素</li><li>第二项嵌套的第二个元素</li></ul></li></ol><h1 id="6-markdown-区块"><a class="markdownIt-Anchor" href="#6-markdown-区块"></a> 6. Markdown 区块</h1><p>Markdown 区块引用是在段落开头使用 <code>&gt;</code> 符号 ，然后后面紧跟一个<strong>空格</strong>符号：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 区块引用</span></span><br></pre></td></tr></table></figure><h2 id="嵌套"><a class="markdownIt-Anchor" href="#嵌套"></a> 嵌套</h2><p>另外区块是可以嵌套的，一个 &gt; 符号是最外层，两个 &gt; 符号是第一层嵌套，以此类推：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 最外层</span></span><br><span class="line"><span class="quote">&gt; &gt; 第一层嵌套</span></span><br><span class="line"><span class="quote">&gt; &gt; &gt; 第二层嵌套</span></span><br></pre></td></tr></table></figure><p>效果:</p><blockquote><p>最外层</p><blockquote><p>第一层嵌套</p><blockquote><p>第二层嵌套</p></blockquote></blockquote></blockquote><h2 id="区块中使用列表"><a class="markdownIt-Anchor" href="#区块中使用列表"></a> 区块中使用列表</h2><p>区块中使用列表实例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="quote">&gt; 区块中使用列表</span></span><br><span class="line"><span class="quote">&gt; 1. 第一项</span></span><br><span class="line"><span class="quote">&gt; 2. 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第一项</span></span><br><span class="line"><span class="quote">&gt; + 第二项</span></span><br><span class="line"><span class="quote">&gt; + 第三项</span></span><br></pre></td></tr></table></figure><p>效果:</p><blockquote><p>区块中使用列表</p><ol><li>第一项</li><li>第二项</li></ol><ul><li>第一项</li><li>第二项</li><li>第三项</li></ul></blockquote><h2 id="列表中使用区块"><a class="markdownIt-Anchor" href="#列表中使用区块"></a> 列表中使用区块</h2><p>如果要在列表项目内放进区块，那么就需要在 &gt; 前添加四个空格的缩进。<br />区块中使用列表实例如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="bullet">*</span> 第一项</span><br><span class="line"><span class="code">    &gt; 菜鸟教程</span></span><br><span class="line"><span class="code">    &gt; 学的不仅是技术更是梦想</span></span><br><span class="line"><span class="code">* 第二项</span></span><br></pre></td></tr></table></figure><p>效果:</p><ul><li>第一项<blockquote><p>富强、民主、文明、和谐、自由、平等<br />公正、法治、爱国、敬业、诚信、友善</p></blockquote></li><li>第二项</li></ul><h1 id="7-markdown-代码"><a class="markdownIt-Anchor" href="#7-markdown-代码"></a> 7. Markdown 代码</h1><p>如果是段落上的一个函数或片段的代码可以用反引号把它包起来（`），例如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="code">`printf()`</span> 函数</span><br></pre></td></tr></table></figure><p>效果:<br /><code>printf()</code> 函数</p><h2 id="代码区块"><a class="markdownIt-Anchor" href="#代码区块"></a> 代码区块</h2><p>代码区块使用 4 个空格或者一个制表符（Tab 键）。<br />你也可以用 ``` 包裹一段代码，并指定一种语言（也可以不指定）：</p><h1 id="8-markdown-链接"><a class="markdownIt-Anchor" href="#8-markdown-链接"></a> 8. Markdown 链接</h1><p>链接使用方法如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">链接名称</span>](<span class="link">链接地址</span>)</span><br><span class="line"></span><br><span class="line">或者</span><br><span class="line"></span><br><span class="line">&lt;链接地址&gt;</span><br></pre></td></tr></table></figure><h2 id="高级链接"><a class="markdownIt-Anchor" href="#高级链接"></a> 高级链接</h2><p>我们可以通过变量来设置一个链接，变量赋值在文档末尾进行：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [<span class="string">Google</span>][<span class="symbol">1</span>]  </span><br><span class="line">这个链接用 2 作为网址变量 [<span class="string">Creator</span>][<span class="symbol">2</span>]  </span><br><span class="line">然后在文档的结尾为变量赋值（网址）  </span><br><span class="line"></span><br><span class="line">  [1]: https://www.google.com/</span><br><span class="line">  [2]: https://elec-creator.com/</span><br></pre></td></tr></table></figure><p>效果:<br />这个链接用 1 作为网址变量 <a href="https://www.google.com/">Google</a><br />这个链接用 2 作为网址变量 <a href="https://elec-creator.com/">Creator</a><br />然后在文档的结尾为变量赋值（网址）</p><p><strong>注意</strong>:需严格按照上述格式,备注网站名称前需要两个<strong>空格</strong>,备注网站具体上方文字需要有一空行才能进行正确显示。</p><h1 id="9-markdown-图片"><a class="markdownIt-Anchor" href="#9-markdown-图片"></a> 9. Markdown 图片</h1><p>Markdown 图片语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址</span>)</span><br><span class="line"></span><br><span class="line">![<span class="string">alt 属性文本</span>](<span class="link">图片地址 &quot;可选标题&quot;</span>)</span><br></pre></td></tr></table></figure><ul><li>开头一个感叹号 !</li><li>接着一个方括号，里面放上图片的替代文字</li><li>接着一个普通括号，里面放上图片的网址，最后还可以用引号包住并加上选择性的 ‘title’ 属性的文字。</li></ul><p>当然，你也可以像网址那样对图片网址使用变量:</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">这个链接用 1 作为网址变量 [<span class="string">Creator</span>][<span class="symbol">1</span>].</span><br><span class="line">然后在文档的结尾为变量赋值（网址）</span><br><span class="line"></span><br><span class="line">  [1]: http://static.runoob.com/images/runoob-logo.png</span><br></pre></td></tr></table></figure><p>Markdown 还没有办法指定图片的高度与宽度，如果你需要的话，你可以使用HTML的普通的 &lt;img&gt; 标签。<br />&lt;img src=“<a href="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/2/thumb.jpg">http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/2/thumb.jpg</a>” width=“50%”&gt;</p><h1 id="10-markdown-图片链接"><a class="markdownIt-Anchor" href="#10-markdown-图片链接"></a> 10. Markdown 图片&amp;链接</h1><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">![alt 属性文本</span>](<span class="link">图片地址</span>)](<span class="link">链接地址</span>)</span><br></pre></td></tr></table></figure><h1 id="11-markdown-表格"><a class="markdownIt-Anchor" href="#11-markdown-表格"></a> 11. Markdown 表格</h1><p>Markdown 制作表格使用 | 来分隔不同的单元格，使用 - 来分隔表头和其他行。<br />语法格式如下：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">|  表头   | 表头  |</span><br><span class="line">|  ----  | ----  |</span><br><span class="line">| 单元格  | 单元格 |</span><br><span class="line">| 单元格  | 单元格 |</span><br></pre></td></tr></table></figure><p>效果:</p><table><thead><tr><th>表头</th><th>表头</th></tr></thead><tbody><tr><td>单元格</td><td>单元格</td></tr><tr><td>单元格</td><td>单元格</td></tr></tbody></table><h2 id="对齐方式"><a class="markdownIt-Anchor" href="#对齐方式"></a> 对齐方式</h2><p>我们可以设置表格的对齐方式：</p><ul><li>-: 设置内容和标题栏居右对齐。</li><li>:- 设置内容和标题栏居左对齐。</li><li>:-: 设置内容和标题栏居中对齐。</li></ul><p>实例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">| 左对齐 | 右对齐 | 居中对齐 |</span><br><span class="line">| :-----| ----: | :----: |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br><span class="line">| 单元格 | 单元格 | 单元格 |</span><br></pre></td></tr></table></figure><p>效果:</p><table><thead><tr><th style="text-align:left">左对齐</th><th style="text-align:right">右对齐</th><th style="text-align:center">居中对齐</th></tr></thead><tbody><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr><tr><td style="text-align:left">单元格</td><td style="text-align:right">单元格</td><td style="text-align:center">单元格</td></tr></tbody></table><h1 id="12-markdown-高级技巧"><a class="markdownIt-Anchor" href="#12-markdown-高级技巧"></a> 12. Markdown 高级技巧</h1><h2 id="支持的-html-元素"><a class="markdownIt-Anchor" href="#支持的-html-元素"></a> 支持的 HTML 元素</h2><p>不在 Markdown 涵盖范围之内的标签，都可以直接在文档里面用 HTML 撰写。<br />目前支持的 HTML 元素有：&lt;kbd&gt; &lt;b&gt; &lt;i&gt; &lt;em&gt; &lt;sup&gt; &lt;sub&gt; &lt;br&gt;等 ，如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">使用 <span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Ctrl<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Alt<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span>+<span class="xml"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span></span>Del<span class="xml"><span class="tag">&lt;/<span class="name">kbd</span>&gt;</span></span> 重启电脑</span><br></pre></td></tr></table></figure><p>效果:<br />使用 <kbd>Ctrl</kbd>+<kbd>Alt</kbd>+<kbd>Del</kbd> 重启电脑</p><h2 id="转义"><a class="markdownIt-Anchor" href="#转义"></a> 转义</h2><p>Markdown 使用了很多特殊符号来表示特定的意义，如果需要显示特定的符号则需要使用转义字符，Markdown 使用反斜杠转义特殊字符：</p><p><strong>文本加粗</strong><br />** 正常显示星号 **</p><p>Markdown 支持以下这些符号前面加上反斜杠来帮助插入普通的符号：</p><table><thead><tr><th>符号</th><th>含义</th></tr></thead><tbody><tr><td>\</td><td>反斜线</td></tr><tr><td>`</td><td>反引号</td></tr><tr><td>*</td><td>星号</td></tr><tr><td>_</td><td>下划线</td></tr><tr><td>{}</td><td>花括号</td></tr><tr><td>[]</td><td>方括号</td></tr><tr><td>()</td><td>小括号</td></tr><tr><td>#</td><td>井字号</td></tr><tr><td>+</td><td>加号</td></tr><tr><td>-</td><td>减号</td></tr><tr><td>.</td><td>英文句点</td></tr><tr><td>!</td><td>感叹号</td></tr></tbody></table><h2 id="公式"><a class="markdownIt-Anchor" href="#公式"></a> 公式</h2><p>当你需要在编辑器中插入数学公式时，可以使用两个美元符 $$ 包裹 TeX 或 LaTeX 格式的数学公式来实现。提交后，问答和文章页会根据需要加载 Mathjax 对数学公式进行渲染。如：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$$</span><br><span class="line">\mathbf&#123;V&#125;<span class="emphasis">_1 \times \mathbf&#123;V&#125;_</span>2 =  \begin&#123;vmatrix&#125; </span><br><span class="line">\mathbf&#123;i&#125; &amp; \mathbf&#123;j&#125; &amp; \mathbf&#123;k&#125; \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial u&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial u&#125; &amp; 0 \\</span><br><span class="line">\frac&#123;\partial X&#125;&#123;\partial v&#125; &amp;  \frac&#123;\partial Y&#125;&#123;\partial v&#125; &amp; 0 \\</span><br><span class="line">\end&#123;vmatrix&#125;</span><br><span class="line">$&#123;$tep1&#125;&#123;\style&#123;visibility:hidden&#125;&#123;(x+1)(x+1)&#125;&#125;</span><br><span class="line">$$</span><br></pre></td></tr></table></figure><h2 id="图表渲染"><a class="markdownIt-Anchor" href="#图表渲染"></a> 图表渲染</h2><h3 id="有道云笔记支持的图表渲染"><a class="markdownIt-Anchor" href="#有道云笔记支持的图表渲染"></a> 有道云笔记支持的图表渲染</h3><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">E = mc^2</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/youdaonote-chart-1.jpg" alt="有道云笔记图表公式渲染图-1" /></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A--&gt;B</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/youdaonote-chart-2.jpg" alt="有道云笔记图表公式渲染图-2" /></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sequenceDiagram</span><br><span class="line">A-&gt;&gt;B: How are you?</span><br><span class="line">B-&gt;&gt;A: Great!</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/youdaonote-chart-3.jpg" alt="有道云笔记图表公式渲染图-3" /></p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">gantt</span><br><span class="line">dateFormat YYYY-MM-DD</span><br><span class="line">section S1</span><br><span class="line">T1: 2014-01-01, 9d</span><br><span class="line">section S2</span><br><span class="line">T2: 2014-01-11, 9d</span><br><span class="line">section S3</span><br><span class="line">T3: 2014-01-02, 9d</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/youdaonote-chart-4.jpg" alt="有道云笔记图表公式渲染图-4" /></p><h3 id="typora支持的图表渲染"><a class="markdownIt-Anchor" href="#typora支持的图表渲染"></a> Typora支持的图表渲染</h3><p>1、横向流程图源码格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph LR</span><br><span class="line">A[方形] --&gt;B(圆角)</span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt;|a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt;|a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[横向流程图]</span></span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-1.jpg" alt="Typora图表公式渲染图-1" /></p><p>2、竖向流程图源码格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">graph TD</span><br><span class="line">A[方形] --&gt; B(圆角)</span><br><span class="line"><span class="code">    B --&gt; C&#123;条件a&#125;</span></span><br><span class="line"><span class="code">    C --&gt; |a=1| D[结果1]</span></span><br><span class="line"><span class="code">    C --&gt; |a=2| E[结果2]</span></span><br><span class="line"><span class="code">    F[竖向流程图]</span></span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-2.jpg" alt="Typora图表公式渲染图-2" /></p><p>3、标准流程图源码格式：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st-&gt;op-&gt;cond</span><br><span class="line">cond(yes)-&gt;io-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-3.jpg" alt="Typora图表公式渲染图-3" /></p><p>4、标准流程图源码格式（横向）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">st=&gt;start: 开始框</span><br><span class="line">op=&gt;operation: 处理框</span><br><span class="line">cond=&gt;condition: 判断框(是或否?)</span><br><span class="line">sub1=&gt;subroutine: 子流程</span><br><span class="line">io=&gt;inputoutput: 输入输出框</span><br><span class="line">e=&gt;end: 结束框</span><br><span class="line">st(right)-&gt;op(right)-&gt;cond</span><br><span class="line">cond(yes)-&gt;io(bottom)-&gt;e</span><br><span class="line">cond(no)-&gt;sub1(right)-&gt;op</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-4.jpg" alt="Typora图表公式渲染图-4" /></p><p>5、UML时序图源码样例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-5.jpg" alt="Typora图表公式渲染图-5" /></p><p>6、UML时序图源码复杂样例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">Title: 标题：复杂使用</span><br><span class="line">对象A-&gt;对象B: 对象B你好吗?（请求）</span><br><span class="line">Note right of 对象B: 对象B的描述</span><br><span class="line">Note left of 对象A: 对象A的描述(提示)</span><br><span class="line">对象B--&gt;对象A: 我很好(响应)</span><br><span class="line">对象B-&gt;小三: 你好吗</span><br><span class="line">小三--&gt;&gt;对象A: 对象B找我了</span><br><span class="line">对象A-&gt;对象B: 你真的好吗？</span><br><span class="line">Note over 小三,对象B: 我们是朋友</span><br><span class="line">participant C</span><br><span class="line">Note right of C: 没人陪我玩</span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-6.jpg" alt="Typora图表公式渲染图-6" /></p><p>7、UML标准时序图样例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">%% 时序图例子,-&gt; 直线，--&gt;虚线，-&gt;&gt;实线箭头</span><br><span class="line">  sequenceDiagram</span><br><span class="line"><span class="code">    participant 张三</span></span><br><span class="line"><span class="code">    participant 李四</span></span><br><span class="line"><span class="code">    张三-&gt;王五: 王五你好吗？</span></span><br><span class="line"><span class="code">    loop 健康检查</span></span><br><span class="line"><span class="code">        王五-&gt;王五: 与疾病战斗</span></span><br><span class="line"><span class="code">    end</span></span><br><span class="line"><span class="code">    Note right of 王五: 合理 食物 &lt;br/&gt;看医生...</span></span><br><span class="line"><span class="code">    李四--&gt;&gt;张三: 很好!</span></span><br><span class="line"><span class="code">    王五-&gt;李四: 你怎么样?</span></span><br><span class="line"><span class="code">    李四--&gt;王五: 很好!</span></span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-7.jpg" alt="Typora图表公式渲染图-7" /></p><p>8、甘特图样例：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">%% 语法示例</span><br><span class="line"><span class="code">    gantt</span></span><br><span class="line"><span class="code">    dateFormat  YYYY-MM-DD</span></span><br><span class="line"><span class="code">    title 软件开发甘特图</span></span><br><span class="line"><span class="code">    section 设计</span></span><br><span class="line"><span class="code">    需求                      :done,    des1, 2014-01-06,2014-01-08</span></span><br><span class="line"><span class="code">    原型                      :active,  des2, 2014-01-09, 3d</span></span><br><span class="line"><span class="code">    UI设计                     :         des3, after des2, 5d</span></span><br><span class="line"><span class="code">    未来任务                   :         des4, after des3, 5d</span></span><br><span class="line"><span class="code">    section 开发</span></span><br><span class="line"><span class="code">    学习准备理解需求                      :crit, done, 2014-01-06,24h</span></span><br><span class="line"><span class="code">    设计框架                             :crit, done, after des2, 2d</span></span><br><span class="line"><span class="code">    开发                                 :crit, active, 3d</span></span><br><span class="line"><span class="code">    未来任务                              :crit, 5d</span></span><br><span class="line"><span class="code">    耍                                   :2d</span></span><br><span class="line"><span class="code">    section 测试</span></span><br><span class="line"><span class="code">    功能测试                              :active, a1, after des3, 3d</span></span><br><span class="line"><span class="code">    压力测试                               :after a1  , 20h</span></span><br><span class="line"><span class="code">    测试报告                               : 48h</span></span><br></pre></td></tr></table></figure><p>效果:<br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/programming-language/markdown/Markedown-%E5%85%A5%E6%89%8B/typora-chart-8.jpg" alt="Typora图表公式渲染图-8" /></p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Markdown </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Markdown </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML 入手</title>
      <link href="/posts/51dfec46.html"/>
      <url>/posts/51dfec46.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-html-简介"><a class="markdownIt-Anchor" href="#1-html-简介"></a> 1. HTML 简介</h1><p>超文本标记语言（英语：HyperText Markup Language，简称：HTML）是一种用于创建网页的标准标记语言。<br />您可以使用 HTML 来建立自己的 WEB 站点，HTML 运行在浏览器上，由浏览器来解析。<br />HTML 是用来描述网页的一种语言：</p><ul><li>HTML 指的是超文本标记语言: HyperText Markup Language</li><li>HTML 不是一种编程语言，而是一种标记语言</li><li>标记语言是一套标记标签 (markup tag)</li><li>HTML 使用标记标签来描述网页</li><li>HTML 文档包含了HTML 标签及文本内容</li><li>HTML文档也叫做 web 页面</li></ul><h2 id="html文档的后缀名"><a class="markdownIt-Anchor" href="#html文档的后缀名"></a> HTML文档的后缀名</h2><ul><li>.html</li><li>.htm</li></ul><h2 id="神器安利"><a class="markdownIt-Anchor" href="#神器安利"></a> 神器安利</h2><p><strong>贴上几个特别实用的几个链接帮助快速入门使用HTML:</strong></p><ul><li><strong><a href="https://www.runoob.com/html/html-examples.html">在线实例</a></strong>：包含了数百个在线实例，我们可以在线编辑并查看运行结果。</li><li><strong><a href="https://www.runoob.com/tags/html-reference.html">HTML 参考手册</a></strong>：完整的 HTML 参考手册，其中包括标签、属性、颜色、实体等等。</li><li><strong><a href="https://c.runoob.com/front-end/61">HTML/CSS/JS 在线工具</a></strong>：可以在线编辑 HTML、CSS、JS 代码，并实时查看效果，你也可以将优质代码保存分享<br />我觉得<a href="https://www.runoob.com/">菜鸟</a>全网最有效率的快速入门一门语言的神器，不接受反驳，为菜鸟打扣！！！</li></ul><h2 id="html文件构成"><a class="markdownIt-Anchor" href="#html文件构成"></a> HTML文件构成</h2><p>最简单的HTML页面有这样的结构构成：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>测试页面(elec-creaotr.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>其中：</p><ul><li>&lt;!DOCTYPE html&gt; --&gt; 声明为 HTML5 文档</li><li>&lt;html&gt;          --&gt; 元素是 HTML 页面的根元素</li><li>&lt;head&gt;          --&gt; 元素包含了文档的元（meta）数据，如 <meta charset="utf-8"> 定义网页编码格式为 utf-8。</li><li>&lt;title&gt;         --&gt; 元素描述了文档的标题</li><li>&lt;body&gt;          --&gt; 元素包含了可见的页面内容</li><li>&lt;h1&gt;            --&gt; 元素定义一个大标题</li><li>&lt;p&gt;             --&gt; 元素定义一个段落</li></ul><h2 id="web-浏览器和html网页架构"><a class="markdownIt-Anchor" href="#web-浏览器和html网页架构"></a> Web 浏览器和HTML网页架构</h2><p>Web浏览器（如谷歌浏览器，Internet Explorer，Firefox，Safari）是用于读取HTML文件，并将其作为网页显示。<br />浏览器并不是直接显示的HTML标签，但可以使用标签来决定如何展现HTML页面的内容给用户。一个可视化的HTML页面结构一般如下：</p><div style="width:99%;border:1px solid grey;padding:3px;margin:0;background-color:#ddd">&lt;html&gt;<div style="width:90%;border:1px solid grey;padding:3px;margin:20px">&lt;head&gt;<div style="width:90%;border:1px solid grey;padding:5px;margin:20px">&lt;title&gt;页面标题&lt;/title&gt;</div>&lt;/head&gt;</div><div style="width:90%;border:1px solid grey;padding:3px;margin:20px;background-color:#fff">&lt;body&gt;<div style="width:90%;border:1px solid grey;padding:5px;margin:20px">&lt;h1&gt;这是一个标题&lt;/h1&gt;</div><div style="width:90%;border:1px solid grey;padding:5px;margin:20px">&lt;p&gt;这是一个段落。&lt;/p&gt;</div><div style="width:90%;border:1px solid grey;padding:5px;margin:20px">&lt;p&gt;这是另外一个段落。&lt;/p&gt;</div>&lt;/body&gt;</div>&lt;/html&gt;</div><p><strong>只有 <body> 区域 (白色部分) 才会在浏览器中显示。</strong></p><h2 id="doctype-声明"><a class="markdownIt-Anchor" href="#doctype-声明"></a> &lt;!DOCTYPE&gt; 声明</h2><!DOCTYPE>声明有助于浏览器中正确显示网页。<p>网络上有很多不同的文件，如果能够正确声明HTML的版本，浏览器就能正确显示网页内容。</p><p>doctype 声明是不区分大小写的，以下方式均可：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!doctype <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&lt;!Doctype <span class="meta-keyword">Html</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通用声明"><a class="markdownIt-Anchor" href="#通用声明"></a> 通用声明</h3><h4 id="html5"><a class="markdownIt-Anchor" href="#html5"></a> HTML5</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="html-401"><a class="markdownIt-Anchor" href="#html-401"></a> HTML 4.01</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">HTML</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD HTML 4.01 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/html4/loose.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="xhtml-10"><a class="markdownIt-Anchor" href="#xhtml-10"></a> XHTML 1.0</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>查看更多完整网页声明类型参考菜鸟网 <a href="https://www.runoob.com/tags/tag-doctype.html">DOCTYPE 参考手册</a>。</p><h2 id="中文编码"><a class="markdownIt-Anchor" href="#中文编码"></a> 中文编码</h2><p>目前在大部分浏览器中，直接输出中文会出现中文乱码的情况，这时候我们就需要在头部将字符声明为 UTF-8 或 GBK。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;UTF-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>页面标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>我的第一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>我的第一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="2-html基础部分"><a class="markdownIt-Anchor" href="#2-html基础部分"></a> 2. HTML基础部分</h1><h2 id="html-标签"><a class="markdownIt-Anchor" href="#html-标签"></a> HTML 标签</h2><p>HTML 标记标签通常被称为 HTML 标签 (HTML tag):</p><ul><li>HTML 标签是由尖括号包围的关键词，比如 <html></li><li>HTML 标签通常是成对出现的，比如 &lt;b&gt; 和 &lt;/b&gt;</li><li>标签对中的第一个标签是开始标签，第二个带斜杠的标签是结束标签</li><li>开始和结束标签也被称为开放标签和闭合标签</li></ul><p><strong>&lt;标签&gt;内容&lt;/标签&gt;</strong></p><h2 id="html-元素"><a class="markdownIt-Anchor" href="#html-元素"></a> HTML 元素</h2><p>HTML 文档由嵌套的 HTML 元素构成。“HTML 标签” 和 “HTML 元素” 通常都是描述同样的意思:<br />但是严格来讲, 一个 HTML 元素包含了开始标签与结束标签，如下实例:<br />HTML 元素:</p><p><strong>&lt;p&gt;这是一个段落。&lt;/p&gt;</strong></p><table><thead><tr><th>常用标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;html&gt;</td><td>定义 HTML 文档</td></tr><tr><td>&lt;body&gt;</td><td>定义文档的主体</td></tr><tr><td>&lt;h1&gt; - &lt;h6&gt;</td><td>定义 HTML 标题</td></tr><tr><td>&lt;hr&gt;</td><td>定义水平线</td></tr><tr><td>&lt;!–…--&gt;</td><td>定义注释</td></tr></tbody></table><h3 id="html-元素语法"><a class="markdownIt-Anchor" href="#html-元素语法"></a> HTML 元素语法</h3><p>HTML 元素以开始标签起始<br />HTML 元素以结束标签终止<br />元素的内容是开始标签与结束标签之间的内容<br />某些 HTML 元素具有空内容（empty content）<br />空元素在开始标签中进行关闭（以开始标签的结束而结束）<br />大多数 HTML 元素可拥有属性</p><ul><li><p> 元素:</li><li><body> 元素:</li><li><html> 元素：</li></ul><h3 id="html-空元素"><a class="markdownIt-Anchor" href="#html-空元素"></a> HTML 空元素</h3><p>没有内容的 HTML 元素被称为空元素。空元素是在开始标签中关闭的。<br />&lt;br&gt; 就是没有关闭标签的空元素（&lt;br&gt; 标签定义换行）。<br />在 XHTML、XML 以及未来版本的 HTML 中，所有元素都必须被关闭。<br />在开始标签中添加斜杠，比如 &lt;br /&gt;，是关闭空元素的正确方法，HTML、XHTML 和 XML 都接受这种方式。<br /><strong>即使 &lt;br&gt; 在所有浏览器中都是有效的，但使用 &lt;br /&gt; 其实是更长远的保障。</strong></p><h3 id="html-提示使用小写标签"><a class="markdownIt-Anchor" href="#html-提示使用小写标签"></a> HTML 提示：使用小写标签</h3><p>HTML 标签对大小写不敏感：&lt;P&gt; 等同于 &lt;p&gt;。许多网站都使用大写的 HTML 标签。<br />一般使用的是小写标签，因为万维网联盟（W3C）在 HTML 4 中推荐使用小写，而在未来 (X)HTML 版本中强制使用小写。</p><h2 id="html-属性"><a class="markdownIt-Anchor" href="#html-属性"></a> HTML 属性</h2><p>属性是 HTML 元素提供的附加信息。</p><h3 id="html-属性-2"><a class="markdownIt-Anchor" href="#html-属性-2"></a> HTML 属性</h3><p>HTML 元素可以设置属性<br />属性可以在元素中添加附加信息<br />属性一般描述于开始标签<br />属性总是以 <strong>名称/值</strong> 对的形式出现，比如：name=“value”。</p><h3 id="属性实例"><a class="markdownIt-Anchor" href="#属性实例"></a> 属性实例</h3><p>HTML 链接由 <a> 标签定义。链接的地址在 href 属性中指定：<br />&lt;a href=“http://elec-creator.com”&gt;这是一个链接</a><br />效果:<br /><a href="http://elec-creator.com">这是一个链接</a></p><h3 id="html-属性常用引用属性值"><a class="markdownIt-Anchor" href="#html-属性常用引用属性值"></a> HTML 属性常用引用属性值</h3><p>属性值应该始终被包括在引号内。</p><p>双引号是最常用的，不过使用单引号也没有问题。</p><p>Remark提示: 在某些个别的情况下，比如属性值本身就含有双引号，那么您必须使用单引号，例如：name=‘John “ShotGun” Nelson’</p><h3 id="html-提示使用小写属性"><a class="markdownIt-Anchor" href="#html-提示使用小写属性"></a> HTML 提示：使用小写属性</h3><p>属性和属性值对大小写不敏感。<br />不过，万维网联盟在其 HTML 4 推荐标准中推荐小写的属性/属性值。<br />而新版本的 (X)HTML 要求使用小写属性。</p><h3 id="html-属性参考手册"><a class="markdownIt-Anchor" href="#html-属性参考手册"></a> HTML 属性参考手册</h3><p>查看完整的HTML属性列表: HTML 标签参考手册。<br />下面列出了适用于大多数 HTML 元素的属性：</p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>class</td><td>为html元素定义一个或多个类名（classname）(类名从样式文件引入)</td></tr><tr><td>id</td><td>定义元素的唯一id</td></tr><tr><td>style</td><td>规定元素的行内样式（inline style）</td></tr><tr><td>title</td><td>描述了元素的额外信息 (作为工具条使用)</td></tr></tbody></table><p>更多标准属性说明请参阅菜鸟网的 <a href="https://www.runoob.com/tags/ref-standardattributes.html">HTML标准属性参考手册</a>.</p><h2 id="html标题"><a class="markdownIt-Anchor" href="#html标题"></a> HTML标题</h2><p>HTML 标题（Heading）是通过&lt;h1&gt; - &lt;h6&gt; 标签来定义的.</p><ul><li>&lt;h1&gt;这是一个标题&lt;/h1&gt;</li><li>.</li><li>.</li><li>.</li><li>&lt;h6&gt;这是一个标题&lt;/h6&gt;</li></ul><p>浏览器会自动地在标题的前后添加空行。</p><h2 id="html-水平线"><a class="markdownIt-Anchor" href="#html-水平线"></a> HTML 水平线</h2><p>&lt;hr&gt; 标签在 HTML 页面中创建水平线。<br />hr 元素可用于分隔内容。</p><h2 id="html-注释"><a class="markdownIt-Anchor" href="#html-注释"></a> HTML 注释</h2><p>可以将注释插入 HTML 代码中，这样可以提高其可读性，使代码更易被人理解。浏览器会忽略注释，也不会显示它们。</p><p>注释写法如下:<br />&lt;!-- 这是一个注释 --&gt;</p><h2 id="html-段落"><a class="markdownIt-Anchor" href="#html-段落"></a> HTML 段落</h2><p>HTML 段落是通过标签 &lt;p&gt; 和 &lt;/p&gt;来定义的.</p><p>&lt;p&gt;这是一个段落。&lt;/p&gt;<br />&lt;p&gt;这是另外一个段落。&lt;/p&gt;</p><h3 id="html-折行"><a class="markdownIt-Anchor" href="#html-折行"></a> HTML 折行</h3><p>需要注意的是，HTML 代码中的所有连续的空行（换行）也被显示为一个空格。<br />如果您希望在不产生一个新段落的情况下进行换行（新行），请使用 <br> 标签：<br />&lt;p&gt;这个&lt;br&gt;段落&lt;br&gt;演示了分行的效果&lt;/p&gt;<br />效果:<br />&lt;p&gt;这个&lt;br&gt;段落&lt;br&gt;演示了分行的效果&lt;/p&gt;</p><p><ins>&lt;br /&gt; 元素是一个空的 HTML 元素。由于关闭标签没有任何意义，因此它没有结束标签。</ins></p><h4 id="区分记录"><a class="markdownIt-Anchor" href="#区分记录"></a> 区分记录:</h4><p>&lt;br&gt;, &lt;br/&gt; 以及 &lt;br /&gt;（带有空格）<br />&lt;br&gt; 是 HTML 写法。<br />是 XHTML1.1 的写法, 也是 XML 写法。&lt;br/&gt; 是 XHTML 为兼容 HTML 的写法,也是 XML 写法。HTML5 因为兼容 XHTML，所以三种写法都可以使用。<br />早期发布的 HTML 规范当中，&lt;br&gt; 与 &lt;img&gt; 等元素是不用封闭自身的，但是这种元素造成了 HTML 规范的不严谨，于是在之后发布的 XHTML 语言中，参考了更为严谨的 XML 规范，在这些不用自身封闭的元素后加 / 来表示自行封闭，在逻辑上来讲等同于&lt;br&gt;…&lt;/br&gt;（但是没有 &lt;/br&gt; 这种写法），这样一来保证了较少的代码量，二来保证了规范的严谨。</p><h2 id="html-文本格式化"><a class="markdownIt-Anchor" href="#html-文本格式化"></a> HTML 文本格式化</h2><h3 id="html-格式化标签"><a class="markdownIt-Anchor" href="#html-格式化标签"></a> HTML 格式化标签</h3><p>HTML 使用标签 &lt;b&gt;(“bold”) 与 &lt;i&gt;(“italic”) 对输出的文本进行格式, 如：粗体 or 斜体<br />这些HTML标签被称为格式化标签。</p><h4 id="区分"><a class="markdownIt-Anchor" href="#区分"></a> 区分</h4><p>通常标签 &lt;strong&gt; 替换加粗标签 &lt;b&gt; 来使用, &lt;em&gt; 替换 &lt;i&gt;标签使用。<br />然而，这些标签的含义是不同的：<br />&lt;b&gt; 与&lt;i&gt; 定义粗体或斜体文本。<br />&lt;strong&gt; 或者 &lt;em&gt;意味着你要呈现的文本是重要的，所以要突出显示。现今所有主要浏览器都能渲染各种效果的字体。不过，未来浏览器可能会支持更好的渲染效果。</p><h3 id="html-文本格式化标签"><a class="markdownIt-Anchor" href="#html-文本格式化标签"></a> HTML 文本格式化标签</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;b&gt;</td><td>定义粗体文本</td></tr><tr><td>&lt;em&gt;</td><td>定义着重文字</td></tr><tr><td>&lt;i&gt;</td><td>定义斜体字</td></tr><tr><td>&lt;small&gt;</td><td>定义小号字</td></tr><tr><td>&lt;strong&gt;</td><td>定义加重语气</td></tr><tr><td>&lt;sub&gt;</td><td>定义下标字</td></tr><tr><td>&lt;sup&gt;</td><td>定义上标字</td></tr><tr><td>&lt;ins&gt;</td><td>定义插入字</td></tr><tr><td>&lt;del&gt;</td><td>定义删除字</td></tr></tbody></table><h3 id="html-计算机输出-标签"><a class="markdownIt-Anchor" href="#html-计算机输出-标签"></a> HTML “计算机输出” 标签</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;code&gt;</td><td>定义计算机代码</td></tr><tr><td>&lt;kbd&gt;</td><td>定义键盘码</td></tr><tr><td>&lt;samp&gt;</td><td>定义计算机代码样本</td></tr><tr><td>&lt;var&gt;</td><td>定义变量</td></tr><tr><td>&lt;pre&gt;</td><td>定义预格式文本</td></tr></tbody></table><h3 id="html-引文-引用-及标签定义"><a class="markdownIt-Anchor" href="#html-引文-引用-及标签定义"></a> HTML 引文, 引用, 及标签定义</h3><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;abbr&gt;</td><td>定义缩写</td></tr><tr><td>&lt;address&gt;</td><td>定义地址</td></tr><tr><td>&lt;bdo&gt;</td><td>定义文字方向</td></tr><tr><td>&lt;blockquote&gt;</td><td>定义长的引用</td></tr><tr><td>&lt;q&gt;</td><td>定义短的引用语</td></tr><tr><td>&lt;cite&gt;</td><td>定义引用、引证</td></tr><tr><td>&lt;dfn&gt;</td><td>定义一个定义项目。</td></tr></tbody></table><h1 id="3-html-链接"><a class="markdownIt-Anchor" href="#3-html-链接"></a> 3. HTML 链接</h1><p>HTML 链接是通过标签 &lt;a&gt; 来定义的.</p><p>&lt;a href=“<a href="https://elec-creator.com">https://elec-creator.com</a>”&gt;这是一个链接&lt;/a&gt;<br />在 href 属性中指定链接的地址。</p><h2 id="html-超链接链接"><a class="markdownIt-Anchor" href="#html-超链接链接"></a> HTML 超链接（链接）</h2><p>HTML使用标签 &lt;a&gt;来设置超文本链接。<br />超链接可以是一个字，一个词，或者一组词，也可以是一幅图像，您可以点击这些内容来跳转到新的文档或者当前文档中的某个部分。<br />当您把鼠标指针移动到网页中的某个链接上时，箭头会变为一只小手。<br />在标签&lt;a&gt; 中使用了href属性来描述链接的地址。<br />默认情况下，链接将以以下形式出现在浏览器中：</p><ul><li>一个未访问过的链接显示为蓝色字体并带有下划线。</li><li>访问过的链接显示为紫色并带有下划线。</li><li>点击链接时，链接显示为红色并带有下划线。<br />注意：如果为这些超链接设置了 CSS 样式，展示样式会根据 CSS 的设定而显示。</li></ul><h3 id="html-链接语法"><a class="markdownIt-Anchor" href="#html-链接语法"></a> HTML 链接语法</h3><p>链接的 HTML 代码很简单。它类似这样：<br />&lt;a href=“url”&gt;链接文本&lt;/a&gt;<br />href 属性描述了链接的目标。<br />“链接文本” 不必一定是文本。图片或其他 HTML 元素都可以成为链接。</p><h4 id="html-链接-id-属性"><a class="markdownIt-Anchor" href="#html-链接-id-属性"></a> HTML 链接- id 属性</h4><p>id属性可用于创建在一个HTML文档书签标记。<br /><strong>提示:</strong> 书签是不以任何特殊的方式显示，在HTML文档中是不显示的，所以对于读者来说是隐藏的。<br />在HTML文档中插入ID:<br />&lt;a id=“tips”&gt;有用的提示部分</a><br />在HTML文档中创建一个链接到&quot;有用的提示部分(id=“tips”）&quot;：<br />&lt;a href=&quot;#tips&quot;&gt;访问有用的提示部分</a><br />或者，从另一个页面创建一个链接到&quot;有用的提示部分(id=“tips”）&quot;：<br />&lt;a href=“https://elec-creator.com#tips”&gt;<br />访问有用的提示部分</a></p><h3 id="基本的注意事项-有用的提示"><a class="markdownIt-Anchor" href="#基本的注意事项-有用的提示"></a> 基本的注意事项 - 有用的提示</h3><p>注释： 请始终将正斜杠添加到子文件夹。假如这样书写链接：href=“https:elec-creator.com”，就会向服务器产生两次 HTTP 请求。这是因为服务器会添加正斜杠到这个地址，然后创建一个新的请求，就像这样：href=“<a href="https://elec-creator.com/">https://elec-creator.com/</a>”。</p><h1 id="4-html-头部"><a class="markdownIt-Anchor" href="#4-html-头部"></a> 4. HTML 头部</h1><h2 id="html-head-元素"><a class="markdownIt-Anchor" href="#html-head-元素"></a> HTML &lt;head&gt; 元素</h2><p>&lt;head&gt; 元素包含了所有的头部标签元素。在 &lt;head&gt;元素中你可以插入脚本（scripts）, 样式文件（CSS），及各种meta信息。<br />可以添加在头部区域的元素标签为: &lt;title&gt;, &lt;style&gt;, &lt;meta&gt;, &lt;link&gt;, &lt;script&gt;, &lt;noscript&gt;, and &lt;base&gt;.</p><h3 id="区分head-标签和-header-标签的不同"><a class="markdownIt-Anchor" href="#区分head-标签和-header-标签的不同"></a> 区分head 标签和 header 标签的不同</h3><p>head 标签用于定义文档头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等等。</p><p>如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">     <span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>header 标签用于定义文档的页眉（介绍信息）。<br />如：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">header</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">h1</span>&gt;</span>一级标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">header</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>注意千万不要弄混。</p><h2 id="html-title-元素"><a class="markdownIt-Anchor" href="#html-title-元素"></a> HTML &lt;title&gt; 元素</h2><p>&lt;title&gt; 标签定义了不同文档的标题。<br />&lt;title&gt; 在 HTML/XHTML 文档中是必须的。<br />&lt;title&gt; 元素:<br />定义了浏览器工具栏的标题<br />当网页添加到收藏夹时，显示在收藏夹中的标题<br />显示在搜索引擎结果页面的标题<br />一个简单的 HTML 文档:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">文档内容......</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-base-元素"><a class="markdownIt-Anchor" href="#html-base-元素"></a> HTML &lt;base&gt; 元素</h2><base> 标签描述了基本的链接地址/链接目标，该标签作为HTML文档中所有的链接标签的默认链接:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">base</span> <span class="attr">href</span>=<span class="string">&quot;http://elec-creator.com/img/&quot;</span> <span class="attr">target</span>=<span class="string">&quot;_blank&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-link-元素"><a class="markdownIt-Anchor" href="#html-link-元素"></a> HTML &lt;link&gt; 元素</h2><link> 标签定义了文档与外部资源之间的关系。  <link> 标签通常用于链接到样式表:  <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-style-元素"><a class="markdownIt-Anchor" href="#html-style-元素"></a> HTML &lt;style&gt; 元素</h2><p>&lt;style&gt; 标签定义了HTML文档的样式文件引用地址.<br />在&lt;style&gt; 元素中你也可以直接添加样式来渲染 HTML 文档:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css">  </span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow&#125;  </span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue&#125;  </span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span>  </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-meta-元素"><a class="markdownIt-Anchor" href="#html-meta-元素"></a> HTML &lt;meta&gt; 元素</h2><p>meta标签描述了一些基本的元数据。<br />&lt;meta&gt; 标签提供了元数据.元数据也不显示在页面上，但会被浏览器解析。<br />META 元素通常用于指定网页的描述，关键词，文件的最后修改时间，作者，和其他元数据。<br />元数据可以使用于浏览器（如何显示内容或重新加载页面），搜索引擎（关键词），或其他Web服务。<br />&lt;meta&gt; 一般放置于 &lt;head&gt; 区域</p><h3 id="meta-标签-使用实例"><a class="markdownIt-Anchor" href="#meta-标签-使用实例"></a> &lt;meta&gt; 标签- 使用实例</h3><p>为搜索引擎定义关键词:<br />&lt;meta name=“keywords” content=“HTML, CSS, XML, XHTML, JavaScript”&gt;</p><p>为网页定义描述内容:<br />&lt;meta name=“description” content=“免费 Web &amp; 编程 教程”&gt;</p><p>定义网页作者:<br />&lt;meta name=“author” content=“Malloy”&gt;</p><p>每30秒钟刷新当前页面:<br />&lt;meta http-equiv=“refresh” content=“30”&gt;</p><h2 id="html-script-元素"><a class="markdownIt-Anchor" href="#html-script-元素"></a> HTML &lt;script&gt; 元素</h2><p>&lt;script&gt;标签用于加载脚本文件，如： JavaScript。<br />&lt;script&gt; 元素在以后的章节中会详细描述。</p><h2 id="html-head-元素-2"><a class="markdownIt-Anchor" href="#html-head-元素-2"></a> HTML head 元素</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;head&gt;</td><td>定义了文档的信息</td></tr><tr><td>&lt;title&gt;</td><td>定义了文档的标题</td></tr><tr><td>&lt;base&gt;</td><td>定义了页面链接标签的默认链接地址</td></tr><tr><td>&lt;link&gt;</td><td>定义了一个文档和外部资源之间的关系</td></tr><tr><td>&lt;meta&gt;</td><td>定义了HTML文档中的元数据</td></tr><tr><td>&lt;script&gt;</td><td>定义了客户端的脚本文件</td></tr><tr><td>&lt;style&gt;</td><td>定义了HTML文档的样式文件</td></tr></tbody></table><h1 id="5-html-css"><a class="markdownIt-Anchor" href="#5-html-css"></a> 5. HTML CSS</h1><p>CSS (Cascading Style Sheets) 用于渲染HTML元素标签的样式。<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>茂林的个人站(elec-creator.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;opacity:0.5;position:absolute;left:50px;width:300px;height:150px;background-color:#40B3DF&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;font-family:verdana;padding:20px;border-radius:10px;border:10px solid #EE872A;&quot;</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;opacity:0.3;position:absolute;left:120px;width:100px;height:200px;background-color:#8AC007&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span>Look! Styles and colors<span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;letter-spacing:12px;&quot;</span>&gt;</span>Manipulate Text<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:#40B3DF;&quot;</span>&gt;</span>Colors</span><br><span class="line"><span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#B4009E;color:#ffffff;&quot;</span>&gt;</span>Boxes<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">&quot;color:#000000;&quot;</span>&gt;</span>and more...<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="如何使用css"><a class="markdownIt-Anchor" href="#如何使用css"></a> 如何使用CSS</h2><p>CSS 是在 HTML 4 开始使用的,是为了更好的渲染HTML元素而引入的.</p><p>CSS 可以通过以下方式添加到HTML中:</p><ul><li>内联样式- 在HTML元素中使用&quot;style&quot; 属性</li><li>内部样式表 -在HTML文档头部 &lt;head&gt; 区域使用 &lt;style&gt; 元素 来包含CSS</li><li>外部引用 - 使用外部 CSS 文件</li></ul><p>最好的方式是通过外部引用CSS文件.<br />在本站的HTML教程中我们使用了内联CSS样式来介绍实例，这是为了简化的例子，也使得你能更容易在线编辑代码并在线运行实例。<br />你可以通过本站的 CSS 教程 学习更多的 CSS 知识。</p><h2 id="内联样式"><a class="markdownIt-Anchor" href="#内联样式"></a> 内联样式</h2><p>当特殊的样式需要应用到个别元素时，就可以使用内联样式。 使用内联样式的方法是在相关的标签中使用样式属性。样式属性可以包含任何 CSS 属性。以下实例显示出如何改变段落的颜色和左外边距。</p><p>&lt;p style=“color:blue;margin-left:20px;”&gt;这是一个段落。&lt;/p&gt;<br />学习更多样式，请访问 <a href="https://www.runoob.com/css/">CSS 教程</a>.</p><h3 id="css修饰标签的样式有-内联-和-外引-两种方式"><a class="markdownIt-Anchor" href="#css修饰标签的样式有-内联-和-外引-两种方式"></a> CSS修饰标签的样式，有 “内联” 和 “外引” 两种方式。</h3><p>对于大部分标签，以上两种方法均可，且修改父级标签，子级标签特性也会改变。但某些标签确无法通过修改父级标签来改变子级标签特性，如a标签，修改其颜色特性，必须直接修改 a 标签的特性才可。<br />实例：<br />&lt;a href=&quot;#&quot; style=“color:red;” rel=“nofollow”&gt;只能使用&quot;内联&quot;方式&lt;/a&gt;</p><h2 id="html样式实例-背景颜色"><a class="markdownIt-Anchor" href="#html样式实例-背景颜色"></a> HTML样式实例 - 背景颜色</h2><p>背景色属性（background-color）定义一个元素的背景颜色：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">style</span>=<span class="string">&quot;background-color:yellow;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span> <span class="attr">style</span>=<span class="string">&quot;background-color:red;&quot;</span>&gt;</span>这是一个标题<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;background-color:green;&quot;</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>早期背景色属性（background-color）是使用 bgcolor 属性定义。</p><p>旧版HTML来设置背景方式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>茂林的个人站(elec-creator.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span> <span class="attr">bgcolor</span>=<span class="string">&quot;yellow&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>This is a heading<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>This is a paragraph.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>The old bgcolor attribute only works on the body element.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>For future proof HTML, use styles instead:<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-样式实例-字体-字体颜色-字体大小"><a class="markdownIt-Anchor" href="#html-样式实例-字体-字体颜色-字体大小"></a> HTML 样式实例 - 字体, 字体颜色 ，字体大小</h2><p>我们可以使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义字体的样式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;font-family:verdana;&quot;</span>&gt;</span>一个标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span> <span class="attr">style</span>=<span class="string">&quot;font-family:arial;color:red;font-size:20px;&quot;</span>&gt;</span>一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在通常使用font-family（字体），color（颜色），和font-size（字体大小）属性来定义文本样式，而不是使用<font>标签。</p><h2 id="html-样式实例-文本对齐方式"><a class="markdownIt-Anchor" href="#html-样式实例-文本对齐方式"></a> HTML 样式实例 - 文本对齐方式</h2><p>使用 text-align（文字对齐）属性指定文本的水平与垂直对齐方式：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;text-align:center;&quot;</span>&gt;</span>居中对齐的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><p>文本对齐属性 text-align取代了旧标签 &lt;center&gt; 。</p><h2 id="内部样式表"><a class="markdownIt-Anchor" href="#内部样式表"></a> 内部样式表</h2><p>当单个文件需要特别样式时，就可以使用内部样式表。你可以在 &lt;head&gt; 部分通过 &lt;style&gt;标签定义内部样式表:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">body</span> &#123;<span class="attribute">background-color</span>:yellow;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="外部样式表"><a class="markdownIt-Anchor" href="#外部样式表"></a> 外部样式表</h2><p>当样式需要被应用到很多页面的时候，外部样式表将是理想的选择。使用外部样式表，你就可以通过更改一个文件来改变整个站点的外观。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">&quot;stylesheet&quot;</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mystyle.css&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-样式标签"><a class="markdownIt-Anchor" href="#html-样式标签"></a> HTML 样式标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;style&gt;</td><td>定义文本样式</td></tr><tr><td>&lt;link&gt;</td><td>定义资源引用地址</td></tr></tbody></table><h2 id="已弃用的标签和属性"><a class="markdownIt-Anchor" href="#已弃用的标签和属性"></a> 已弃用的标签和属性</h2><p>在HTML 4, 原来支持定义HTML元素样式的标签和属性已被弃用。这些标签将不支持新版本的HTML标签。<br />不建议使用的标签有: &lt;font&gt;, &lt;center&gt;, &lt;strike&gt;<br />不建议使用的属性: color 和 bgcolor.</p><h1 id="6-html-图像"><a class="markdownIt-Anchor" href="#6-html-图像"></a> 6. HTML 图像</h1><p>HTML 图像是通过标签 &lt;img&gt; 来定义的.<br />&lt;img src=“<a href="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/2/thumb.jpg">http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/2/thumb.jpg</a>” width=“1080” height=“720” /&gt;<br />效果:<br /><img src="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/2/thumb.jpg" width="1080" height="720" /></p><h2 id="html-图像-图像标签img和源属性src"><a class="markdownIt-Anchor" href="#html-图像-图像标签img和源属性src"></a> HTML 图像- 图像标签（&lt;img&gt;）和源属性（Src）</h2><p>在 HTML 中，图像由 &lt;img&gt; 标签定义。<br />&lt;img&gt; 是空标签，意思是说，它只包含属性，并且没有闭合标签。<br />要在页面上显示图像，你需要使用源属性（src）。src 指 “source”。源属性的值是图像的 URL 地址。<br />定义图像的语法是：<br />&lt;img src=“url” alt=“some_text”&gt;<br />URL 指存储图像的位置。如果名为 “thumb.jpg” 的图像位于 <a href="http://ppe.oss-cn-shenzhen.aliyuncs.com">ppe.oss-cn-shenzhen.aliyuncs.com</a> 的 collections/182/2/ 目录中，那么其 URL 为 <a href="http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/2/thumb.jpg%E3%80%82">http://ppe.oss-cn-shenzhen.aliyuncs.com/collections/182/2/thumb.jpg。</a><br />浏览器将图像显示在文档中图像标签出现的地方。如果你将图像标签置于两个段落之间，那么浏览器会首先显示第一个段落，然后显示图片，最后显示第二段。</p><h2 id="html-图像-alt属性"><a class="markdownIt-Anchor" href="#html-图像-alt属性"></a> HTML 图像- Alt属性</h2><p>alt 属性用来为图像定义一串预备的可替换的文本。<br />替换文本属性的值是用户定义的。<br />&lt;img src=“boat.gif” alt=“Big Boat”&gt;<br />在浏览器无法载入图像时，替换文本属性告诉读者她们失去的信息。此时，浏览器将显示这个替代性的文本而不是图像。为页面上的图像都加上替换文本属性是个好习惯，这样有助于更好的显示信息，并且对于那些使用纯文本浏览器的人来说是非常有用的。</p><h2 id="html-图像-设置图像的高度与宽度"><a class="markdownIt-Anchor" href="#html-图像-设置图像的高度与宽度"></a> HTML 图像- 设置图像的高度与宽度</h2><p>height（高度） 与 width（宽度）属性用于设置图像的高度与宽度。<br />属性值默认单位为像素:<br />&lt;img src=“pulpit.jpg” alt=“Pulpit rock” width=“304” height=“228”&gt;<br />提示: 指定图像的高度和宽度是一个很好的习惯。如果图像指定了高度宽度，页面加载时就会保留指定的尺寸。如果没有指定图片的大小，加载页面时有可能会破坏HTML页面的整体布局。</p><h2 id="基本的注意事项-有用的提示-2"><a class="markdownIt-Anchor" href="#基本的注意事项-有用的提示-2"></a> 基本的注意事项 - 有用的提示：</h2><p><strong>注意</strong>: 假如某个 HTML 文件包含十个图像，那么为了正确显示这个页面，需要加载 11 个文件。加载图片是需要时间的，所以我们的建议是：慎用图片。<br /><strong>注意</strong>: 加载页面时，要注意插入页面图像的路径，如果不能正确设置图像的位置，浏览器无法加载图片，图像标签就会显示一个破碎的图片。</p><h2 id="html-图像标签"><a class="markdownIt-Anchor" href="#html-图像标签"></a> HTML 图像标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;img&gt;</td><td>定义图像</td></tr><tr><td>&lt;map&gt;</td><td>定义图像地图</td></tr><tr><td>&lt;area&gt;</td><td>定义图像地图中的可点击区域</td></tr></tbody></table><p>示例:<br />示例&quot;创建图像映射&quot;中的代码：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">map</span> <span class="attr">name</span>=<span class="string">&quot;planetmap&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;rect&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;0,0,82,126&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Sun&quot;</span> <span class="attr">href</span>=<span class="string">&quot;sun.htm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;90,58,3&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Mercury&quot;</span> <span class="attr">href</span>=<span class="string">&quot;mercur.htm&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">area</span> <span class="attr">shape</span>=<span class="string">&quot;circle&quot;</span> <span class="attr">coords</span>=<span class="string">&quot;124,58,8&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Venus&quot;</span> <span class="attr">href</span>=<span class="string">&quot;venus.htm&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br></pre></td></tr></table></figure><p>1、矩形：(左上角顶点坐标为(x1,y1)，右下角顶点坐标为(x2,y2))<br />&lt;area shape=“rect” coords=“x1,y1,x2,y2” href=url&gt;<br />2、圆形：(圆心坐标为(X1,y1)，半径为r)<br />&lt;area shape=“circle” coords=“x1,y1,r” href=url&gt;<br />3、多边形：(各顶点坐标依次为(x1,y1)、(x2,y2)、(x3,y3) …)<br />&lt;area shape=“poly” coords=“x1,y1,x2,y2 …” href=url&gt;</p><h1 id="7-html-表格"><a class="markdownIt-Anchor" href="#7-html-表格"></a> 7. HTML 表格</h1><p>表格由 &lt;table&gt; 标签来定义。每个表格均有若干行（由 &lt;tr&gt; 标签定义），每行被分割为若干单元格（由 &lt;td&gt; 标签定义）。字母 td 指表格数据（table  data），即数据单元格的内容。数据单元格可以包含文本、图片、列表、段落、表单、水平线、表格等等。<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><table border="1">    <tr>        <td>row 1, cell 1</td>        <td>row 1, cell 2</td>    </tr>    <tr>        <td>row 2, cell 1</td>        <td>row 2, cell 2</td>    </tr></table>## HTML 表格和边框属性如果不定义边框属性，表格将不显示边框。有时这很有用，但是大多数时候，我们希望显示边框。  使用边框属性来显示一个带有边框的表格：  实例:<figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>Row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-表格表头"><a class="markdownIt-Anchor" href="#html-表格表头"></a> HTML 表格表头</h2><p>表格的表头使用 &lt;th&gt; 标签进行定义。<br />大多数浏览器会把表头显示为粗体居中的文本：<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Header 1<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">th</span>&gt;</span>Header 2<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 1, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">td</span>&gt;</span>row 2, cell 2<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><table border="1">    <tr>        <th>Header 1</th>        <th>Header 2</th>    </tr>    <tr>        <td>row 1, cell 1</td>        <td>row 1, cell 2</td>    </tr>    <tr>        <td>row 2, cell 1</td>        <td>row 2, cell 2</td>    </tr><h2 id="html-表格标签"><a class="markdownIt-Anchor" href="#html-表格标签"></a> HTML 表格标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;table&gt;</td><td>定义表格</td></tr><tr><td>&lt;th&gt;</td><td>定义表格的表头</td></tr><tr><td>&lt;tr&gt;</td><td>定义表格的行</td></tr><tr><td>&lt;td&gt;</td><td>定义表格单元</td></tr><tr><td>&lt;caption&gt;</td><td>定义表格标题</td></tr><tr><td>&lt;colgroup&gt;</td><td>定义表格列的组</td></tr><tr><td>&lt;col&gt;</td><td>定义用于表格列的属性</td></tr><tr><td>&lt;thead&gt;</td><td>定义表格的页眉</td></tr><tr><td>&lt;tbody&gt;</td><td>定义表格的主体</td></tr><tr><td>&lt;tfoot&gt;</td><td>定义表格的页脚</td></tr></tbody></table><h1 id="8-html-列表"><a class="markdownIt-Anchor" href="#8-html-列表"></a> 8. HTML 列表</h1><p>HTML 支持有序、无序和定义列表:</p><h2 id="html无序列表"><a class="markdownIt-Anchor" href="#html无序列表"></a> HTML无序列表</h2><p>无序列表是一个项目的列表，此列项目使用粗体圆点（典型的小黑圆圈）进行标记。<br />无序列表使用 &lt;ul&gt; 标签</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-有序列表"><a class="markdownIt-Anchor" href="#html-有序列表"></a> HTML 有序列表</h2><p>同样，有序列表也是一列项目，列表项目使用数字进行标记。 有序列表始于 &lt;ol&gt; 标签。每个列表项始于 &lt;li&gt; 标签。<br />列表项使用数字来标记。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">li</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-自定义列表"><a class="markdownIt-Anchor" href="#html-自定义列表"></a> HTML 自定义列表</h2><p>自定义列表不仅仅是一列项目，而是项目及其注释的组合。</p><p>自定义列表以 &lt;dl&gt; 标签开始。每个自定义列表项以 &lt;dt&gt; 开始。每个自定义列表项的定义以 &lt;dd&gt; 开始。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Coffee<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>- black hot drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dt</span>&gt;</span>Milk<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dd</span>&gt;</span>- white cold drink<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><p>效果:</p><dl><dt>Coffee</dt><dd>- black hot drink</dd><dt>Milk</dt><dd>- white cold drink</dd></dl><h2 id="注意事项-有用提示"><a class="markdownIt-Anchor" href="#注意事项-有用提示"></a> 注意事项 - 有用提示</h2><p>提示: 列表项内部可以使用段落、换行符、图片、链接以及其他列表等等。</p><h2 id="html-列表标签"><a class="markdownIt-Anchor" href="#html-列表标签"></a> HTML 列表标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;ol&gt;</td><td>定义有序列表</td></tr><tr><td>&lt;ul&gt;</td><td>定义无序列表</td></tr><tr><td>&lt;li&gt;</td><td>定义列表项</td></tr><tr><td>&lt;dl&gt;</td><td>定义列表</td></tr><tr><td>&lt;dt&gt;</td><td>自定义列表项目</td></tr><tr><td>&lt;dd&gt;</td><td>定义自定列表项的描述</td></tr></tbody></table><h1 id="9-html-区块"><a class="markdownIt-Anchor" href="#9-html-区块"></a> 9. HTML 区块</h1><h2 id="html-div-和span"><a class="markdownIt-Anchor" href="#html-div-和span"></a> HTML <div> 和<span></h2><p>HTML 可以通过 &lt;div&gt; 和 &lt;span&gt;将元素组合起来。</p><h2 id="html-区块元素"><a class="markdownIt-Anchor" href="#html-区块元素"></a> HTML 区块元素</h2><p>大多数 HTML 元素被定义为块级元素或内联元素。<br />块级元素在浏览器显示时，通常会以新行来开始（和结束）。<br />实例: &lt;h1&gt;, &lt;p&gt;, &lt;ul&gt;, &lt;table&gt;</p><h2 id="html-内联元素"><a class="markdownIt-Anchor" href="#html-内联元素"></a> HTML 内联元素</h2><p>内联元素在显示时通常不会以新行开始。<br />实例: &lt;b&gt;, &lt;td&gt;, &lt;a&gt;, &lt;img&gt;</p><h2 id="html-div-元素"><a class="markdownIt-Anchor" href="#html-div-元素"></a> HTML &lt;div&gt; 元素</h2><p>HTML &lt;div&gt; 元素是块级元素，它可用于组合其他 HTML 元素的容器。<br />&lt;div&gt; 元素没有特定的含义。除此之外，由于它属于块级元素，浏览器会在其前后显示折行。<br />如果与 CSS 一同使用，&lt;div&gt; 元素可用于对大的内容块设置样式属性。<br />&lt;div&gt; 元素的另一个常见的用途是文档布局。它取代了使用表格定义布局的老式方法。使用 &lt;table&gt;   元素进行文档布局不是表格的正确用法。&lt;table&gt; 元素的作用是显示表格化的数据。</p><h2 id="html-span-元素"><a class="markdownIt-Anchor" href="#html-span-元素"></a> HTML <span> 元素</h2><p>HTML &lt;span&gt; 元素是内联元素，可用作文本的容器<br />&lt;span&gt; 元素也没有特定的含义。<br />当与 CSS 一同使用时，&lt;span&gt; 元素可用于为部分文本设置样式属性。</p><h2 id="html-分组标签"><a class="markdownIt-Anchor" href="#html-分组标签"></a> HTML 分组标签</h2><p>标签 | 描述<br />&lt;div&gt;  | 定义了文档的区域，块级 (block-level)<br />&lt;span&gt; | 用来组合文档中的行内元素， 内联元素(inline)</p><h1 id="10-html-布局"><a class="markdownIt-Anchor" href="#10-html-布局"></a> 10. HTML 布局</h1><h2 id="网站布局"><a class="markdownIt-Anchor" href="#网站布局"></a> 网站布局</h2><p>大多数网站会把内容安排到多个列中（就像杂志或报纸那样）。<br />大多数网站可以使用 &lt;div&gt; 或者 &lt;table&gt; 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。<br />虽然我们可以使用HTML table标签来设计出漂亮的布局，但是table标签是不建议作为布局工具使用的 - 表格不是布局工具。</p><h2 id="html-布局-使用div-元素"><a class="markdownIt-Anchor" href="#html-布局-使用div-元素"></a> HTML 布局 - 使用<div> 元素</h2><p>div 元素是用于分组 HTML 元素的块级元素。<br />下面的例子使用五个 div 元素来创建多列布局：<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>茂林的个人站(elec-creator.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;container&quot;</span> <span class="attr">style</span>=<span class="string">&quot;width:500px&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;header&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span> <span class="attr">style</span>=<span class="string">&quot;margin-bottom:0;&quot;</span>&gt;</span>主要的网页标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;menu&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFD700;height:200px;width:100px;float:left;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">HTML<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">CSS<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">JavaScript<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;content&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#EEEEEE;height:200px;width:400px;float:left;&quot;</span>&gt;</span></span><br><span class="line">内容在这里<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">&quot;footer&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;clear:both;text-align:center;&quot;</span>&gt;</span></span><br><span class="line">版权 © elec-creator.com<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-布局-使用表格"><a class="markdownIt-Anchor" href="#html-布局-使用表格"></a> HTML 布局 - 使用表格</h2><p>使用 HTML &lt;table&gt; 标签是创建布局的一种简单的方式。<br />大多数站点可以使用 &lt;div&gt; 或者 &lt;table&gt; 元素来创建多列。CSS 用于对元素进行定位，或者为页面创建背景以及色彩丰富的外观。<br />lamp即使可以使用 HTML 表格来创建漂亮的布局，但设计表格的目的是呈现表格化数据 - 表格不是布局工具！<br />下面的例子使用三行两列的表格 - 第一和最后一行使用 colspan 属性来横跨两列：<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>茂林的个人站(elec-creator.com)<span class="tag">&lt;/<span class="name">title</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;500&quot;</span> <span class="attr">border</span>=<span class="string">&quot;0&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>主要的网页标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFD700;width:100px;&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>菜单<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">HTML<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">CSS<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">JavaScript</span><br><span class="line"><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#eeeeee;height:200px;width:400px;&quot;</span>&gt;</span></span><br><span class="line">内容在这里<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">td</span> <span class="attr">colspan</span>=<span class="string">&quot;2&quot;</span> <span class="attr">style</span>=<span class="string">&quot;background-color:#FFA500;text-align:center;&quot;</span>&gt;</span></span><br><span class="line">版权 © elec-creator.com<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-布局-有用的提示"><a class="markdownIt-Anchor" href="#html-布局-有用的提示"></a> HTML 布局 - 有用的提示</h2><p><strong>Tip</strong>: 使用 CSS 最大的好处是，如果把 CSS 代码存放到外部样式表中，那么站点会更易于维护。通过编辑单一的文件，就可以改变所有页面的布局。如需学习更多有关 CSS 的知识，请访问<a href="https://www.runoob.com/css/css-tutorial.html">菜鸟的CSS 教程</a>。<br /><strong>Tip</strong>: 由于创建高级的布局非常耗时，使用模板是一个快速的选项。通过搜索引擎可以找到很多免费的网站模板（您可以使用这些预先构建好的网站布局，并优化它们）。</p><h2 id="html-布局标签"><a class="markdownIt-Anchor" href="#html-布局标签"></a> HTML 布局标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;div&gt;</td><td>定义文档区块，块级(block-level)</td></tr><tr><td>&lt;span&gt;</td><td>定义 span，用来组合文档中的行内元素</td></tr></tbody></table><h1 id="11-html-表单"><a class="markdownIt-Anchor" href="#11-html-表单"></a> 11. HTML 表单</h1><p>表单是一个包含表单元素的区域。Markdown好像不支持这个元素。<br />表单元素是允许用户在表单中输入内容,比如：文本域(textarea)、下拉列表、单选框(radio-buttons)、复选框(checkboxes)等等。<br />表单使用表单标签 &lt;form&gt; 来设置:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">.</span><br><span class="line">input 元素</span><br><span class="line">.</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-表单-输入元素"><a class="markdownIt-Anchor" href="#html-表单-输入元素"></a> HTML 表单 - 输入元素</h2><p>多数情况下被用到的表单标签是输入标签（&lt;input&gt;）。<br />输入类型是由类型属性（type）定义的。大多数经常被用到的输入类型如下：</p><h2 id="文本域text-fields"><a class="markdownIt-Anchor" href="#文本域text-fields"></a> 文本域（Text Fields）</h2><p>文本域通过&lt;input type=“text”&gt; 标签来设定，当用户要在表单中键入字母、数字等内容时，就会用到文本域。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">First name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;firstname&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">Last name: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;lastname&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:表单本身并不可见。同时，在大多数浏览器中，文本域的默认宽度是 20 个字符。</p><h2 id="密码字段"><a class="markdownIt-Anchor" href="#密码字段"></a> 密码字段</h2><p>密码字段通过标签&lt;input type=“password”&gt; 来定义:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line">Password: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span> <span class="attr">name</span>=<span class="string">&quot;pwd&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>注意</strong>:密码字段字符不会明文显示，而是以星号或圆点替代。</p><h2 id="单选按钮radio-buttons"><a class="markdownIt-Anchor" href="#单选按钮radio-buttons"></a> 单选按钮（Radio Buttons）</h2><p>&lt;input type=“radio”&gt; 标签定义了表单单选框选项</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;male&quot;</span>&gt;</span>Male<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">name</span>=<span class="string">&quot;sex&quot;</span> <span class="attr">value</span>=<span class="string">&quot;female&quot;</span>&gt;</span>Female</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="复选框checkboxes"><a class="markdownIt-Anchor" href="#复选框checkboxes"></a> 复选框（Checkboxes）</h2><p>&lt;input type=“checkbox”&gt; 定义了复选框. 用户需要从若干给定的选择中选取一个或若干选项。</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Bike&quot;</span>&gt;</span>I have a bike<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">name</span>=<span class="string">&quot;vehicle&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Car&quot;</span>&gt;</span>I have a car</span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="提交按钮submit-button"><a class="markdownIt-Anchor" href="#提交按钮submit-button"></a> 提交按钮(Submit Button)</h2><p>&lt;input type=“submit”&gt; 定义了提交按钮.<br />当用户单击确认按钮时，表单的内容会被传送到另一个文件。表单的动作属性定义了目的文件的文件名。由动作属性定义的这个文件通常会对接收到的输入数据进行相关的处理。:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">name</span>=<span class="string">&quot;input&quot;</span> <span class="attr">action</span>=<span class="string">&quot;html_form_action.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;get&quot;</span>&gt;</span></span><br><span class="line">Username: <span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;user&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Submit&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><p>假如您在此文本框内键入几个字母，然后点击确认按钮，那么输入数据会传送到 “html_form_action.php” 的页面。该页面将显示出输入的结果。</p><h2 id="html-表单标签"><a class="markdownIt-Anchor" href="#html-表单标签"></a> HTML 表单标签</h2><p>HTML5新标签:</p><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;form&gt;</td><td>定义供用户输入的表单</td></tr><tr><td>&lt;input&gt;</td><td>定义输入域</td></tr><tr><td>&lt;textarea&gt;</td><td>定义文本域 (一个多行的输入控件)</td></tr><tr><td>&lt;label&gt;</td><td>定义了 &lt;input&gt; 元素的标签，一般为输入标题</td></tr><tr><td>&lt;fieldset&gt;</td><td>定义了一组相关的表单元素，并使用外框包含起来</td></tr><tr><td>&lt;legend&gt;</td><td>定义了 &lt;fieldset&gt; 元素的标题</td></tr><tr><td>&lt;select&gt;</td><td>定义了下拉选项列表</td></tr><tr><td>&lt;optgroup&gt;</td><td>定义选项组</td></tr><tr><td>&lt;option&gt;</td><td>定义下拉列表中的选项</td></tr><tr><td>&lt;button&gt;</td><td>定义一个点击按钮</td></tr><tr><td>&lt;datalist&gt;New</td><td>指定一个预先定义的输入控件选项列表</td></tr><tr><td>&lt;keygen&gt;New</td><td>定义了表单的密钥对生成器字段</td></tr><tr><td>&lt;output&gt;New</td><td>定义一个计算结果</td></tr></tbody></table><h1 id="12-html-框架"><a class="markdownIt-Anchor" href="#12-html-框架"></a> 12. HTML 框架</h1><p>通过使用框架，你可以在同一个浏览器窗口中显示不止一个页面。<br />iframe语法:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><p>该URL指向不同的网页。</p><h2 id="iframe-设置高度与宽度"><a class="markdownIt-Anchor" href="#iframe-设置高度与宽度"></a> Iframe - 设置高度与宽度</h2><p>height 和 width 属性用来定义iframe标签的高度与宽度。<br />属性默认以像素为单位, 但是你可以指定其按比例显示 (如：“80%”)。<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">width</span>=<span class="string">&quot;200&quot;</span> <span class="attr">height</span>=<span class="string">&quot;200&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="iframe-移除边框"><a class="markdownIt-Anchor" href="#iframe-移除边框"></a> Iframe - 移除边框</h2><p>frameborder 属性用于定义iframe表示是否显示边框。<br />设置属性值为 “0” 移除iframe的边框:<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">frameborder</span>=<span class="string">&quot;0&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="使用iframe来显示目标链接页面"><a class="markdownIt-Anchor" href="#使用iframe来显示目标链接页面"></a> 使用iframe来显示目标链接页面</h2><p>iframe可以显示一个目标链接的页面<br />目标链接的属性必须使用iframe的属性，如下实例:<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span> <span class="attr">name</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://elec-creator.com&quot;</span> <span class="attr">target</span>=<span class="string">&quot;iframe_a&quot;</span>&gt;</span>ELEC-CREATOR.COM<span class="tag">&lt;/<span class="name">a</span>&gt;</span><span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="html-iframe-标签"><a class="markdownIt-Anchor" href="#html-iframe-标签"></a> HTML &lt;iframe&gt; 标签</h2><table><thead><tr><th>标签</th><th>说明</th></tr></thead><tbody><tr><td>&lt;iframe&gt;</td><td>定义一个内联的iframe</td></tr></tbody></table><h1 id="13-html-颜色"><a class="markdownIt-Anchor" href="#13-html-颜色"></a> 13. HTML 颜色</h1><p>HTML 颜色由红色、绿色、蓝色混合而成。</p><h2 id="颜色值"><a class="markdownIt-Anchor" href="#颜色值"></a> 颜色值</h2><p>HTML 颜色由一个十六进制符号来定义，这个符号由红色、绿色和蓝色的值组成（RGB）。<br />每种颜色的最小值是0（十六进制：#00）。最大值是255（十六进制：#FF）。</p><h2 id="1600万种不同颜色"><a class="markdownIt-Anchor" href="#1600万种不同颜色"></a> 1600万种不同颜色</h2><p>三种颜色 红，绿，蓝的组合从0到255，一共有1600万种不同颜色(256 x 256 x 256)。<br />在下面的颜色表中你会看到不同的结果，从0到255的红色，同时设置绿色和蓝色的值为0,随着红色的值变化，不同的值都显示了不同的颜色。</p><h2 id="颜色查询参考"><a class="markdownIt-Anchor" href="#颜色查询参考"></a> 颜色查询参考</h2><p><a href="https://www.runoob.com/html/html-colornames.html"><strong>fontke字客网查询快速入口</strong></a><br /><a href="https://www.runoob.com/html/html-colornames.html"><strong>菜鸟的颜色名查询</strong></a><br /><a href="https://www.runoob.com/html/html-colorvalues.html"><strong>菜鸟的颜色值查询</strong></a></p><h1 id="14-html-脚本"><a class="markdownIt-Anchor" href="#14-html-脚本"></a> 14. HTML 脚本</h1><p>JavaScript 使 HTML 页面具有更强的动态和交互性。</p><h2 id="html-script-标签"><a class="markdownIt-Anchor" href="#html-script-标签"></a> HTML &lt;script&gt; 标签</h2><p>&lt;script&gt; 标签用于定义客户端脚本，比如 JavaScript。<br />&lt;script&gt; 元素既可包含脚本语句，也可通过 src 属性指向外部脚本文件。<br />JavaScript 最常用于图片操作、表单验证以及内容动态更新。<br />下面的脚本会向浏览器输出&quot;Hello World!&quot;：<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;Hello World!&quot;</span>);</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure><p>学习更多关于Javascript教程，查看<a href="https://www.runoob.com/js/js-tutorial.html">菜鸟的JavaScript 教程</a>!</p><h2 id="html-noscript-标签"><a class="markdownIt-Anchor" href="#html-noscript-标签"></a> HTML &lt;noscript&gt; 标签</h2><p>&lt;noscript&gt; 标签提供无法使用脚本时的替代内容，比方在浏览器禁用脚本时，或浏览器不支持客户端脚本时。<br />&lt;noscript&gt;元素可包含普通 HTML 页面的 body 元素中能够找到的所有元素。<br />只有在浏览器不支持脚本或者禁用脚本时，才会显示 &lt;noscript&gt; 元素中的内容：<br />实例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="javascript"></span></span><br><span class="line"><span class="javascript"><span class="built_in">document</span>.write(<span class="string">&quot;Hello World!&quot;</span>)</span></span><br><span class="line"><span class="javascript"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">noscript</span>&gt;</span>抱歉，你的浏览器不支持 JavaScript!<span class="tag">&lt;/<span class="name">noscript</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="javascript体验来自本站javascript教程"><a class="markdownIt-Anchor" href="#javascript体验来自本站javascript教程"></a> JavaScript体验(来自本站javascript教程)</h2><p>JavaScript实例代码:<br />JavaScript可以直接在HTML输出:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.write(&quot;<span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span>&quot;);</span><br></pre></td></tr></table></figure><p>JavaScript事件响应:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">type</span>=<span class="string">&quot;button&quot;</span> <span class="attr">onclick</span>=<span class="string">&quot;myFunction()&quot;</span>&gt;</span>点我！<span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure><p>JavaScript处理 HTML 样式:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">document.getElementById(&quot;demo&quot;).style.color=&quot;#ff0000&quot;;</span><br></pre></td></tr></table></figure><h2 id="html-脚本标签"><a class="markdownIt-Anchor" href="#html-脚本标签"></a> HTML 脚本标签</h2><table><thead><tr><th>标签</th><th>描述</th></tr></thead><tbody><tr><td>&lt;script&gt;</td><td>定义了客户端脚本</td></tr><tr><td>&lt;noscript&gt;</td><td>定义了不支持脚本浏览器输出的文本</td></tr></tbody></table><h1 id="15-html-字符实体"><a class="markdownIt-Anchor" href="#15-html-字符实体"></a> 15. HTML 字符实体</h1><p>HTML 中的预留字符必须被替换为字符实体。<br />一些在键盘上找不到的字符也可以使用字符实体来替换。<br />在 HTML 中，某些字符是预留的。<br />在 HTML 中不能使用小于号（&lt;）和大于号（&gt;），这是因为浏览器会误认为它们是标签。<br />如果希望正确地显示预留字符，我们必须在 HTML 源代码中使用字符实体（character entities）。 字符实体类似这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&amp;entity_name;</span><br><span class="line">或</span><br><span class="line">&amp;#entity_number;</span><br></pre></td></tr></table></figure><p>如需显示小于号，我们必须这样写：<strong>&amp;lt;</strong> 或 <strong>&amp;#60;</strong> 或 <strong>&amp;#060;</strong><br /><strong>提示</strong>： 使用实体名而不是数字的好处是，名称易于记忆。不过坏处是，浏览器也许并不支持所有实体名称（对实体数字的支持却很好）。</p><h2 id="不间断空格non-breaking-space"><a class="markdownIt-Anchor" href="#不间断空格non-breaking-space"></a> 不间断空格(Non-breaking Space)</h2><p>HTML 中的常用字符实体是不间断空格(&amp;nbsp;)。<br />浏览器总是会截短 HTML 页面中的空格。如果您在文本中写 10 个空格，在显示该页面之前，浏览器会删除它们中的 9 个。如需在页面中增加空格的数量，您需要使用 &amp;nbsp; 字符实体。</p><h2 id="结合音标符"><a class="markdownIt-Anchor" href="#结合音标符"></a> 结合音标符</h2><p>发音符号是加到字母上的一个&quot;glyph(字形)&quot;。<br />一些变音符号, 如 尖音符 (  ̀) 和 抑音符 (  ́) 。<br />变音符号可以出现字母的上面和下面，或者字母里面，或者两个字母间。<br />变音符号可以与字母、数字字符的组合来使用。<br />以下是一些实例:</p><table><thead><tr><th>音标符</th><th>字符</th><th>Construct</th><th>输出结果</th></tr></thead><tbody><tr><td>`</td><td>a</td><td>a&amp;#768;</td><td>à</td></tr><tr><td>́</td><td>a</td><td>a&amp;#769;</td><td>á</td></tr><tr><td>̂</td><td>a</td><td>a&amp;#770;</td><td>â</td></tr><tr><td>̃</td><td>a</td><td>a&amp;#771;</td><td>ã</td></tr><tr><td>̀</td><td>O</td><td>O&amp;#768;</td><td>Ò</td></tr><tr><td>́</td><td>O</td><td>O&amp;#769;</td><td>Ó</td></tr><tr><td>̂</td><td>O</td><td>O&amp;#770;</td><td>Ô</td></tr><tr><td>̃</td><td>O</td><td>O&amp;#771;</td><td>Õ</td></tr></tbody></table><h2 id="html字符实体"><a class="markdownIt-Anchor" href="#html字符实体"></a> HTML字符实体</h2><p><strong>Note</strong>:实体名称对大小写敏感!</p><table><thead><tr><th>显示结果</th><th>描述</th><th>实体名称</th><th>实体编号</th></tr></thead><tbody><tr><td>空格</td><td>&amp;nbsp;</td><td>&amp;#160;</td><td></td></tr><tr><td>&lt;</td><td>小于号</td><td>&amp;lt;</td><td>&amp;#60;</td></tr><tr><td>&gt;</td><td>大于号</td><td>&amp;gt;</td><td>&amp;#62;</td></tr><tr><td>&amp;</td><td>和号</td><td>&amp;amp;</td><td>&amp;#38;</td></tr><tr><td>&quot;</td><td>引号</td><td>&amp;quot;</td><td>&amp;#34;</td></tr><tr><td>’</td><td>撇号</td><td>&amp;apos; (IE不支持)</td><td>&amp;#39;</td></tr><tr><td>￠</td><td>分</td><td>&amp;cent;</td><td>&amp;#162;</td></tr><tr><td>£</td><td>镑</td><td>&amp;pound;</td><td>&amp;#163;</td></tr><tr><td>¥</td><td>人民币/日元</td><td>&amp;yen;</td><td>&amp;#165;</td></tr><tr><td>€</td><td>欧元</td><td>&amp;euro;</td><td>&amp;#8364;</td></tr><tr><td>§</td><td>小节</td><td>&amp;sect;</td><td>&amp;#167;</td></tr><tr><td>©</td><td>版权</td><td>&amp;copy;</td><td>&amp;#169;</td></tr><tr><td>®</td><td>注册商标</td><td>&amp;reg;</td><td>&amp;#174;</td></tr><tr><td>™</td><td>商标</td><td>&amp;trade;</td><td>&amp;#8482;</td></tr><tr><td>×</td><td>乘号</td><td>&amp;times;</td><td>&amp;#215;</td></tr><tr><td>÷</td><td>除号</td><td>&amp;divide;</td><td>&amp;#247;</td></tr></tbody></table><p>虽然 html 不区分大小写，但实体字符对大小写敏感。<br />查看完整的HTML实体：参考<a href="https://www.runoob.com/tags/ref-entities.html">菜鸟的 HTML 实体参考手册</a>。</p><h1 id="16-html-url"><a class="markdownIt-Anchor" href="#16-html-url"></a> 16. HTML URL</h1><p>URL名为统一资源定位器(Uniform Resource Locators)<br />URL 是一个网页地址。<br />URL可以由字母组成，如&quot;<a href="http://elec-creator.com">elec-creator.com</a>&quot;，或互联网协议（IP）地址：   192.68.20.50。大多数人进入网站使用网站域名来访问，因为 名字比数字更容易记住。</p><h2 id="url-统一资源定位器"><a class="markdownIt-Anchor" href="#url-统一资源定位器"></a> URL - 统一资源定位器</h2><p>Web浏览器通过URL从Web服务器请求页面。<br />当您点击 HTML 页面中的某个链接时，对应的 <a> 标签指向万维网上的一个地址。<br />一个统一资源定位器(URL) 用于定位万维网上的文档。<br />一个网页地址实例: <a href="http://elec-creator.com/%E7%BC%96%E7%A8%8B%E8%AF%AD%E8%A8%80/HTML">http://elec-creator.com/编程语言/HTML</a> 语法规则:<br />scheme://host.domain:port/path/filename<br />说明:</p><ul><li>scheme - 定义因特网服务的类型。最常见的类型是 http</li><li>host - 定义域主机（http 的默认主机是 www）</li><li>domain - 定义因特网域名，比如 <a href="http://elec-creator.com">elec-creator.com</a></li><li>:port - 定义主机上的端口号（http 的默认端口号是 80）</li><li>path - 定义服务器上的路径（如果省略，则文档必须位于网站的根目录中）。</li><li>filename - 定义文档/资源的名称</li></ul><h2 id="常见的-url-scheme"><a class="markdownIt-Anchor" href="#常见的-url-scheme"></a> 常见的 URL Scheme</h2><p>以下是一些URL scheme：</p><table><thead><tr><th>Scheme</th><th>访问</th><th>用于…</th></tr></thead><tbody><tr><td>http</td><td>超文本传输协议</td><td>以 http:// 开头的普通网页。不加密。</td></tr><tr><td>https</td><td>安全超文本传输协议</td><td>安全网页，加密所有信息交换。</td></tr><tr><td>ftp</td><td>文件传输协议</td><td>用于将文件下载或上传至网站。</td></tr><tr><td>file</td><td></td><td>您计算机上的文件。</td></tr></tbody></table><h2 id="url-字符编码"><a class="markdownIt-Anchor" href="#url-字符编码"></a> URL 字符编码</h2><p>URL 只能使用 <a href="https://www.runoob.com/tags/html-ascii.html">ASCII 字符集</a>.<br />来通过因特网进行发送。由于 URL 常常会包含 ASCII 集合之外的字符，URL 必须转换为有效的 ASCII 格式。<br />URL 编码使用 “%” 其后跟随两位的十六进制数来替换非 ASCII 字符。<br />URL 不能包含空格。URL 编码通常使用 + 来替换空格。</p><h2 id="url-编码实例"><a class="markdownIt-Anchor" href="#url-编码实例"></a> URL 编码实例</h2><table><thead><tr><th>字符</th><th>URL 编码</th></tr></thead><tbody><tr><td>€</td><td>%80</td></tr><tr><td>£</td><td>%A3</td></tr><tr><td>©</td><td>%A9</td></tr><tr><td>®</td><td>%AE</td></tr><tr><td>À</td><td>%C0</td></tr><tr><td>Á</td><td>%C1</td></tr><tr><td>Â</td><td>%C2</td></tr><tr><td>Ã</td><td>%C3</td></tr><tr><td>Ä</td><td>%C4</td></tr><tr><td>Å</td><td>%C5</td></tr></tbody></table><p>完整的 URL 编码参考，参考<a href="https://www.runoob.com/tags/html-urlencode.html">菜鸟的 URL 编码参考手册</a>。</p><h1 id="17-html-常用格式速查"><a class="markdownIt-Anchor" href="#17-html-常用格式速查"></a> 17. HTML 常用格式速查</h1><h2 id="html-基本文档"><a class="markdownIt-Anchor" href="#html-基本文档"></a> HTML 基本文档</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">可见文本...</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="基本标签basic-tags"><a class="markdownIt-Anchor" href="#基本标签basic-tags"></a> 基本标签（Basic Tags）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>最大的标题<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h3</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h3</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h4</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h4</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h5</span>&gt;</span> . . . <span class="tag">&lt;/<span class="name">h5</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h6</span>&gt;</span>最小的标题<span class="tag">&lt;/<span class="name">h6</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落。<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">br</span>&gt;</span> （换行）</span><br><span class="line"><span class="tag">&lt;<span class="name">hr</span>&gt;</span> （水平线）</span><br><span class="line"><span class="comment">&lt;!-- 这是注释 --&gt;</span></span><br></pre></td></tr></table></figure><h2 id="文本格式化formatting"><a class="markdownIt-Anchor" href="#文本格式化formatting"></a> 文本格式化（Formatting）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span>粗体文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">code</span>&gt;</span>计算机代码<span class="tag">&lt;/<span class="name">code</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">em</span>&gt;</span>强调文本<span class="tag">&lt;/<span class="name">em</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">i</span>&gt;</span>斜体文本<span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">kbd</span>&gt;</span>键盘输入<span class="tag">&lt;/<span class="name">kbd</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">pre</span>&gt;</span>预格式化文本<span class="tag">&lt;/<span class="name">pre</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">small</span>&gt;</span>更小的文本<span class="tag">&lt;/<span class="name">small</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">strong</span>&gt;</span>重要的文本<span class="tag">&lt;/<span class="name">strong</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">abbr</span>&gt;</span> （缩写）</span><br><span class="line"><span class="tag">&lt;<span class="name">address</span>&gt;</span> （联系信息）</span><br><span class="line"><span class="tag">&lt;<span class="name">bdo</span>&gt;</span> （文字方向）</span><br><span class="line"><span class="tag">&lt;<span class="name">blockquote</span>&gt;</span> （从另一个源引用的部分）</span><br><span class="line"><span class="tag">&lt;<span class="name">cite</span>&gt;</span> （工作的名称）</span><br><span class="line"><span class="tag">&lt;<span class="name">del</span>&gt;</span> （删除的文本）</span><br><span class="line"><span class="tag">&lt;<span class="name">ins</span>&gt;</span> （插入的文本）</span><br><span class="line"><span class="tag">&lt;<span class="name">sub</span>&gt;</span> （下标文本）</span><br><span class="line"><span class="tag">&lt;<span class="name">sup</span>&gt;</span> （上标文本）</span><br></pre></td></tr></table></figure><h2 id="链接links"><a class="markdownIt-Anchor" href="#链接links"></a> 链接（Links）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">普通的链接：<span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span>&gt;</span>链接文本<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">图像链接： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;http://www.example.com/&quot;</span>&gt;</span><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;替换文本&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">邮件链接： <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;mailto:webmaster@example.com&quot;</span>&gt;</span>发送e-mail<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line">书签：</span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">id</span>=<span class="string">&quot;tips&quot;</span>&gt;</span>提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;#tips&quot;</span>&gt;</span>跳到提示部分<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="图片images"><a class="markdownIt-Anchor" href="#图片images"></a> 图片（Images）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;URL&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;替换文本&quot;</span> <span class="attr">height</span>=<span class="string">&quot;42&quot;</span> <span class="attr">width</span>=<span class="string">&quot;42&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="样式区块stylessections"><a class="markdownIt-Anchor" href="#样式区块stylessections"></a> 样式/区块（Styles/Sections）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">&quot;text/css&quot;</span>&gt;</span><span class="css"></span></span><br><span class="line"><span class="css"><span class="selector-tag">h1</span> &#123;<span class="attribute">color</span>:red;&#125;</span></span><br><span class="line"><span class="css"><span class="selector-tag">p</span> &#123;<span class="attribute">color</span>:blue;&#125;</span></span><br><span class="line"><span class="css"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span>&gt;</span>文档中的块级元素<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">span</span>&gt;</span>文档中的内联元素<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="无序列表"><a class="markdownIt-Anchor" href="#无序列表"></a> 无序列表</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>项目<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>项目<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span><br><span class="line">## 有序列表</span><br><span class="line"><span class="tag">&lt;<span class="name">ol</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第一项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">li</span>&gt;</span>第二项<span class="tag">&lt;/<span class="name">li</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">ol</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="定义列表"><a class="markdownIt-Anchor" href="#定义列表"></a> 定义列表</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dl</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>项目 1<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项目 1<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dt</span>&gt;</span>项目 2<span class="tag">&lt;/<span class="name">dt</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dd</span>&gt;</span>描述项目 2<span class="tag">&lt;/<span class="name">dd</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dl</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表格tables"><a class="markdownIt-Anchor" href="#表格tables"></a> 表格（Tables）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">&quot;1&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">th</span>&gt;</span>表格标题<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格数据<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">td</span>&gt;</span>表格数据<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">## 框架（Iframe）</span><br><span class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">src</span>=<span class="string">&quot;demo_iframe.htm&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="表单forms"><a class="markdownIt-Anchor" href="#表单forms"></a> 表单（Forms）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">form</span> <span class="attr">action</span>=<span class="string">&quot;demo_form.php&quot;</span> <span class="attr">method</span>=<span class="string">&quot;post/get&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;text&quot;</span> <span class="attr">name</span>=<span class="string">&quot;email&quot;</span> <span class="attr">size</span>=<span class="string">&quot;40&quot;</span> <span class="attr">maxlength</span>=<span class="string">&quot;50&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;password&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;checkbox&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;radio&quot;</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;submit&quot;</span> <span class="attr">value</span>=<span class="string">&quot;Send&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;reset&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">type</span>=<span class="string">&quot;hidden&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>苹果<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span>香蕉<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span>&gt;</span>樱桃<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">textarea</span> <span class="attr">name</span>=<span class="string">&quot;comment&quot;</span> <span class="attr">rows</span>=<span class="string">&quot;60&quot;</span> <span class="attr">cols</span>=<span class="string">&quot;20&quot;</span>&gt;</span><span class="tag">&lt;/<span class="name">textarea</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">form</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="实体entities"><a class="markdownIt-Anchor" href="#实体entities"></a> 实体（Entities）</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">&amp;lt;</span> 等同于 &lt;</span><br><span class="line"><span class="symbol">&amp;gt;</span> 等同于 &gt;</span><br><span class="line"><span class="symbol">&amp;#169;</span> 等同于 ©</span><br></pre></td></tr></table></figure><h1 id="18-html-进化版-xhtml"><a class="markdownIt-Anchor" href="#18-html-进化版-xhtml"></a> 18. HTML 进化版-XHTML</h1><p>XHTML 是以 XML 格式编写的 HTML。</p><h2 id="什么是-xhtml"><a class="markdownIt-Anchor" href="#什么是-xhtml"></a> 什么是 XHTML?</h2><ul><li>XHTML 指的是可扩展超文本标记语言</li><li>XHTML 与 HTML 4.01 几乎是相同的</li><li>XHTML 是更严格更纯净的 HTML 版本</li><li>XHTML 是以 XML 应用的方式定义的 HTML</li><li>XHTML 是 2001 年 1 月发布的 W3C 推荐标准</li><li>XHTML 得到所有主流浏览器的支持</li></ul><h2 id="为什么使用-xhtml"><a class="markdownIt-Anchor" href="#为什么使用-xhtml"></a> 为什么使用 XHTML?</h2><p>因特网上的很多页面包含了&quot;糟糕&quot;的 HTML。<br />如果在浏览器中查看，下面的 HTML 代码运行起来非常正常（即使它并未遵守 HTML 规则）：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">title</span>&gt;</span>这是一个不规范的 HTML<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>不规范的 HTML</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><p>XML 是一种必须正确标记且格式良好的标记语言。<br />如果希望学习 XML，请阅读我们的 XML 教程。<br />今日的科技界存在一些不同的浏览器技术。其中一些在计算机上运行，而另一些可能在移动电话或其他小型设备上运行。小型设备往往缺乏解释&quot;糟糕&quot;的标记语言的资源和能力。<br />所以 - 通过结合 XML 和 HTML 的长处，开发出了 XHTML。XHTML 是作为 XML 被重新设计的 HTML。</p><h2 id="与-html-相比最重要的区别"><a class="markdownIt-Anchor" href="#与-html-相比最重要的区别"></a> 与 HTML 相比最重要的区别：</h2><h3 id="文档结构"><a class="markdownIt-Anchor" href="#文档结构"></a> 文档结构</h3><ul><li>XHTML DOCTYPE 是强制性的</li><li>&lt;html&gt; 中的 XML namespace 属性是强制性的</li><li>&lt;html&gt;、&lt;head&gt;、&lt;title&gt; 以及 &lt;body&gt; 也是强制性的</li></ul><h3 id="元素语法"><a class="markdownIt-Anchor" href="#元素语法"></a> 元素语法</h3><ul><li>XHTML 元素必须正确嵌套</li><li>XHTML 元素必须始终关闭</li><li>XHTML 元素必须小写</li><li>XHTML 文档必须有一个根元素</li></ul><h3 id="属性语法"><a class="markdownIt-Anchor" href="#属性语法"></a> 属性语法</h3><ul><li>XHTML 属性必须使用小写</li><li>XHTML 属性值必须用引号包围</li><li>XHTML 属性最小化也是禁止的</li></ul><h2 id="doctype-是强制性的"><a class="markdownIt-Anchor" href="#doctype-是强制性的"></a> <!DOCTYPE ....>是强制性的</h2><p>XHTML 文档必须进行 XHTML 文档类型声明（XHTML DOCTYPE declaration）。<br />您可以在菜鸟教程的标签参考手册中找到完整的 XHTML 文档类型。<br />&lt;html&gt;, &lt;head&gt;, &lt;title&gt;, 和 &lt;body&gt; 元素也必须存在，并且必须使用 &lt;html&gt; 中的 xmlns 属性为文档规定 xml 命名空间。<br />下面的例子展示了带有最少的必需标签的 XHTML 文档：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE <span class="meta-keyword">html</span> <span class="meta-keyword">PUBLIC</span> <span class="meta-string">&quot;-//W3C//DTD XHTML 1.0 Transitional//EN&quot;</span></span></span><br><span class="line"><span class="meta"><span class="meta-string">&quot;http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns</span>=<span class="string">&quot;http://www.w3.org/1999/xhtml&quot;</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">&quot;utf-8&quot;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">title</span>&gt;</span>文档标题<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line">文档内容</span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"> </span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="xhtml-元素必须合理嵌套"><a class="markdownIt-Anchor" href="#xhtml-元素必须合理嵌套"></a> XHTML 元素必须合理嵌套</h2><p>在 HTML 中，一些元素可以不互相嵌套，像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>粗体和斜体文本<span class="tag">&lt;/<span class="name">b</span>&gt;</span><span class="tag">&lt;/<span class="name">i</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在 XHTML 中，所有的元素都必须互相合理地嵌套，像这样：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">b</span>&gt;</span><span class="tag">&lt;<span class="name">i</span>&gt;</span>粗体和斜体文本<span class="tag">&lt;/<span class="name">i</span>&gt;</span><span class="tag">&lt;/<span class="name">b</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="xhtml-元素必须有关闭标签"><a class="markdownIt-Anchor" href="#xhtml-元素必须有关闭标签"></a> XHTML 元素必须有关闭标签</h2><p>错误示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落</span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另外一个段落</span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是另外一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="空元素必须包含关闭标签"><a class="markdownIt-Anchor" href="#空元素必须包含关闭标签"></a> 空元素必须包含关闭标签</h2><p>错误示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分行:<span class="tag">&lt;<span class="name">br</span>&gt;</span></span><br><span class="line">水平线: <span class="tag">&lt;<span class="name">hr</span>&gt;</span></span><br><span class="line">图片: <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;happy.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Happy face&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">分行:<span class="tag">&lt;<span class="name">br</span> /&gt;</span></span><br><span class="line">水平线: <span class="tag">&lt;<span class="name">hr</span> /&gt;</span></span><br><span class="line">图片: <span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&quot;happy.gif&quot;</span> <span class="attr">alt</span>=<span class="string">&quot;Happy face&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><h2 id="xhtml-元素必须是小写"><a class="markdownIt-Anchor" href="#xhtml-元素必须是小写"></a> XHTML 元素必须是小写</h2><p>错误示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">BODY</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">P</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">P</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">BODY</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span>这是一个段落<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="属性名称必须是小写"><a class="markdownIt-Anchor" href="#属性名称必须是小写"></a> 属性名称必须是小写</h2><p>错误示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">WIDTH</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确示例:</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="属性值必须有引号"><a class="markdownIt-Anchor" href="#属性值必须有引号"></a> 属性值必须有引号</h2><p>错误示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">100%</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">width</span>=<span class="string">&quot;100%&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="不允许属性简写"><a class="markdownIt-Anchor" href="#不允许属性简写"></a> 不允许属性简写</h2><p>错误示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">checked</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">readonly</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">disabled</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>&gt;</span></span><br></pre></td></tr></table></figure><p>正确示例：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">checked</span>=<span class="string">&quot;checked&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">readonly</span>=<span class="string">&quot;readonly&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">input</span> <span class="attr">disabled</span>=<span class="string">&quot;disabled&quot;</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">option</span> <span class="attr">selected</span>=<span class="string">&quot;selected&quot;</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="如何将-html-转换为-xhtml"><a class="markdownIt-Anchor" href="#如何将-html-转换为-xhtml"></a> 如何将 HTML 转换为 XHTML</h2><ol><li>添加一个 XHTML &lt;!DOCTYPE&gt; 到你的网页中</li><li>添加 xmlns 属性添加到每个页面的html元素中。</li><li>改变所有的元素为小写</li><li>关闭所有的空元素</li><li>修改所有的属性名称为小写</li><li>所有属性值添加引号</li></ol>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/posts/4a17b156.html"/>
      <url>/posts/4a17b156.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><center> <font color="#008000" size=8>Hello world!</font><blockquote><p>欢迎来到Malloy的个人站,疫情期间宅坏了,一直想搭建自己的个人站,囫囵吞枣学习的服务器的架构和一些前端的知识,于是就自以为是的搭建起来了哈哈哈,今天终于得以实践加成功的部署了我的个人站,看到Hello world的时候心情激动极了,感觉这一周的折腾没有白费 ,Awesome<br />ヽ(^_−)ﾉ .</p></blockquote><p>个人站初期,很多东西需要完善,等解决了公网的问题后会把所有完善到新种草的超精致的全志H5超低功耗mini服务器Nanopi NEO2这个金属坨坨上,以后有空的时候会在这里记录分享我的作品和创作过程(＾－＾),也会慢慢把之前的东西整理上来,希望我不要成为’‘拖稿王’’!</p><h1 id="折腾起来吧骚年祝我玩的开心~"><a class="markdownIt-Anchor" href="#折腾起来吧骚年祝我玩的开心~"></a> 折腾起来吧骚年!祝我玩的开心~</h1><div class="fj-gallery"><p><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/1.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/2.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/3.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/4.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/5.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/6.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/7.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/8.jpg" alt="" /><br /><img src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/content/hello-world/9.jpg" alt="" /></p>          </div>]]></content>
      
      
      <categories>
          
          <category> Hello-world </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hello world </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Android</title>
      <link href="/posts/5d018fb1.html"/>
      <url>/posts/5d018fb1.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> Android </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Android </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>控制算法</title>
      <link href="/posts/797aa75.html"/>
      <url>/posts/797aa75.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 控制算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 控制算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬件</title>
      <link href="/posts/7ba183b4.html"/>
      <url>/posts/7ba183b4.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 硬件 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 硬件 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Keil</title>
      <link href="/posts/d376f476.html"/>
      <url>/posts/d376f476.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> Keil </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Keil </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>MCU</title>
      <link href="/posts/47567e3c.html"/>
      <url>/posts/47567e3c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Jetson-nano</title>
      <link href="/posts/25f0994d.html"/>
      <url>/posts/25f0994d.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> Nvidia </category>
          
          <category> Nvidia </category>
          
          <category> Jetson-nano </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Jetson-nano </tag>
            
            <tag> Nvidia </tag>
            
            <tag> Linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PCBA</title>
      <link href="/posts/5b01bfa6.html"/>
      <url>/posts/5b01bfa6.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 硬件学习 </category>
          
          <category> PCBA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PCBA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Raspberry</title>
      <link href="/posts/fce157c2.html"/>
      <url>/posts/fce157c2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> Raspberry </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> Raspberry </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS</title>
      <link href="/posts/15fa7048.html"/>
      <url>/posts/15fa7048.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vscode</title>
      <link href="/posts/83363fd2.html"/>
      <url>/posts/83363fd2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> Vscode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Vscode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Opencv</title>
      <link href="/posts/f19f4a3.html"/>
      <url>/posts/f19f4a3.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> AI </category>
          
          <category> Opencv </category>
          
      </categories>
      
      
        <tags>
            
            <tag> AI </tag>
            
            <tag> Opencv </tag>
            
            <tag> 机器学习 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Nuvoton</title>
      <link href="/posts/dcf744a9.html"/>
      <url>/posts/dcf744a9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
          <category> Nuvoton </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> Nuvoton </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM32</title>
      <link href="/posts/b900f0d0.html"/>
      <url>/posts/b900f0d0.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
          <category> STM32 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> STM32 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>STM8</title>
      <link href="/posts/fe9c70ea.html"/>
      <url>/posts/fe9c70ea.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> MCU </category>
          
          <category> STM8 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MCU </tag>
            
            <tag> STM8 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Linux</title>
      <link href="/posts/53d0684b.html"/>
      <url>/posts/53d0684b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows</title>
      <link href="/posts/2c5abc07.html"/>
      <url>/posts/2c5abc07.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Windows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 操作系统 </tag>
            
            <tag> Windows </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C</title>
      <link href="/posts/3dd7ffa7.html"/>
      <url>/posts/3dd7ffa7.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C语言 </tag>
            
            <tag> 编程语言 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++</title>
      <link href="/posts/5751eea2.html"/>
      <url>/posts/5751eea2.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JAVA</title>
      <link href="/posts/498f0b66.html"/>
      <url>/posts/498f0b66.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> JAVA </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> JAVA </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Javascript</title>
      <link href="/posts/cbb79327.html"/>
      <url>/posts/cbb79327.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Javascript </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Javascript </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python</title>
      <link href="/posts/a378bd8e.html"/>
      <url>/posts/a378bd8e.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> Python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> Python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Debian</title>
      <link href="/posts/741cc87a.html"/>
      <url>/posts/741cc87a.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> Debian </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Debian </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu</title>
      <link href="/posts/7be7930f.html"/>
      <url>/posts/7be7930f.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h2 id="日后更新"><a class="markdownIt-Anchor" href="#日后更新"></a> 日后更新…</h2>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
          <category> Linux </category>
          
          <category> Ubuntu </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> 操作系统 </tag>
            
            <tag> Ubuntu </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS入门</title>
      <link href="/posts/5d29def9.html"/>
      <url>/posts/5d29def9.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-robot-operating-system"><a class="markdownIt-Anchor" href="#1-robot-operating-system"></a> 1. Robot Operating System</h1><h2 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1. 简介</h2><p>ROS是一个适用于机器人编程的<strong>框架</strong>，这个框架把原本松散的零部件耦合在了一起，为他们提供了<strong>通信架构</strong>。ROS虽然叫做<strong>操作系统</strong>，但并非Windows、Mac那样通常意义的操作系统，它只是连接了操作系统和你开发的ROS应用程序，所以它也算是一个<strong>中间件</strong>，基于ROS的应用程序之间建立起了沟通的桥梁，所以也是运行在Linux上的<strong>运行时环境</strong>，在这个环境上，机器人的感知、决策、控制算法可以更好的组织和运行。</p><p>以上几个关键词（框架、中间件、操作系统、运行时环境）都可以用来描述ROS的特性，作为初学者我们不必深究这些概念，随着你越来越多的使用ROS，就能够体会到它的作用。</p><h2 id="12-历代ros版本"><a class="markdownIt-Anchor" href="#12-历代ros版本"></a> 1.2. 历代ROS版本</h2><p>ROS1.0版本发布于2010年， 基于PR2机器人开发了一系列机器人相关的基础软件包。 随后<br />ROS版本迭代频繁， 目前已经发布到了Lunar。 目前使用人数最多的是Kinetic和Indigo这两个<br />Long Term Support版本。</p><table><thead><tr><th>ROS版本</th><th>发布时间</th></tr></thead><tbody><tr><td>Lunar Loggerhead</td><td>2017.5</td></tr><tr><td>Kinetic Kame</td><td>2016.5</td></tr><tr><td>Jade Turtle</td><td>2015.5</td></tr><tr><td>Indigo lgloo</td><td>2014.7</td></tr><tr><td>Hydro Medusa</td><td>2013.9</td></tr><tr><td>Groovy Galapagos</td><td>2012.12</td></tr><tr><td>Fuerte Turtle</td><td>2012.4</td></tr><tr><td>Electric Emys</td><td>2011.8</td></tr><tr><td>Diamondback</td><td>2011.3</td></tr><tr><td>C Turtle</td><td>2010.8</td></tr><tr><td>Box TurtleBox Turtle</td><td>2010.3</td></tr></tbody></table><h2 id="13-ros特点"><a class="markdownIt-Anchor" href="#13-ros特点"></a> 1.3. ROS特点</h2><p>ROS具有这些特点：</p><ul><li><p><strong>分布式 点对点</strong></p><p>ROS采用了分布式的框架，通过点对点的设计让机器人的进程可以分别运行，便于模块化的修改和定制，提高了系统的容错能力。</p></li><li><p><strong>多种语言支持</strong></p><p>ROS支持多种编程语言。<strong>C++</strong>、<strong>Pyhton</strong>已经在ROS中实现编译，<strong>是目前应用最广的ROS开发语言</strong>，Lisp、C#、Java等语言的测试库也已经实现。为了支持多语言编程，ROS采用了一种语言中立的接口定义语言来实现各模块之间消息传送。通俗的理解就是，ROS的通信格式和用哪种编程语言来写无关，它使用的是自身定义的一套通信接口。</p></li><li><p><strong>开源社区</strong></p><p>ROS具有一个庞大的社区<a href="http://wiki.ros.org/">ROS WIKI</a>，这个网站将会始终伴随着你ROS开发，无论是查阅功能包的参数、搜索问题还是。当前使用ROS开发的软件包已经达到数千万个，相关的机器人已经多达上千款。此外，ROS遵从BSD协议，对个人和商业应用及修改完全免费。这也促进了ROS的流行。</p></li></ul><h2 id="14-ros优缺点"><a class="markdownIt-Anchor" href="#14-ros优缺点"></a> 1.4. ROS优缺点</h2><p>ROS为我们开发机器人带来了许多方便， 然而它也确实存在一些问题：</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>提供框架、 工具和功能</td><td>通信实时性能有限</td></tr><tr><td>方便移植</td><td>系统稳定性尚不满足工业级要求</td></tr><tr><td>庞大的用户群体</td><td>安全性上没有防护措施</td></tr><tr><td>免费开源</td><td>仅支持Linux(Ubuntu)</td></tr></tbody></table><p>总体来说， ROS更适合科研和开源用户使用， 如果在工业场景应用（ 例如无人驾驶） 还需要<br />做优化和定制。 为了解决实际应用的问题， ROS2.0做了很大的改进， 目前正在开发之中， 未<br />来表现如何值得期待。</p><h1 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2. 安装</h1><h1 id="3-编译"><a class="markdownIt-Anchor" href="#3-编译"></a> 3. 编译</h1><h2 id="31-catkin特点"><a class="markdownIt-Anchor" href="#31-catkin特点"></a> 3.1. Catkin特点</h2><p>Catkin是基于CMake的编译构建系统，具有以下特点：</p><ul><li>Catkin沿用了包管理的传统像 <code>find_package()</code>基础结构,<code>pkg-config</code></li><li>扩展了CMake，例如<ul><li>软件包编译后无需安装就可使用</li><li>自动生成<code>find_package()</code>代码，<code>pkg-config</code>文件</li><li>解决了多个软件包构建顺序问题</li></ul></li></ul><p>一个Catkin的软件包（package）必须要包括两个文件：</p><ul><li>package.xml: 包括了package的描述信息<ul><li>name, description, version, maintainer(s), license</li><li>opt. authors, url’s, dependencies, plugins, etc…</li></ul></li><li>CMakeLists.txt: 构建package所需的CMake文件<ul><li>调用Catkin的函数/宏</li><li>解析<code>package.xml</code></li><li>找到其他依赖的catkin软件包</li><li>将本软件包添加到环境变量</li></ul></li></ul><h2 id="32-catkin工作原理"><a class="markdownIt-Anchor" href="#32-catkin工作原理"></a> 3.2. Catkin工作原理</h2><p>catkin编译的工作流程如下：</p><ol><li>首先在工作空间<code>catkin_ws/src/</code>下递归的查找其中每一个ROS的package。</li><li>package中会有<code>package.xml</code>和<code>CMakeLists.txt</code>文件，Catkin(CMake)编译系统依据<code>CMakeLists.txt</code>文件,从而生成<code>makefiles</code>(放在<code>catkin_ws/build/</code>)。</li><li>然后<code>make</code>刚刚生成的<code>makefiles</code>等文件，编译链接生成可执行文件(放在<code>catkin_ws/devel</code>)。</li></ol><p>也就是说，Catkin就是将<code>cmake</code>与<code>make</code>指令做了一个封装从而完成整个编译过程的工具。catkin有比较突出的优点，主要是：</p><ul><li>操作更加简单</li><li>一次配置，多次使用</li><li>跨依赖项目编译</li></ul><h2 id="33-使用catkin_make进行编译"><a class="markdownIt-Anchor" href="#33-使用catkin_make进行编译"></a> 3.3. 使用<code>catkin_make</code>进行编译</h2><p>要用catkin编译一个工程或软件包，只需要用<code>catkin_make</code>指令。一般当我们写完代码，执行一次<code>catkin_make</code>进行编译,调用系统自动完成编译和链接过程，构建生成目标文件。编译的一般性流程如下，在1.5节我们编译ROS-Academy-for-Beginners教学包就是这样的流程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws <span class="comment">#回到工作空间,catkin_make必须在工作空间下执行</span></span><br><span class="line">$ catkin_make    <span class="comment">#开始编译</span></span><br><span class="line">$ <span class="built_in">source</span> ~/catkin_ws/devel/setup.bash <span class="comment">#刷新坏境</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> catkin编译之前需要回到工作空间目录，<code>catkin_make</code>在其他路径下编译不会成功。编译完成后，如果有新的目标文件产生（原来没有），那么一般紧跟着要source刷新环境，使得系统能够找到刚才编译生成的ROS可执行文件。这个细节比较容易遗漏，致使后面出现可执行文件无法打开等错误。</p><p><code>catkin_make</code>命令也有一些可选参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">catkin_make [args]</span><br><span class="line">  -h, --help            帮助信息</span><br><span class="line">  -C DIRECTORY, --directory DIRECTORY</span><br><span class="line">                        工作空间的路径 (默认为 &#x27;.&#x27;)</span><br><span class="line">  --source SOURCE       src的路径 (默认为&#x27;workspace_base/src&#x27;)</span><br><span class="line">  --build BUILD         build的路径 (默认为&#x27;workspace_base/build&#x27;)</span><br><span class="line">  --use-ninja           用ninja取代make</span><br><span class="line">  --use-nmake           用nmake取&#x27;make</span><br><span class="line">  --force-cmake         强制cmake，即使已经cmake过</span><br><span class="line">  --no-color            禁止彩色输出(只对catkin_make和CMake生效)</span><br><span class="line">  --pkg PKG [PKG ...]   只对某个PKG进行make</span><br><span class="line">  --only-pkg-with-deps  ONLY_PKG_WITH_DEPS [ONLY_PKG_WITH_DEPS ...]</span><br><span class="line">                        将指定的package列入白名单CATKIN_WHITELIST_PACKAGES，</span><br><span class="line">                        之编译白名单里的package。该环境变量存在于CMakeCache.txt。</span><br><span class="line">  --cmake-args [CMAKE_ARGS [CMAKE_ARGS ...]]</span><br><span class="line">                        传给CMake的参数</span><br><span class="line">  --make-args [MAKE_ARGS [MAKE_ARGS ...]]</span><br><span class="line">                        传给Make的参数</span><br><span class="line">  --override-build-tool-check</span><br><span class="line">                        用来覆盖由于不同编译工具产生的错误</span><br></pre></td></tr></table></figure><h1 id="4-catkin工作空间"><a class="markdownIt-Anchor" href="#4-catkin工作空间"></a> 4. Catkin工作空间</h1><p>Catkin工作空间是创建、修改、编译catkin软件包的目录。catkin的工作空间，直观的形容就是一个仓库，里面装载着ROS的各种项目工程，便于系统组织管理调用。在可视化图形界面里是一个文件夹。我们自己写的ROS代码通常就放在工作空间中，本节就来介绍catkin工作空间的结构。</p><h2 id="41-catkin工作空间结构"><a class="markdownIt-Anchor" href="#41-catkin工作空间结构"></a> 4.1. Catkin工作空间结构</h2><p>catkin的结构十分清晰，具体的catkin工作空间结构图如下。初看起来catkin工作空间看起来极其复杂，其实不然，catkin工作空间的结构其实非常清晰。</p><p>在工作空间下用tree命令，显示文件结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">$ sudo apt install tree</span><br><span class="line">$ tree</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">─ build</span><br><span class="line">│   ├── catkin</span><br><span class="line">│   │   └── catkin_generated</span><br><span class="line">│   │       └── version</span><br><span class="line">│   │           └── package.cmake</span><br><span class="line">│   ├──</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">│   ├── catkin_make.cache</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   │   ├──</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">├── devel</span><br><span class="line">│   ├── env.sh</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── setup.bash</span><br><span class="line">│   ├── setup.sh</span><br><span class="line">│   ├── _setup_util.py</span><br><span class="line">│   └── setup.zsh</span><br><span class="line">└── src</span><br><span class="line">└── CMakeLists.txt -&gt; /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake</span><br></pre></td></tr></table></figure><p>通过tree命令可以看到catkin工作空间的结构,它包括了<code>src</code>、<code>build</code>、<code>devel</code>三个路径，在有些编译选项下也可能包括其他。但这三个文件夹是catkin编译系统默认的。它们的具体作用如下：</p><ul><li>src/: ROS的catkin软件包（源代码包）</li><li>build/: catkin（CMake）的缓存信息和中间文件</li><li>devel/: 生成的目标文件（包括头文件，动态链接库，静态链接库，可执行文件等）、环境变量</li></ul><p>在编译过程中，它们的工作流程如图：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/catkin_flow.jpg" alt="img" /></p><p>后两个路径由catkin系统自动生成、管理，我们日常的开发一般不会去涉及，而主要用到的是src文件夹，我们写的ROS程序、网上下载的ROS源代码包都存放在这里。</p><p>在编译时，catkin编译系统会<strong>递归</strong>的查找和编译<code>src/</code>下的每一个源代码包。因此你也可以把几个源代码包放到同一个文件夹下，如下图所示：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/catkin_ws.jpg" alt="img" /></p><h2 id="42-小结"><a class="markdownIt-Anchor" href="#42-小结"></a> 4.2. 小结</h2><p>catkin工作空间基本就是以上的结构，package是catkin工作空间的<strong>基本单元</strong>，我们在ROS开发时，写好代码，然后catkin_make，系统就会完成所有编译构建的工作。至于更详细的package内容，我们将在下节继续介绍。</p><h1 id="5-package软件包"><a class="markdownIt-Anchor" href="#5-package软件包"></a> 5. Package软件包</h1><p>我们调用<code>catkin_make</code>编译的对象就是一个个ROS的package，也就是说任何ROS程序只有组织成package才能编译。所以package也是ROS源代码存放的地方，任何ROS的代码无论是C++还是Python都要放到package中，这样才能正常的编译和运行。<br />一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等）。</p><h2 id="51-package结构"><a class="markdownIt-Anchor" href="#51-package结构"></a> 5.1. package结构</h2><p>一个package下常见的文件、路径有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt    #package的编译规则(必须)</span><br><span class="line">├── package.xml       #package的描述信息(必须)</span><br><span class="line">├── src/              #源代码文件</span><br><span class="line">├── include/          #C++头文件</span><br><span class="line">├── scripts/          #可执行脚本</span><br><span class="line">├── msg/              #自定义消息</span><br><span class="line">├── srv/              #自定义服务</span><br><span class="line">├── models/           #3D模型文件</span><br><span class="line">├── urdf/             #urdf文件</span><br><span class="line">├── launch/           #launch文件</span><br></pre></td></tr></table></figure><p>其中定义package的是<code>CMakeLists.txt</code>和<code>package.xml</code>，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件。这两个文件就定义了一个package。</p><ul><li>CMakeLists.txt: 定义package的包名、依赖、源文件、目标文件等编译规则，是package不可少的成分</li><li>package.xml: 描述package的包名、版本号、作者、依赖等信息，是package不可少的成分</li><li>src/: 存放ROS的源代码，包括C++的源码和(.cpp)以及Python的module(.py)</li><li>include/: 存放C++源码对应的头文件</li><li>scripts/: 存放可执行脚本，例如shell脚本(.sh)、Python脚本(.py)</li><li>msg/: 存放自定义格式的消息(.msg)</li><li>srv/: 存放自定义格式的服务(.srv)</li><li>models/: 存放机器人或仿真场景的3D模型(.sda, .stl, .dae等)</li><li>urdf/: 存放机器人的模型描述(.urdf或.xacro)</li><li>launch/: 存放launch文件(.launch或.xml)</li></ul><p>通常ROS文件组织都是按照以上的形式，这是约定俗成的命名习惯，建议遵守。以上路径中，只有<code>CMakeLists.txt</code>和<code>package.xml</code>是必须的，其余路径根据软件包是否需要来决定。</p><h2 id="52-package的创建"><a class="markdownIt-Anchor" href="#52-package的创建"></a> 5.2. package的创建</h2><p>创建一个package需要在<code>catkin_ws/src</code>下,用到<code>catkin_create_pkg</code>命令，用法是：<br /><code>catkin_create_pkg package depends</code><br />其中package是包名，depends是依赖的包名，可以依赖多个软件包。</p><p>例如，新建一个package叫做<code>test_pkg</code>,依赖roscpp、rospy、std_msgs(常用依赖)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_create_pkg test_pkg roscpp rospy std_msgs</span><br></pre></td></tr></table></figure><p>这样就会在当前路径下新建<code>test_pkg</code>软件包，包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── test_pkg</span><br><span class="line">├── package.xml</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure><p><code>catkin_create_pkg</code>帮你完成了软件包的初始化，填充好了<code>CMakeLists.txt</code>和<code>package.xml</code>，并且将依赖项填进了这两个文件中。</p><h2 id="53-package相关命令"><a class="markdownIt-Anchor" href="#53-package相关命令"></a> 5.3. package相关命令</h2><h3 id="531-rospack"><a class="markdownIt-Anchor" href="#531-rospack"></a> 5.3.1. rospack</h3><p>rospack是对package管理的工具，命令的用法如下：</p><table><thead><tr><th style="text-align:center">rostopic命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rospack help</code></td><td style="text-align:center">显示rospack的用法</td></tr><tr><td style="text-align:center"><code>rospack list</code></td><td style="text-align:center">列出本机所有package</td></tr><tr><td style="text-align:center"><code>rospack depends [package]</code></td><td style="text-align:center">显示package的依赖包</td></tr><tr><td style="text-align:center"><code>rospack find [package]</code></td><td style="text-align:center">定位某个package</td></tr><tr><td style="text-align:center"><code>rospack profile</code></td><td style="text-align:center">刷新所有package的位置记录</td></tr></tbody></table><p>以上命令如果package缺省，则默认为当前目录(如果当前目录包含package.xml)</p><h3 id="532-roscd"><a class="markdownIt-Anchor" href="#532-roscd"></a> 5.3.2. roscd</h3><p><code>roscd</code>命令类似与Linux系统的<code>cd</code>，改进之处在于<code>roscd</code>可以直接<code>cd</code>到ROS的软件包。</p><table><thead><tr><th style="text-align:center">rostopic命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>roscd [pacakge]</code></td><td style="text-align:center">cd到ROS package所在路径</td></tr></tbody></table><h3 id="533-rosls"><a class="markdownIt-Anchor" href="#533-rosls"></a> 5.3.3. rosls</h3><p><code>rosls</code>也可以视为Linux指令<code>ls</code>的改进版，可以直接<code>ls</code>ROS软件包的内容。</p><table><thead><tr><th style="text-align:center">rosls命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosls [pacakge]</code></td><td style="text-align:center">列出pacakge下的文件</td></tr></tbody></table><h3 id="534-rosdep"><a class="markdownIt-Anchor" href="#534-rosdep"></a> 5.3.4. rosdep</h3><p><code>rosdep</code>是用于管理ROS package依赖项的命令行工具，用法如下：</p><table><thead><tr><th style="text-align:center">rosdep命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosdep check [pacakge]</code></td><td style="text-align:center">检查package的依赖是否满足</td></tr><tr><td style="text-align:center"><code>rosdep install [pacakge]</code></td><td style="text-align:center">安装pacakge的依赖</td></tr><tr><td style="text-align:center"><code>rosdep db</code></td><td style="text-align:center">生成和显示依赖数据库</td></tr><tr><td style="text-align:center"><code>rosdep init</code></td><td style="text-align:center">初始化/etc/ros/rosdep中的源</td></tr><tr><td style="text-align:center"><code>rosdep keys</code></td><td style="text-align:center">检查package的依赖是否满足</td></tr><tr><td style="text-align:center"><code>rosdep update</code></td><td style="text-align:center">更新本地的rosdep数据库</td></tr></tbody></table><p>一个较常使用的命令是<code>rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y</code>,用于安装工作空间中<code>src</code>路径下所有package的依赖项（由pacakge.xml文件指定）。</p><h1 id="6-cmakeliststxt"><a class="markdownIt-Anchor" href="#6-cmakeliststxt"></a> 6. CMakeLists.txt</h1><h2 id="61-cmakeliststxt作用"><a class="markdownIt-Anchor" href="#61-cmakeliststxt作用"></a> 6.1. CMakeLists.txt作用</h2><p><code>CMakeLists.txt</code>原本是Cmake编译系统的规则文件，而Catkin编译系统基本沿用了CMake的编译风格，只是针对ROS工程添加了一些宏定义。所以在写法上，catkin的<code>CMakeLists.txt</code>与CMake的基本一致。</p><p>这个文件直接规定了这个package要依赖哪些package，要编译生成哪些目标，如何编译等等流程。所以<code>CMakeLists.txt</code>非常重要，它指定了由源码到目标文件的规则，catkin编译系统在工作时首先会找到每个package下的<code>CMakeLists.txt</code>，然后按照规则来编译构建。</p><h2 id="62-cmakeliststxt写法"><a class="markdownIt-Anchor" href="#62-cmakeliststxt写法"></a> 6.2. CMakeLists.txt写法</h2><p><code>CMakeLists.txt</code>的基本语法都还是按照CMake，而Catkin在其中加入了少量的宏，总体的结构如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>() <span class="comment">#CMake的版本号 </span></span><br><span class="line"><span class="keyword">project</span>()                <span class="comment">#项目名称 </span></span><br><span class="line"><span class="keyword">find_package</span>()           <span class="comment">#找到编译需要的其他CMake/Catkin package</span></span><br><span class="line">catkin_python_setup()    <span class="comment">#catkin新加宏，打开catkin的Python Module的支持</span></span><br><span class="line">add_message_files()      <span class="comment">#catkin新加宏，添加自定义Message/Service/Action文件</span></span><br><span class="line">add_service_files()</span><br><span class="line">add_action_files()</span><br><span class="line">generate_message()       <span class="comment">#catkin新加宏，生成不同语言版本的msg/srv/action接口</span></span><br><span class="line">catkin_package()         <span class="comment">#catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用</span></span><br><span class="line"><span class="keyword">add_library</span>()            <span class="comment">#生成库</span></span><br><span class="line"><span class="keyword">add_executable</span>()         <span class="comment">#生成可执行二进制文件</span></span><br><span class="line"><span class="keyword">add_dependencies</span>()       <span class="comment">#定义目标文件依赖于其他目标文件，确保其他目标已被构建</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>()  <span class="comment">#链接</span></span><br><span class="line">catkin_add_gtest()       <span class="comment">#catkin新加宏，生成测试</span></span><br><span class="line"><span class="keyword">install</span>()                <span class="comment">#安装至本机</span></span><br></pre></td></tr></table></figure><p>如果你从未接触过CMake的语法，请阅读《CMake实践》：<a href="https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf">https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf</a> 。掌握CMake语法对于理解ROS工程很有帮助。</p><h1 id="7-packagexml"><a class="markdownIt-Anchor" href="#7-packagexml"></a> 7. package.xml</h1><p><code>package.xml</code>也是一个catkin的package必备文件，它是这个软件包的描述文件，在较早的ROS版本(rosbuild编译系统)中，这个文件叫做<code>manifest.xml</code>，用于描述pacakge的基本信息。如果你在网上看到一些ROS项目里包含着<code>manifest.xml</code>，那么它多半是hydro版本之前的项目了。</p><h2 id="71-packagexml作用"><a class="markdownIt-Anchor" href="#71-packagexml作用"></a> 7.1. package.xml作用</h2><p><code>pacakge.xml</code>包含了package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。<br />实际上<code>rospack find</code>、<code>rosdep</code>等命令之所以能快速定位和分析出package的依赖项信息，就是直接读取了每一个pacakge中的<code>package.xml</code>文件。它为用户提供了快速了解一个pacakge的渠道。</p><h2 id="72-packagexml写法"><a class="markdownIt-Anchor" href="#72-packagexml写法"></a> 7.2. package.xml写法</h2><p><code>pacakge.xml</code>遵循xml标签文本的写法，由于版本更迭原因，现在有两种格式并存（format1与format2），不过区别不大。老版本（format1）的<code>pacakge.xml</code>通常包含以下标签:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pacakge</span>&gt;</span>           根标记文件  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>              包名  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>           版本号  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>       内容描述  </span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span>&gt;</span>        维护者 </span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>           软件许可证  </span><br><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>  编译构建工具，通常为catkin  </span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>      编译依赖项，与Catkin中的  </span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>        运行依赖项</span><br></pre></td></tr></table></figure><p>说明：其中1-6为必备标签，1是根标签，嵌套了其余的所有标签，2-6为包的各种属性，7-9为编译相关信息。</p><p>在新版本（format2）中，包含的标签为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pacakge</span>&gt;</span>               根标记文件  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>                  包名  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>               版本号  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>           内容描述  </span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span>&gt;</span>            维护者 </span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>               软件许可证  </span><br><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>      编译构建工具，通常为catkin    </span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>                指定依赖项为编译、导出、运行需要的依赖，最常用</span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>          编译依赖项  </span><br><span class="line"><span class="tag">&lt;<span class="name">build_export_depend</span>&gt;</span>   导出依赖项</span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>           运行依赖项</span><br><span class="line"><span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>           测试用例依赖项  </span><br><span class="line"><span class="tag">&lt;<span class="name">doc_depend</span>&gt;</span>            文档依赖项</span><br></pre></td></tr></table></figure><p>由此看见新版本的<code>pacakge.xml</code>格式上增加了 、、、 ,相当于将之前的build和run依赖项描述进行了细分。</p><p>目前Indigo、Kinetic、Lunar等版本的ROS都同时支持两种版本的<code>package.xml</code>，所以无论选哪种格式都可以。</p><h2 id="73-pacakgexml例子"><a class="markdownIt-Anchor" href="#73-pacakgexml例子"></a> 7.3. pacakge.xml例子</h2><p>为了说明pacakge.xml写法，还是以turtlesim软件包为例，其<code>pacakge.xml</code>文件内容如下，我们添加了相关的注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span>       <span class="comment">&lt;!--本示例为老版本的pacakge.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span>                   <span class="comment">&lt;!--pacakge为根标签，写在最外面--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>turtlesim<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">    turtlesim is a tool made for teaching ROS and ROS packages.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;dthomas@osrfoundation.org&quot;</span>&gt;</span>Dirk Thomas<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;website&quot;</span>&gt;</span>http://www.ros.org/wiki/turtlesim<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;bugtracker&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials/issues<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;repository&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Josh Faust<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--编译工具为catkin--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--编译时需要依赖以下包--&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>geometry_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qtbase5-dev<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qt5-qmake<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosconsole<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp_serialization<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roslib<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rostime<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_srvs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--运行时需要依赖以下包--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>geometry_msgs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt5-core<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt5-gui<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>rosconsole<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roscpp_serialization<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roslib<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>rostime<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>std_srvs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上内容是老版本（format1）的写法，如果要写成新版本（format2）则可以改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;2&quot;</span>&gt;</span>      <span class="comment">&lt;!--在声明pacakge时指定format2，为新版格式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>turtlesim<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">    turtlesim is a tool made for teaching ROS and ROS packages.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;dthomas@osrfoundation.org&quot;</span>&gt;</span>Dirk Thomas<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;website&quot;</span>&gt;</span>http://www.ros.org/wiki/turtlesim<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;bugtracker&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials/issues<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;repository&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Josh Faust<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--编译工具为catkin--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--用depend来整合build_depend和run_depend--&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>geometry_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rosconsole<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>roscpp_serialization<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>roslib<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rostime<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_srvs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--build_depend标签未变--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qtbase5-dev<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qt5-qmake<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--run_depend要改为exec_depend--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>libqt5-core<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>libqt5-gui<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="8-metapackage"><a class="markdownIt-Anchor" href="#8-metapackage"></a> 8. Metapackage</h1><h2 id="81-metapackage介绍"><a class="markdownIt-Anchor" href="#81-metapackage介绍"></a> 8.1. Metapackage介绍</h2><p>在一些ROS的教学资料和博客里，你可能还会看到一个Stack（功能包集）的概念，它指的是将多个功能接近、甚至相互依赖的软件包的放到一个集合中去。但Stack这个概念在Hydro之后就取消了，取而代之的就是Metapackage。尽管换了个马甲，但它的作用没变，都是把一些相近的功能模块、软件包放到一起。</p><p>ROS里常见的Metapacakge有：</p><table><thead><tr><th style="text-align:center">Metapacakge名称</th><th style="text-align:center">描述</th><th style="text-align:center">链接</th></tr></thead><tbody><tr><td style="text-align:center">navigation</td><td style="text-align:center">导航相关的功能包集</td><td style="text-align:center"><a href="https://github.com/ros-planning/navigation">https://github.com/ros-planning/navigation</a></td></tr><tr><td style="text-align:center">moveit</td><td style="text-align:center">运动规划相关的（主要是机械臂）功能包集</td><td style="text-align:center"><a href="https://github.com/ros-planning/moveit">https://github.com/ros-planning/moveit</a></td></tr><tr><td style="text-align:center">image_pipeline</td><td style="text-align:center">图像获取、处理相关的功能包集</td><td style="text-align:center"><a href="https://github.com/ros-perception/image_common">https://github.com/ros-perception/image_common</a></td></tr><tr><td style="text-align:center">vision_opencv</td><td style="text-align:center">ROS与OpenCV交互的功能包集</td><td style="text-align:center"><a href="https://github.com/ros-perception/vision_opencv">https://github.com/ros-perception/vision_opencv</a></td></tr><tr><td style="text-align:center">turtlebot</td><td style="text-align:center">Turtlebot机器人相关的功能包集</td><td style="text-align:center"><a href="https://github.com/turtlebot/turtlebot">https://github.com/turtlebot/turtlebot</a></td></tr><tr><td style="text-align:center">pr2_robot</td><td style="text-align:center">pr2机器人驱动功能包集</td><td style="text-align:center"><a href="https://github.com/PR2/pr2_robot">https://github.com/PR2/pr2_robot</a></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>以上列举了一些常见的功能包集，例如navigation、turtlebot，他们都是用于某一方面的功能，以navigation metapackage（官方介绍里仍然沿用stack的叫法）为例，它包括了以下软件包：</p><table><thead><tr><th style="text-align:center">包名</th><th style="text-align:center">功能</th><th></th></tr></thead><tbody><tr><td style="text-align:center">navigation</td><td style="text-align:center">Metapacakge，依赖以下所有pacakge</td><td></td></tr><tr><td style="text-align:center">amcl</td><td style="text-align:center">定位</td><td></td></tr><tr><td style="text-align:center">fake_localization</td><td style="text-align:center">定位</td><td></td></tr><tr><td style="text-align:center">map_server</td><td style="text-align:center">提供地图</td><td></td></tr><tr><td style="text-align:center">move_base</td><td style="text-align:center">路径规划节点</td><td></td></tr><tr><td style="text-align:center">nav_core</td><td style="text-align:center">路径规划的接口类</td><td></td></tr><tr><td style="text-align:center">base_local_planner</td><td style="text-align:center">局部规划</td><td></td></tr><tr><td style="text-align:center">dwa_local_planner</td><td style="text-align:center">局部规划</td><td></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td>…</td></tr></tbody></table><p>具体功能介绍，我们留到第九章，这里只看一个软件包navigation。这个navigation就是一个简单的pacakge，里面只有几个文件，但由于它依赖了其他所有的软件包。Catkin编译系统会明白，这些软件包都属于navigation metapacakge。</p><p>这个道理并不难理解，比如我们在安装ROS时，用到了<code>sudo apt-get install ros-kinetic-desktop-full</code>命令，由于它依赖了ROS所有的核心组件，我们在安装时也就能够安装整个ROS。</p><h2 id="82-metapackage写法"><a class="markdownIt-Anchor" href="#82-metapackage写法"></a> 8.2. Metapackage写法</h2><p>我们以ROS-Academy-for-beginners为例介绍meteapckage的写法，在教学包内，有一个<code>ros-academy-for-beginners</code>软件包，该包即为一个metapacakge，其中有且仅有两个文件：<code>CMakeLists.txt</code>和<code>pacakge.xml</code>。</p><p><code>CMakeLists.txt</code>写法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(ros_academy_for_beginners)</span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED)</span><br><span class="line">catkin_metapackage()   <span class="comment">#声明本软件包是一个metapacakge</span></span><br></pre></td></tr></table></figure><p><code>pacakge.xml</code>写法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>ros_academy_for_beginners<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>17.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">        --------------------------------------------------------------------------</span><br><span class="line">        A ROS tutorial for beginner level learners. This metapacakge includes some</span><br><span class="line">        demos of topic, service, parameter server, tf, urdf, navigation, SLAM...</span><br><span class="line">        It tries to explain the basic concepts and usages of ROS.</span><br><span class="line">        --------------------------------------------------------------------------</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;chaichangkun@163.com&quot;</span>&gt;</span>Chai Changkun<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Chai Changkun<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://http://www.droid.ac.cn<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>navigation_sim_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span>  <span class="comment">&lt;!--注意这里的run_depend标签，将其他软件包都设为依赖项--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>param_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>robot_sim_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>service_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>slam_sim_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>tf_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>topic_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">export</span>&gt;</span>    <span class="comment">&lt;!--这里需要有export和metapacakge标签，注意这种固定写法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">metapackage</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>metapacakge中的以上两个文件和普通pacakge不同点是：</p><ul><li><code>CMakeLists.txt</code>:加入了catkin_metapackage()宏，指定本软件包为一个metapacakge。</li><li><code>package.xml</code>:标签将所有软件包列为依赖项，标签中添加标签声明。</li></ul><p>metapacakge在我们实际开发一个大工程时可能有用</p><h1 id="9-其他常见文件类型"><a class="markdownIt-Anchor" href="#9-其他常见文件类型"></a> 9. 其他常见文件类型</h1><p>在ROS的pacakge中，还有其他许多常见的文件类型，这里做个总结。</p><h2 id="91-launch文件"><a class="markdownIt-Anchor" href="#91-launch文件"></a> 9.1. launch文件</h2><p>launch文件一般以.launch或.xml结尾，它对ROS需要运行程序进行了打包，通过一句命令来启动。一般launch文件中会指定要启动哪些package下的哪些可执行程序，指定以什么参数启动，以及一些管理控制的命令。 launch文件通常放在软件包的<code>launch/</code>路径中中。 launch文件的具体写法见3.2节。</p><h2 id="92-msgsrvaction文件"><a class="markdownIt-Anchor" href="#92-msgsrvaction文件"></a> 9.2. msg/srv/action文件</h2><p>ROS程序中有可能有一些自定义的消息/服务/动作文件，为程序的发者所设计的数据结构，这类的文件以<code>.msg</code>,<code>.srv</code>,<code>.action</code>结尾，通常放在package的<code>msg/</code>,<code>srv/</code>,<code>action/</code>路径下。</p><p>msg文件写法见3.4节，srv文件写法见3.6节。</p><h2 id="93-urdfxacro文件"><a class="markdownIt-Anchor" href="#93-urdfxacro文件"></a> 9.3. urdf/xacro文件</h2><p>urdf/xacro文件是机器人模型的描述文件，以.urdf或.xacro结尾。它定义了机器人的连杆和关节的信息，以及它们之间的位置、角度等信息，通过urdf文件可以将机器人的物理连接信息表示出来。并在可视化调试和仿真中显示。</p><p>urdf文件的写法见第七章。</p><h2 id="94-yaml文件"><a class="markdownIt-Anchor" href="#94-yaml文件"></a> 9.4. yaml文件</h2><p>yaml文件一般存储了ROS需要加载的参数信息，一些属性的配置。通常在launch文件或程序中读取.yaml文件，把参数加载到参数服务器上。通常我们会把yaml文件存放在<code>param/</code>路径下</p><h2 id="95-daestl文件"><a class="markdownIt-Anchor" href="#95-daestl文件"></a> 9.5. dae/stl文件</h2><p>dae或stl文件是3D模型文件，机器人的urdf或仿真环境通常会引用这类文件，它们描述了机器人的三维模型。相比urdf文件简单定义的性状，dae/stl文件可以定义复杂的模型，可以直接从solidworks或其他建模软件导出机器人装配模型，从而显示出更加精确的外形。</p><h2 id="96-rviz文件"><a class="markdownIt-Anchor" href="#96-rviz文件"></a> 9.6. rviz文件</h2><p>rviz文件本质上是固定格式的文本文件，其中存储了RViz窗口的配置（显示哪些控件、视角、参数）。通常rviz文件不需要我们去手动修改，而是直接在RViz工具里保存，下次运行时直接读取。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ROS分析与文件结构</title>
      <link href="/posts/a7b9ea4b.html"/>
      <url>/posts/a7b9ea4b.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-robot-operating-system"><a class="markdownIt-Anchor" href="#1-robot-operating-system"></a> 1. Robot Operating System</h1><h2 id="11-简介"><a class="markdownIt-Anchor" href="#11-简介"></a> 1.1. 简介</h2><p>ROS是一个适用于机器人编程的<strong>框架</strong>，这个框架把原本松散的零部件耦合在了一起，为他们提供了<strong>通信架构</strong>。ROS虽然叫做<strong>操作系统</strong>，但并非Windows、Mac那样通常意义的操作系统，它只是连接了操作系统和你开发的ROS应用程序，所以它也算是一个<strong>中间件</strong>，基于ROS的应用程序之间建立起了沟通的桥梁，所以也是运行在Linux上的<strong>运行时环境</strong>，在这个环境上，机器人的感知、决策、控制算法可以更好的组织和运行。</p><p>以上几个关键词（框架、中间件、操作系统、运行时环境）都可以用来描述ROS的特性，作为初学者我们不必深究这些概念，随着你越来越多的使用ROS，就能够体会到它的作用。</p><h2 id="12-历代ros版本"><a class="markdownIt-Anchor" href="#12-历代ros版本"></a> 1.2. 历代ROS版本</h2><p>ROS1.0版本发布于2010年， 基于PR2机器人开发了一系列机器人相关的基础软件包。 随后<br />ROS版本迭代频繁， 目前已经发布到了Lunar。 目前使用人数最多的是Kinetic和Indigo这两个<br />Long Term Support版本。</p><table><thead><tr><th>ROS版本</th><th>发布时间</th></tr></thead><tbody><tr><td>Lunar Loggerhead</td><td>2017.5</td></tr><tr><td>Kinetic Kame</td><td>2016.5</td></tr><tr><td>Jade Turtle</td><td>2015.5</td></tr><tr><td>Indigo lgloo</td><td>2014.7</td></tr><tr><td>Hydro Medusa</td><td>2013.9</td></tr><tr><td>Groovy Galapagos</td><td>2012.12</td></tr><tr><td>Fuerte Turtle</td><td>2012.4</td></tr><tr><td>Electric Emys</td><td>2011.8</td></tr><tr><td>Diamondback</td><td>2011.3</td></tr><tr><td>C Turtle</td><td>2010.8</td></tr><tr><td>Box TurtleBox Turtle</td><td>2010.3</td></tr></tbody></table><h2 id="13-ros特点"><a class="markdownIt-Anchor" href="#13-ros特点"></a> 1.3. ROS特点</h2><p>ROS具有这些特点：</p><ul><li><p><strong>分布式 点对点</strong></p><p>ROS采用了分布式的框架，通过点对点的设计让机器人的进程可以分别运行，便于模块化的修改和定制，提高了系统的容错能力。</p></li><li><p><strong>多种语言支持</strong></p><p>ROS支持多种编程语言。<strong>C++</strong>、<strong>Pyhton</strong>已经在ROS中实现编译，<strong>是目前应用最广的ROS开发语言</strong>，Lisp、C#、Java等语言的测试库也已经实现。为了支持多语言编程，ROS采用了一种语言中立的接口定义语言来实现各模块之间消息传送。通俗的理解就是，ROS的通信格式和用哪种编程语言来写无关，它使用的是自身定义的一套通信接口。</p></li><li><p><strong>开源社区</strong></p><p>ROS具有一个庞大的社区<a href="http://wiki.ros.org/">ROS WIKI</a>，这个网站将会始终伴随着你ROS开发，无论是查阅功能包的参数、搜索问题还是。当前使用ROS开发的软件包已经达到数千万个，相关的机器人已经多达上千款。此外，ROS遵从BSD协议，对个人和商业应用及修改完全免费。这也促进了ROS的流行。</p></li></ul><h2 id="14-ros优缺点"><a class="markdownIt-Anchor" href="#14-ros优缺点"></a> 1.4. ROS优缺点</h2><p>ROS为我们开发机器人带来了许多方便， 然而它也确实存在一些问题：</p><table><thead><tr><th>优点</th><th>缺点</th></tr></thead><tbody><tr><td>提供框架、 工具和功能</td><td>通信实时性能有限</td></tr><tr><td>方便移植</td><td>系统稳定性尚不满足工业级要求</td></tr><tr><td>庞大的用户群体</td><td>安全性上没有防护措施</td></tr><tr><td>免费开源</td><td>仅支持Linux(Ubuntu)</td></tr></tbody></table><p>总体来说， ROS更适合科研和开源用户使用， 如果在工业场景应用（ 例如无人驾驶） 还需要<br />做优化和定制。 为了解决实际应用的问题， ROS2.0做了很大的改进， 目前正在开发之中， 未<br />来表现如何值得期待。</p><h1 id="2-安装"><a class="markdownIt-Anchor" href="#2-安装"></a> 2. 安装</h1><h1 id="3-编译"><a class="markdownIt-Anchor" href="#3-编译"></a> 3. 编译</h1><h2 id="31-catkin特点"><a class="markdownIt-Anchor" href="#31-catkin特点"></a> 3.1. Catkin特点</h2><p>Catkin是基于CMake的编译构建系统，具有以下特点：</p><ul><li>Catkin沿用了包管理的传统像 <code>find_package()</code>基础结构,<code>pkg-config</code></li><li>扩展了CMake，例如<ul><li>软件包编译后无需安装就可使用</li><li>自动生成<code>find_package()</code>代码，<code>pkg-config</code>文件</li><li>解决了多个软件包构建顺序问题</li></ul></li></ul><p>一个Catkin的软件包（package）必须要包括两个文件：</p><ul><li>package.xml: 包括了package的描述信息<ul><li>name, description, version, maintainer(s), license</li><li>opt. authors, url’s, dependencies, plugins, etc…</li></ul></li><li>CMakeLists.txt: 构建package所需的CMake文件<ul><li>调用Catkin的函数/宏</li><li>解析<code>package.xml</code></li><li>找到其他依赖的catkin软件包</li><li>将本软件包添加到环境变量</li></ul></li></ul><h2 id="32-catkin工作原理"><a class="markdownIt-Anchor" href="#32-catkin工作原理"></a> 3.2. Catkin工作原理</h2><p>catkin编译的工作流程如下：</p><ol><li>首先在工作空间<code>catkin_ws/src/</code>下递归的查找其中每一个ROS的package。</li><li>package中会有<code>package.xml</code>和<code>CMakeLists.txt</code>文件，Catkin(CMake)编译系统依据<code>CMakeLists.txt</code>文件,从而生成<code>makefiles</code>(放在<code>catkin_ws/build/</code>)。</li><li>然后<code>make</code>刚刚生成的<code>makefiles</code>等文件，编译链接生成可执行文件(放在<code>catkin_ws/devel</code>)。</li></ol><p>也就是说，Catkin就是将<code>cmake</code>与<code>make</code>指令做了一个封装从而完成整个编译过程的工具。catkin有比较突出的优点，主要是：</p><ul><li>操作更加简单</li><li>一次配置，多次使用</li><li>跨依赖项目编译</li></ul><h2 id="33-使用catkin_make进行编译"><a class="markdownIt-Anchor" href="#33-使用catkin_make进行编译"></a> 3.3. 使用<code>catkin_make</code>进行编译</h2><p>要用catkin编译一个工程或软件包，只需要用<code>catkin_make</code>指令。一般当我们写完代码，执行一次<code>catkin_make</code>进行编译,调用系统自动完成编译和链接过程，构建生成目标文件。编译的一般性流程如下，在1.5节我们编译ROS-Academy-for-Beginners教学包就是这样的流程。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws <span class="comment">#回到工作空间,catkin_make必须在工作空间下执行</span></span><br><span class="line">$ catkin_make    <span class="comment">#开始编译</span></span><br><span class="line">$ <span class="built_in">source</span> ~/catkin_ws/devel/setup.bash <span class="comment">#刷新坏境</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> catkin编译之前需要回到工作空间目录，<code>catkin_make</code>在其他路径下编译不会成功。编译完成后，如果有新的目标文件产生（原来没有），那么一般紧跟着要source刷新环境，使得系统能够找到刚才编译生成的ROS可执行文件。这个细节比较容易遗漏，致使后面出现可执行文件无法打开等错误。</p><p><code>catkin_make</code>命令也有一些可选参数，例如：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">catkin_make [args]</span><br><span class="line">  -h, --help            帮助信息</span><br><span class="line">  -C DIRECTORY, --directory DIRECTORY</span><br><span class="line">                        工作空间的路径 (默认为 &#x27;.&#x27;)</span><br><span class="line">  --source SOURCE       src的路径 (默认为&#x27;workspace_base/src&#x27;)</span><br><span class="line">  --build BUILD         build的路径 (默认为&#x27;workspace_base/build&#x27;)</span><br><span class="line">  --use-ninja           用ninja取代make</span><br><span class="line">  --use-nmake           用nmake取&#x27;make</span><br><span class="line">  --force-cmake         强制cmake，即使已经cmake过</span><br><span class="line">  --no-color            禁止彩色输出(只对catkin_make和CMake生效)</span><br><span class="line">  --pkg PKG [PKG ...]   只对某个PKG进行make</span><br><span class="line">  --only-pkg-with-deps  ONLY_PKG_WITH_DEPS [ONLY_PKG_WITH_DEPS ...]</span><br><span class="line">                        将指定的package列入白名单CATKIN_WHITELIST_PACKAGES，</span><br><span class="line">                        之编译白名单里的package。该环境变量存在于CMakeCache.txt。</span><br><span class="line">  --cmake-args [CMAKE_ARGS [CMAKE_ARGS ...]]</span><br><span class="line">                        传给CMake的参数</span><br><span class="line">  --make-args [MAKE_ARGS [MAKE_ARGS ...]]</span><br><span class="line">                        传给Make的参数</span><br><span class="line">  --override-build-tool-check</span><br><span class="line">                        用来覆盖由于不同编译工具产生的错误</span><br></pre></td></tr></table></figure><h1 id="4-catkin工作空间"><a class="markdownIt-Anchor" href="#4-catkin工作空间"></a> 4. Catkin工作空间</h1><p>Catkin工作空间是创建、修改、编译catkin软件包的目录。catkin的工作空间，直观的形容就是一个仓库，里面装载着ROS的各种项目工程，便于系统组织管理调用。在可视化图形界面里是一个文件夹。我们自己写的ROS代码通常就放在工作空间中，本节就来介绍catkin工作空间的结构。</p><h2 id="41-catkin工作空间结构"><a class="markdownIt-Anchor" href="#41-catkin工作空间结构"></a> 4.1. Catkin工作空间结构</h2><p>catkin的结构十分清晰，具体的catkin工作空间结构图如下。初看起来catkin工作空间看起来极其复杂，其实不然，catkin工作空间的结构其实非常清晰。</p><p>在工作空间下用tree命令，显示文件结构。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cd</span> ~/catkin_ws</span><br><span class="line">$ sudo apt install tree</span><br><span class="line">$ tree</span><br></pre></td></tr></table></figure><p>结果为：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">─ build</span><br><span class="line">│   ├── catkin</span><br><span class="line">│   │   └── catkin_generated</span><br><span class="line">│   │       └── version</span><br><span class="line">│   │           └── package.cmake</span><br><span class="line">│   ├──</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">│   ├── catkin_make.cache</span><br><span class="line">│   ├── CMakeCache.txt</span><br><span class="line">│   ├── CMakeFiles</span><br><span class="line">│   │   ├──</span><br><span class="line">......</span><br><span class="line"></span><br><span class="line">├── devel</span><br><span class="line">│   ├── env.sh</span><br><span class="line">│   ├── lib</span><br><span class="line">│   ├── setup.bash</span><br><span class="line">│   ├── setup.sh</span><br><span class="line">│   ├── _setup_util.py</span><br><span class="line">│   └── setup.zsh</span><br><span class="line">└── src</span><br><span class="line">└── CMakeLists.txt -&gt; /opt/ros/kinetic/share/catkin/cmake/toplevel.cmake</span><br></pre></td></tr></table></figure><p>通过tree命令可以看到catkin工作空间的结构,它包括了<code>src</code>、<code>build</code>、<code>devel</code>三个路径，在有些编译选项下也可能包括其他。但这三个文件夹是catkin编译系统默认的。它们的具体作用如下：</p><ul><li>src/: ROS的catkin软件包（源代码包）</li><li>build/: catkin（CMake）的缓存信息和中间文件</li><li>devel/: 生成的目标文件（包括头文件，动态链接库，静态链接库，可执行文件等）、环境变量</li></ul><p>在编译过程中，它们的工作流程如图：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/catkin_flow.jpg" alt="img" /></p><p>后两个路径由catkin系统自动生成、管理，我们日常的开发一般不会去涉及，而主要用到的是src文件夹，我们写的ROS程序、网上下载的ROS源代码包都存放在这里。</p><p>在编译时，catkin编译系统会<strong>递归</strong>的查找和编译<code>src/</code>下的每一个源代码包。因此你也可以把几个源代码包放到同一个文件夹下，如下图所示：</p><p><img src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/catkin_ws.jpg" alt="img" /></p><h2 id="42-小结"><a class="markdownIt-Anchor" href="#42-小结"></a> 4.2. 小结</h2><p>catkin工作空间基本就是以上的结构，package是catkin工作空间的<strong>基本单元</strong>，我们在ROS开发时，写好代码，然后catkin_make，系统就会完成所有编译构建的工作。至于更详细的package内容，我们将在下节继续介绍。</p><h1 id="5-package软件包"><a class="markdownIt-Anchor" href="#5-package软件包"></a> 5. Package软件包</h1><p>我们调用<code>catkin_make</code>编译的对象就是一个个ROS的package，也就是说任何ROS程序只有组织成package才能编译。所以package也是ROS源代码存放的地方，任何ROS的代码无论是C++还是Python都要放到package中，这样才能正常的编译和运行。<br />一个package可以编译出来多个目标文件（ROS可执行程序、动态静态库、头文件等等）。</p><h2 id="51-package结构"><a class="markdownIt-Anchor" href="#51-package结构"></a> 5.1. package结构</h2><p>一个package下常见的文件、路径有：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt    #package的编译规则(必须)</span><br><span class="line">├── package.xml       #package的描述信息(必须)</span><br><span class="line">├── src/              #源代码文件</span><br><span class="line">├── include/          #C++头文件</span><br><span class="line">├── scripts/          #可执行脚本</span><br><span class="line">├── msg/              #自定义消息</span><br><span class="line">├── srv/              #自定义服务</span><br><span class="line">├── models/           #3D模型文件</span><br><span class="line">├── urdf/             #urdf文件</span><br><span class="line">├── launch/           #launch文件</span><br></pre></td></tr></table></figure><p>其中定义package的是<code>CMakeLists.txt</code>和<code>package.xml</code>，这两个文件是package中必不可少的。catkin编译系统在编译前，首先就要解析这两个文件。这两个文件就定义了一个package。</p><ul><li>CMakeLists.txt: 定义package的包名、依赖、源文件、目标文件等编译规则，是package不可少的成分</li><li>package.xml: 描述package的包名、版本号、作者、依赖等信息，是package不可少的成分</li><li>src/: 存放ROS的源代码，包括C++的源码和(.cpp)以及Python的module(.py)</li><li>include/: 存放C++源码对应的头文件</li><li>scripts/: 存放可执行脚本，例如shell脚本(.sh)、Python脚本(.py)</li><li>msg/: 存放自定义格式的消息(.msg)</li><li>srv/: 存放自定义格式的服务(.srv)</li><li>models/: 存放机器人或仿真场景的3D模型(.sda, .stl, .dae等)</li><li>urdf/: 存放机器人的模型描述(.urdf或.xacro)</li><li>launch/: 存放launch文件(.launch或.xml)</li></ul><p>通常ROS文件组织都是按照以上的形式，这是约定俗成的命名习惯，建议遵守。以上路径中，只有<code>CMakeLists.txt</code>和<code>package.xml</code>是必须的，其余路径根据软件包是否需要来决定。</p><h2 id="52-package的创建"><a class="markdownIt-Anchor" href="#52-package的创建"></a> 5.2. package的创建</h2><p>创建一个package需要在<code>catkin_ws/src</code>下,用到<code>catkin_create_pkg</code>命令，用法是：<br /><code>catkin_create_pkg package depends</code><br />其中package是包名，depends是依赖的包名，可以依赖多个软件包。</p><p>例如，新建一个package叫做<code>test_pkg</code>,依赖roscpp、rospy、std_msgs(常用依赖)。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ catkin_create_pkg test_pkg roscpp rospy std_msgs</span><br></pre></td></tr></table></figure><p>这样就会在当前路径下新建<code>test_pkg</code>软件包，包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">├── CMakeLists.txt</span><br><span class="line">├── include</span><br><span class="line">│   └── test_pkg</span><br><span class="line">├── package.xml</span><br><span class="line">└── src</span><br></pre></td></tr></table></figure><p><code>catkin_create_pkg</code>帮你完成了软件包的初始化，填充好了<code>CMakeLists.txt</code>和<code>package.xml</code>，并且将依赖项填进了这两个文件中。</p><h2 id="53-package相关命令"><a class="markdownIt-Anchor" href="#53-package相关命令"></a> 5.3. package相关命令</h2><h3 id="531-rospack"><a class="markdownIt-Anchor" href="#531-rospack"></a> 5.3.1. rospack</h3><p>rospack是对package管理的工具，命令的用法如下：</p><table><thead><tr><th style="text-align:center">rostopic命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rospack help</code></td><td style="text-align:center">显示rospack的用法</td></tr><tr><td style="text-align:center"><code>rospack list</code></td><td style="text-align:center">列出本机所有package</td></tr><tr><td style="text-align:center"><code>rospack depends [package]</code></td><td style="text-align:center">显示package的依赖包</td></tr><tr><td style="text-align:center"><code>rospack find [package]</code></td><td style="text-align:center">定位某个package</td></tr><tr><td style="text-align:center"><code>rospack profile</code></td><td style="text-align:center">刷新所有package的位置记录</td></tr></tbody></table><p>以上命令如果package缺省，则默认为当前目录(如果当前目录包含package.xml)</p><h3 id="532-roscd"><a class="markdownIt-Anchor" href="#532-roscd"></a> 5.3.2. roscd</h3><p><code>roscd</code>命令类似与Linux系统的<code>cd</code>，改进之处在于<code>roscd</code>可以直接<code>cd</code>到ROS的软件包。</p><table><thead><tr><th style="text-align:center">rostopic命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>roscd [pacakge]</code></td><td style="text-align:center">cd到ROS package所在路径</td></tr></tbody></table><h3 id="533-rosls"><a class="markdownIt-Anchor" href="#533-rosls"></a> 5.3.3. rosls</h3><p><code>rosls</code>也可以视为Linux指令<code>ls</code>的改进版，可以直接<code>ls</code>ROS软件包的内容。</p><table><thead><tr><th style="text-align:center">rosls命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosls [pacakge]</code></td><td style="text-align:center">列出pacakge下的文件</td></tr></tbody></table><h3 id="534-rosdep"><a class="markdownIt-Anchor" href="#534-rosdep"></a> 5.3.4. rosdep</h3><p><code>rosdep</code>是用于管理ROS package依赖项的命令行工具，用法如下：</p><table><thead><tr><th style="text-align:center">rosdep命令</th><th style="text-align:center">作用</th></tr></thead><tbody><tr><td style="text-align:center"><code>rosdep check [pacakge]</code></td><td style="text-align:center">检查package的依赖是否满足</td></tr><tr><td style="text-align:center"><code>rosdep install [pacakge]</code></td><td style="text-align:center">安装pacakge的依赖</td></tr><tr><td style="text-align:center"><code>rosdep db</code></td><td style="text-align:center">生成和显示依赖数据库</td></tr><tr><td style="text-align:center"><code>rosdep init</code></td><td style="text-align:center">初始化/etc/ros/rosdep中的源</td></tr><tr><td style="text-align:center"><code>rosdep keys</code></td><td style="text-align:center">检查package的依赖是否满足</td></tr><tr><td style="text-align:center"><code>rosdep update</code></td><td style="text-align:center">更新本地的rosdep数据库</td></tr></tbody></table><p>一个较常使用的命令是<code>rosdep install --from-paths src --ignore-src --rosdistro=kinetic -y</code>,用于安装工作空间中<code>src</code>路径下所有package的依赖项（由pacakge.xml文件指定）。</p><h1 id="6-cmakeliststxt"><a class="markdownIt-Anchor" href="#6-cmakeliststxt"></a> 6. CMakeLists.txt</h1><h2 id="61-cmakeliststxt作用"><a class="markdownIt-Anchor" href="#61-cmakeliststxt作用"></a> 6.1. CMakeLists.txt作用</h2><p><code>CMakeLists.txt</code>原本是Cmake编译系统的规则文件，而Catkin编译系统基本沿用了CMake的编译风格，只是针对ROS工程添加了一些宏定义。所以在写法上，catkin的<code>CMakeLists.txt</code>与CMake的基本一致。</p><p>这个文件直接规定了这个package要依赖哪些package，要编译生成哪些目标，如何编译等等流程。所以<code>CMakeLists.txt</code>非常重要，它指定了由源码到目标文件的规则，catkin编译系统在工作时首先会找到每个package下的<code>CMakeLists.txt</code>，然后按照规则来编译构建。</p><h2 id="62-cmakeliststxt写法"><a class="markdownIt-Anchor" href="#62-cmakeliststxt写法"></a> 6.2. CMakeLists.txt写法</h2><p><code>CMakeLists.txt</code>的基本语法都还是按照CMake，而Catkin在其中加入了少量的宏，总体的结构如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>() <span class="comment">#CMake的版本号 </span></span><br><span class="line"><span class="keyword">project</span>()                <span class="comment">#项目名称 </span></span><br><span class="line"><span class="keyword">find_package</span>()           <span class="comment">#找到编译需要的其他CMake/Catkin package</span></span><br><span class="line">catkin_python_setup()    <span class="comment">#catkin新加宏，打开catkin的Python Module的支持</span></span><br><span class="line">add_message_files()      <span class="comment">#catkin新加宏，添加自定义Message/Service/Action文件</span></span><br><span class="line">add_service_files()</span><br><span class="line">add_action_files()</span><br><span class="line">generate_message()       <span class="comment">#catkin新加宏，生成不同语言版本的msg/srv/action接口</span></span><br><span class="line">catkin_package()         <span class="comment">#catkin新加宏，生成当前package的cmake配置，供依赖本包的其他软件包调用</span></span><br><span class="line"><span class="keyword">add_library</span>()            <span class="comment">#生成库</span></span><br><span class="line"><span class="keyword">add_executable</span>()         <span class="comment">#生成可执行二进制文件</span></span><br><span class="line"><span class="keyword">add_dependencies</span>()       <span class="comment">#定义目标文件依赖于其他目标文件，确保其他目标已被构建</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>()  <span class="comment">#链接</span></span><br><span class="line">catkin_add_gtest()       <span class="comment">#catkin新加宏，生成测试</span></span><br><span class="line"><span class="keyword">install</span>()                <span class="comment">#安装至本机</span></span><br></pre></td></tr></table></figure><p>如果你从未接触过CMake的语法，请阅读《CMake实践》：<a href="https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf">https://github.com/Akagi201/learning-cmake/blob/master/docs/cmake-practice.pdf</a> 。掌握CMake语法对于理解ROS工程很有帮助。</p><h1 id="7-packagexml"><a class="markdownIt-Anchor" href="#7-packagexml"></a> 7. package.xml</h1><p><code>package.xml</code>也是一个catkin的package必备文件，它是这个软件包的描述文件，在较早的ROS版本(rosbuild编译系统)中，这个文件叫做<code>manifest.xml</code>，用于描述pacakge的基本信息。如果你在网上看到一些ROS项目里包含着<code>manifest.xml</code>，那么它多半是hydro版本之前的项目了。</p><h2 id="71-packagexml作用"><a class="markdownIt-Anchor" href="#71-packagexml作用"></a> 7.1. package.xml作用</h2><p><code>pacakge.xml</code>包含了package的名称、版本号、内容描述、维护人员、软件许可、编译构建工具、编译依赖、运行依赖等信息。<br />实际上<code>rospack find</code>、<code>rosdep</code>等命令之所以能快速定位和分析出package的依赖项信息，就是直接读取了每一个pacakge中的<code>package.xml</code>文件。它为用户提供了快速了解一个pacakge的渠道。</p><h2 id="72-packagexml写法"><a class="markdownIt-Anchor" href="#72-packagexml写法"></a> 7.2. package.xml写法</h2><p><code>pacakge.xml</code>遵循xml标签文本的写法，由于版本更迭原因，现在有两种格式并存（format1与format2），不过区别不大。老版本（format1）的<code>pacakge.xml</code>通常包含以下标签:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pacakge</span>&gt;</span>           根标记文件  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>              包名  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>           版本号  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>       内容描述  </span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span>&gt;</span>        维护者 </span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>           软件许可证  </span><br><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>  编译构建工具，通常为catkin  </span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>      编译依赖项，与Catkin中的  </span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>        运行依赖项</span><br></pre></td></tr></table></figure><p>说明：其中1-6为必备标签，1是根标签，嵌套了其余的所有标签，2-6为包的各种属性，7-9为编译相关信息。</p><p>在新版本（format2）中，包含的标签为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">pacakge</span>&gt;</span>               根标记文件  </span><br><span class="line"><span class="tag">&lt;<span class="name">name</span>&gt;</span>                  包名  </span><br><span class="line"><span class="tag">&lt;<span class="name">version</span>&gt;</span>               版本号  </span><br><span class="line"><span class="tag">&lt;<span class="name">description</span>&gt;</span>           内容描述  </span><br><span class="line"><span class="tag">&lt;<span class="name">maintainer</span>&gt;</span>            维护者 </span><br><span class="line"><span class="tag">&lt;<span class="name">license</span>&gt;</span>               软件许可证  </span><br><span class="line"><span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>      编译构建工具，通常为catkin    </span><br><span class="line"><span class="tag">&lt;<span class="name">depend</span>&gt;</span>                指定依赖项为编译、导出、运行需要的依赖，最常用</span><br><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>          编译依赖项  </span><br><span class="line"><span class="tag">&lt;<span class="name">build_export_depend</span>&gt;</span>   导出依赖项</span><br><span class="line"><span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>           运行依赖项</span><br><span class="line"><span class="tag">&lt;<span class="name">test_depend</span>&gt;</span>           测试用例依赖项  </span><br><span class="line"><span class="tag">&lt;<span class="name">doc_depend</span>&gt;</span>            文档依赖项</span><br></pre></td></tr></table></figure><p>由此看见新版本的<code>pacakge.xml</code>格式上增加了 、、、 ,相当于将之前的build和run依赖项描述进行了细分。</p><p>目前Indigo、Kinetic、Lunar等版本的ROS都同时支持两种版本的<code>package.xml</code>，所以无论选哪种格式都可以。</p><h2 id="73-pacakgexml例子"><a class="markdownIt-Anchor" href="#73-pacakgexml例子"></a> 7.3. pacakge.xml例子</h2><p>为了说明pacakge.xml写法，还是以turtlesim软件包为例，其<code>pacakge.xml</code>文件内容如下，我们添加了相关的注释：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span>       <span class="comment">&lt;!--本示例为老版本的pacakge.xml--&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span>                   <span class="comment">&lt;!--pacakge为根标签，写在最外面--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>turtlesim<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">    turtlesim is a tool made for teaching ROS and ROS packages.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;dthomas@osrfoundation.org&quot;</span>&gt;</span>Dirk Thomas<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;website&quot;</span>&gt;</span>http://www.ros.org/wiki/turtlesim<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;bugtracker&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials/issues<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;repository&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Josh Faust<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--编译工具为catkin--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--编译时需要依赖以下包--&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>geometry_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span>    </span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qtbase5-dev<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qt5-qmake<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rosconsole<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roscpp_serialization<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>roslib<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>rostime<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>std_srvs<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--运行时需要依赖以下包--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>geometry_msgs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt5-core<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>libqt5-gui<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>rosconsole<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roscpp_serialization<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>roslib<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>rostime<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>std_srvs<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>以上内容是老版本（format1）的写法，如果要写成新版本（format2）则可以改为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version=&quot;1.0&quot;?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">format</span>=<span class="string">&quot;2&quot;</span>&gt;</span>      <span class="comment">&lt;!--在声明pacakge时指定format2，为新版格式--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>turtlesim<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>0.8.1<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">    turtlesim is a tool made for teaching ROS and ROS packages.</span><br><span class="line">  <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;dthomas@osrfoundation.org&quot;</span>&gt;</span>Dirk Thomas<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;website&quot;</span>&gt;</span>http://www.ros.org/wiki/turtlesim<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;bugtracker&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials/issues<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span> <span class="attr">type</span>=<span class="string">&quot;repository&quot;</span>&gt;</span>https://github.com/ros/ros_tutorials<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">author</span>&gt;</span>Josh Faust<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--编译工具为catkin--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--用depend来整合build_depend和run_depend--&gt;</span>  </span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>geometry_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rosconsole<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>roscpp<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>roscpp_serialization<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>roslib<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>rostime<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_msgs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">depend</span>&gt;</span>std_srvs<span class="tag">&lt;/<span class="name">depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--build_depend标签未变--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qtbase5-dev<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>qt5-qmake<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">&lt;!--run_depend要改为exec_depend--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>libqt5-core<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>libqt5-gui<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">exec_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">exec_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h1 id="8-metapackage"><a class="markdownIt-Anchor" href="#8-metapackage"></a> 8. Metapackage</h1><h2 id="81-metapackage介绍"><a class="markdownIt-Anchor" href="#81-metapackage介绍"></a> 8.1. Metapackage介绍</h2><p>在一些ROS的教学资料和博客里，你可能还会看到一个Stack（功能包集）的概念，它指的是将多个功能接近、甚至相互依赖的软件包的放到一个集合中去。但Stack这个概念在Hydro之后就取消了，取而代之的就是Metapackage。尽管换了个马甲，但它的作用没变，都是把一些相近的功能模块、软件包放到一起。</p><p>ROS里常见的Metapacakge有：</p><table><thead><tr><th style="text-align:center">Metapacakge名称</th><th style="text-align:center">描述</th><th style="text-align:center">链接</th></tr></thead><tbody><tr><td style="text-align:center">navigation</td><td style="text-align:center">导航相关的功能包集</td><td style="text-align:center"><a href="https://github.com/ros-planning/navigation">https://github.com/ros-planning/navigation</a></td></tr><tr><td style="text-align:center">moveit</td><td style="text-align:center">运动规划相关的（主要是机械臂）功能包集</td><td style="text-align:center"><a href="https://github.com/ros-planning/moveit">https://github.com/ros-planning/moveit</a></td></tr><tr><td style="text-align:center">image_pipeline</td><td style="text-align:center">图像获取、处理相关的功能包集</td><td style="text-align:center"><a href="https://github.com/ros-perception/image_common">https://github.com/ros-perception/image_common</a></td></tr><tr><td style="text-align:center">vision_opencv</td><td style="text-align:center">ROS与OpenCV交互的功能包集</td><td style="text-align:center"><a href="https://github.com/ros-perception/vision_opencv">https://github.com/ros-perception/vision_opencv</a></td></tr><tr><td style="text-align:center">turtlebot</td><td style="text-align:center">Turtlebot机器人相关的功能包集</td><td style="text-align:center"><a href="https://github.com/turtlebot/turtlebot">https://github.com/turtlebot/turtlebot</a></td></tr><tr><td style="text-align:center">pr2_robot</td><td style="text-align:center">pr2机器人驱动功能包集</td><td style="text-align:center"><a href="https://github.com/PR2/pr2_robot">https://github.com/PR2/pr2_robot</a></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>以上列举了一些常见的功能包集，例如navigation、turtlebot，他们都是用于某一方面的功能，以navigation metapackage（官方介绍里仍然沿用stack的叫法）为例，它包括了以下软件包：</p><table><thead><tr><th style="text-align:center">包名</th><th style="text-align:center">功能</th><th></th></tr></thead><tbody><tr><td style="text-align:center">navigation</td><td style="text-align:center">Metapacakge，依赖以下所有pacakge</td><td></td></tr><tr><td style="text-align:center">amcl</td><td style="text-align:center">定位</td><td></td></tr><tr><td style="text-align:center">fake_localization</td><td style="text-align:center">定位</td><td></td></tr><tr><td style="text-align:center">map_server</td><td style="text-align:center">提供地图</td><td></td></tr><tr><td style="text-align:center">move_base</td><td style="text-align:center">路径规划节点</td><td></td></tr><tr><td style="text-align:center">nav_core</td><td style="text-align:center">路径规划的接口类</td><td></td></tr><tr><td style="text-align:center">base_local_planner</td><td style="text-align:center">局部规划</td><td></td></tr><tr><td style="text-align:center">dwa_local_planner</td><td style="text-align:center">局部规划</td><td></td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td><td>…</td></tr></tbody></table><p>具体功能介绍，我们留到第九章，这里只看一个软件包navigation。这个navigation就是一个简单的pacakge，里面只有几个文件，但由于它依赖了其他所有的软件包。Catkin编译系统会明白，这些软件包都属于navigation metapacakge。</p><p>这个道理并不难理解，比如我们在安装ROS时，用到了<code>sudo apt-get install ros-kinetic-desktop-full</code>命令，由于它依赖了ROS所有的核心组件，我们在安装时也就能够安装整个ROS。</p><h2 id="82-metapackage写法"><a class="markdownIt-Anchor" href="#82-metapackage写法"></a> 8.2. Metapackage写法</h2><p>我们以ROS-Academy-for-beginners为例介绍meteapckage的写法，在教学包内，有一个<code>ros-academy-for-beginners</code>软件包，该包即为一个metapacakge，其中有且仅有两个文件：<code>CMakeLists.txt</code>和<code>pacakge.xml</code>。</p><p><code>CMakeLists.txt</code>写法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">cmake_minimum_required</span>(VERSION <span class="number">2.8</span>.<span class="number">3</span>)</span><br><span class="line"><span class="keyword">project</span>(ros_academy_for_beginners)</span><br><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED)</span><br><span class="line">catkin_metapackage()   <span class="comment">#声明本软件包是一个metapacakge</span></span><br></pre></td></tr></table></figure><p><code>pacakge.xml</code>写法如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>ros_academy_for_beginners<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>17.12.4<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">description</span>&gt;</span></span><br><span class="line">        --------------------------------------------------------------------------</span><br><span class="line">        A ROS tutorial for beginner level learners. This metapacakge includes some</span><br><span class="line">        demos of topic, service, parameter server, tf, urdf, navigation, SLAM...</span><br><span class="line">        It tries to explain the basic concepts and usages of ROS.</span><br><span class="line">        --------------------------------------------------------------------------</span><br><span class="line">    <span class="tag">&lt;/<span class="name">description</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maintainer</span> <span class="attr">email</span>=<span class="string">&quot;chaichangkun@163.com&quot;</span>&gt;</span>Chai Changkun<span class="tag">&lt;/<span class="name">maintainer</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">author</span>&gt;</span>Chai Changkun<span class="tag">&lt;/<span class="name">author</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">license</span>&gt;</span>BSD<span class="tag">&lt;/<span class="name">license</span>&gt;</span>  </span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://http://www.droid.ac.cn<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">buildtool_depend</span>&gt;</span>catkin<span class="tag">&lt;/<span class="name">buildtool_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>navigation_sim_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span>  <span class="comment">&lt;!--注意这里的run_depend标签，将其他软件包都设为依赖项--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>param_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>robot_sim_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>service_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>slam_sim_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>tf_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>topic_demo<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">export</span>&gt;</span>    <span class="comment">&lt;!--这里需要有export和metapacakge标签，注意这种固定写法--&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">metapackage</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">export</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>metapacakge中的以上两个文件和普通pacakge不同点是：</p><ul><li><code>CMakeLists.txt</code>:加入了catkin_metapackage()宏，指定本软件包为一个metapacakge。</li><li><code>package.xml</code>:标签将所有软件包列为依赖项，标签中添加标签声明。</li></ul><p>metapacakge在我们实际开发一个大工程时可能有用</p><h1 id="9-其他常见文件类型"><a class="markdownIt-Anchor" href="#9-其他常见文件类型"></a> 9. 其他常见文件类型</h1><p>在ROS的pacakge中，还有其他许多常见的文件类型，这里做个总结。</p><h2 id="91-launch文件"><a class="markdownIt-Anchor" href="#91-launch文件"></a> 9.1. launch文件</h2><p>launch文件一般以.launch或.xml结尾，它对ROS需要运行程序进行了打包，通过一句命令来启动。一般launch文件中会指定要启动哪些package下的哪些可执行程序，指定以什么参数启动，以及一些管理控制的命令。 launch文件通常放在软件包的<code>launch/</code>路径中中。 launch文件的具体写法见3.2节。</p><h2 id="92-msgsrvaction文件"><a class="markdownIt-Anchor" href="#92-msgsrvaction文件"></a> 9.2. msg/srv/action文件</h2><p>ROS程序中有可能有一些自定义的消息/服务/动作文件，为程序的发者所设计的数据结构，这类的文件以<code>.msg</code>,<code>.srv</code>,<code>.action</code>结尾，通常放在package的<code>msg/</code>,<code>srv/</code>,<code>action/</code>路径下。</p><p>msg文件写法见3.4节，srv文件写法见3.6节。</p><h2 id="93-urdfxacro文件"><a class="markdownIt-Anchor" href="#93-urdfxacro文件"></a> 9.3. urdf/xacro文件</h2><p>urdf/xacro文件是机器人模型的描述文件，以.urdf或.xacro结尾。它定义了机器人的连杆和关节的信息，以及它们之间的位置、角度等信息，通过urdf文件可以将机器人的物理连接信息表示出来。并在可视化调试和仿真中显示。</p><p>urdf文件的写法见第七章。</p><h2 id="94-yaml文件"><a class="markdownIt-Anchor" href="#94-yaml文件"></a> 9.4. yaml文件</h2><p>yaml文件一般存储了ROS需要加载的参数信息，一些属性的配置。通常在launch文件或程序中读取.yaml文件，把参数加载到参数服务器上。通常我们会把yaml文件存放在<code>param/</code>路径下</p><h2 id="95-daestl文件"><a class="markdownIt-Anchor" href="#95-daestl文件"></a> 9.5. dae/stl文件</h2><p>dae或stl文件是3D模型文件，机器人的urdf或仿真环境通常会引用这类文件，它们描述了机器人的三维模型。相比urdf文件简单定义的性状，dae/stl文件可以定义复杂的模型，可以直接从solidworks或其他建模软件导出机器人装配模型，从而显示出更加精确的外形。</p><h2 id="96-rviz文件"><a class="markdownIt-Anchor" href="#96-rviz文件"></a> 9.6. rviz文件</h2><p>rviz文件本质上是固定格式的文本文件，其中存储了RViz窗口的配置（显示哪些控件、视角、参数）。通常rviz文件不需要我们去手动修改，而是直接在RViz工具里保存，下次运行时直接读取。</p>]]></content>
      
      
      <categories>
          
          <category> ROS </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ROS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C++ 基础理解</title>
      <link href="/posts/24a8ae0c.html"/>
      <url>/posts/24a8ae0c.html</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" type="text/css" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-c-简介"><a class="markdownIt-Anchor" href="#1-c-简介"></a> 1. C++ 简介</h1><p>C++ 是一种静态类型的、编译式的、通用的、大小写敏感的、不规则的编程语言，支持过程化编程、面向对象编程和泛型编程。</p><p>C++ 被认为是一种<strong>中级</strong>语言，它综合了高级语言和低级语言的特点。</p><p>C++ 是由 Bjarne Stroustrup 于 1979 年在新泽西州美利山贝尔实验室开始设计开发的。C++ 进一步扩充和完善了 C 语言，最初命名为带类的C，后来在 1983 年更名为 C++。</p><p>C++ 是 C 的一个超集，事实上，任何合法的 C 程序都是合法的 C++ 程序。</p><p>**注意：**使用静态类型的编程语言是在编译时执行类型检查，而不是在运行时执行类型检查。</p><h2 id="11-面向对象程序设计"><a class="markdownIt-Anchor" href="#11-面向对象程序设计"></a> 1.1. 面向对象程序设计</h2><p>C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：</p><ul><li>封装</li><li>抽象</li><li>继承</li><li>多态</li></ul><h2 id="12-标准库"><a class="markdownIt-Anchor" href="#12-标准库"></a> 1.2. 标准库</h2><p>标准的 C++ 由三个重要部分组成：</p><ul><li>核心语言，提供了所有构件块，包括变量、数据类型和常量，等等。</li><li>C++ 标准库，提供了大量的函数，用于操作文件、字符串等。</li><li>标准模板库（STL），提供了大量的方法，用于操作数据结构等。</li></ul><h2 id="13-ansi-标准"><a class="markdownIt-Anchor" href="#13-ansi-标准"></a> 1.3. ANSI 标准</h2><p>ANSI 标准是为了确保 C++ 的便携性 —— 您所编写的代码在 Mac、UNIX、Windows、Alpha 计算机上都能通过编译。</p><p>由于 ANSI 标准已稳定使用了很长的时间，所有主要的 C++ 编译器的制造商都支持 ANSI 标准。</p><h2 id="14-学习-c"><a class="markdownIt-Anchor" href="#14-学习-c"></a> 1.4. 学习 C++</h2><p>学习 C++，关键是要理解概念，而不应过于深究语言的技术细节。</p><p>学习程序设计语言的目的是为了成为一个更好的程序员，也就是说，是为了能更有效率地设计和实现新系统，以及维护旧系统。</p><p>C++ 支持多种编程风格。您可以使用 Fortran、C、Smalltalk 等任意一种语言的编程风格来编写代码。每种风格都能有效地保证运行时间效率和空间效率。</p><h2 id="15-c-的使用"><a class="markdownIt-Anchor" href="#15-c-的使用"></a> 1.5. C++ 的使用</h2><p>基本上每个应用程序领域的程序员都有使用 C++。</p><p>C++ 通常用于编写设备驱动程序和其他要求实时性的直接操作硬件的软件。</p><p>C++ 广泛用于教学和研究。</p><p>任何一个使用苹果电脑或 Windows PC 机的用户都在间接地使用 C++，因为这些系统的主要用户接口是使用 C++ 编写的。</p><hr /><h2 id="16-标准化"><a class="markdownIt-Anchor" href="#16-标准化"></a> 1.6. 标准化</h2><table><thead><tr><th style="text-align:center">发布时间</th><th style="text-align:center">通称</th><th style="text-align:center">备注</th></tr></thead><tbody><tr><td style="text-align:center">2017</td><td style="text-align:center">C++17</td><td style="text-align:center">第五个C++标准</td></tr><tr><td style="text-align:center">2017</td><td style="text-align:center">coroutines TS</td><td style="text-align:center">协程库扩展</td></tr><tr><td style="text-align:center">2017</td><td style="text-align:center">ranges TS</td><td style="text-align:center">提供范围机制</td></tr><tr><td style="text-align:center">2017</td><td style="text-align:center">library fundamentals TS</td><td style="text-align:center">标准库扩展</td></tr><tr><td style="text-align:center">2016</td><td style="text-align:center">concurrency TS</td><td style="text-align:center">用于并发计算的扩展</td></tr><tr><td style="text-align:center">2015</td><td style="text-align:center">concepts TS</td><td style="text-align:center">概念库，用于优化编译期信息</td></tr><tr><td style="text-align:center">2015</td><td style="text-align:center">TM TS</td><td style="text-align:center">事务性内存操作</td></tr><tr><td style="text-align:center">2015</td><td style="text-align:center">parallelism TS</td><td style="text-align:center">用于并行计算的扩展</td></tr><tr><td style="text-align:center">2015</td><td style="text-align:center">filesystem TS</td><td style="text-align:center">文件系统</td></tr><tr><td style="text-align:center">2014</td><td style="text-align:center">C++14</td><td style="text-align:center">第四个C++标准</td></tr><tr><td style="text-align:center">2011</td><td style="text-align:center">-</td><td style="text-align:center">十进制浮点数扩展</td></tr><tr><td style="text-align:center">2011</td><td style="text-align:center">C++11</td><td style="text-align:center">第三个C++标准</td></tr><tr><td style="text-align:center">2010</td><td style="text-align:center">-</td><td style="text-align:center">数学函数扩展</td></tr><tr><td style="text-align:center">2007</td><td style="text-align:center">C++TR1</td><td style="text-align:center">C++技术报告：库扩展</td></tr><tr><td style="text-align:center">2006</td><td style="text-align:center">-</td><td style="text-align:center">C++性能技术报告</td></tr><tr><td style="text-align:center">2003</td><td style="text-align:center">C++03</td><td style="text-align:center">第二个C++标准</td></tr><tr><td style="text-align:center">1998</td><td style="text-align:center">C++98</td><td style="text-align:center">第一个C++标准</td></tr></tbody></table><h1 id="2-c-环境设置"><a class="markdownIt-Anchor" href="#2-c-环境设置"></a> 2. C++ 环境设置</h1><h2 id="21-本地环境设置"><a class="markdownIt-Anchor" href="#21-本地环境设置"></a> 2.1. 本地环境设置</h2><p>如果您想要设置 C++ 语言环境，您需要确保电脑上有以下两款可用的软件，文本编辑器和 C++ 编译器。</p><h2 id="22-文本编辑器"><a class="markdownIt-Anchor" href="#22-文本编辑器"></a> 2.2. 文本编辑器</h2><p>这将用于输入您的程序。文本编辑器包括 Windows Notepad、OS Edit command、Brief、Epsilon、EMACS 和 vim/vi。</p><p>文本编辑器的名称和版本在不同的操作系统上可能会有所不同。例如，Notepad 通常用于 Windows 操作系统上，vim/vi 可用于 Windows 和 Linux/UNIX 操作系统上。</p><p>通过编辑器创建的文件通常称为源文件，源文件包含程序源代码。C++ 程序的源文件通常使用扩展名 .cpp、.cp 或 .c。</p><p>在开始编程之前，请确保您有一个文本编辑器，且有足够的经验来编写一个计算机程序，然后把它保存在一个文件中，编译并执行它。</p><h2 id="23-c-编译器"><a class="markdownIt-Anchor" href="#23-c-编译器"></a> 2.3. C++ 编译器</h2><p>写在源文件中的源代码是人类可读的源。它需要&quot;编译&quot;，转为机器语言，这样 CPU 可以按给定指令执行程序。</p><p>C++ 编译器用于把源代码编译成最终的可执行程序。</p><p>大多数的 C++ 编译器并不在乎源文件的扩展名，但是如果您未指定扩展名，则默认使用 .cpp。</p><p>最常用的免费可用的编译器是 GNU 的 C/C++ 编译器，如果您使用的是 HP 或 Solaris，则可以使用各自操作系统上的编译器。</p><p>以下部分将指导您如何在不同的操作系统上安装 GNU 的 C/C++ 编译器。这里同时提到 C/C++，主要是因为 GNU 的 gcc 编译器适合于 C 和 C++ 编程语言。</p><h2 id="24-安装-gnu-的-cc-编译器"><a class="markdownIt-Anchor" href="#24-安装-gnu-的-cc-编译器"></a> 2.4. 安装 GNU 的 C/C++ 编译器</h2><h3 id="241-unixlinux-上的安装"><a class="markdownIt-Anchor" href="#241-unixlinux-上的安装"></a> 2.4.1. UNIX/Linux 上的安装</h3><p>如果您使用的是 <strong>Linux 或 UNIX</strong>，请在命令行使用下面的命令来检查您的系统上是否安装了 GCC：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ -v</span><br></pre></td></tr></table></figure><p>如果您的计算机上已经安装了 GNU 编译器，则会显示如下消息：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Using built-in specs.</span><br><span class="line">Target: i386-redhat-linux</span><br><span class="line">Configured with: ../configure --prefix=/usr .......</span><br><span class="line">Thread model: posix</span><br><span class="line">gcc version 4.1.2 20080704 (Red Hat 4.1.2-46)</span><br></pre></td></tr></table></figure><p>如果未安装 GCC，那么请按照 <a href="http://gcc.gnu.org/install/">http://gcc.gnu.org/install/</a> 上的详细说明安装 GCC。</p><h3 id="242-mac-os-x-上的安装"><a class="markdownIt-Anchor" href="#242-mac-os-x-上的安装"></a> 2.4.2. Mac OS X 上的安装</h3><p>如果您使用的是 Mac OS X，最快捷的获取 GCC 的方法是从苹果的网站上下载 Xcode 开发环境，并按照安装说明进行安装。一旦安装上 Xcode，您就能使用 GNU 编译器。</p><p>Xcode 目前可从 <a href="http://developer.apple.com/technologies/tools/">developer.apple.com/technologies/tools/</a> 上下载。</p><h3 id="243-windows-上的安装"><a class="markdownIt-Anchor" href="#243-windows-上的安装"></a> 2.4.3. Windows 上的安装</h3><p>为了在 Windows 上安装 GCC，您需要安装 MinGW。为了安装 MinGW，请访问 MinGW 的主页 <a href="http://www.mingw.org/">www.mingw.org</a>，进入 MinGW 下载页面，下载最新版本的 MinGW 安装程序，命名格式为 MinGW-<version>.exe。</p><p>当安装 MinGW 时，您至少要安装 gcc-core、gcc-g++、binutils 和 MinGW runtime，但是一般情况下都会安装更多其他的项。</p><p>添加您安装的 MinGW 的 bin 子目录到您的 <strong>PATH</strong> 环境变量中，这样您就可以在命令行中通过简单的名称来指定这些工具。</p><p>当完成安装时，您可以从 Windows 命令行上运行 gcc、g++、ar、ranlib、dlltool 和其他一些 GNU 工具。</p><hr /><h2 id="25-使用-visual-studio-graphical-interface-编译"><a class="markdownIt-Anchor" href="#25-使用-visual-studio-graphical-interface-编译"></a> 2.5. 使用 Visual Studio (Graphical Interface) 编译</h2><p>1、下载及安装 <a href="https://www.visualstudio.com/">Visual Studio Community 2015</a>。</p><p>2、打开 Visual Studio Community</p><p>3、点击 File -&gt; New -&gt; Project</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/04/1491460649-6165-bFNzb.png" alt="img" /></p><p>4、左侧列表选择 Templates -&gt; Visual C++ -&gt; Win32 Console Application，并设置项目名为 MyFirstProgram。</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/04/1491460652-2077-kYTy1.png" alt="img" /></p><p>5、点击 OK。</p><p>6、在以下窗口中点击 Next</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/04/1491460649-3834-Rebpz.png" alt="img" /></p><p>7、在弹出的窗口中选择 Empty project 选项后，点击 Finish 按钮：</p><p>8、右击文件夹 Source File 并点击 Add --&gt; New Item… :</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/04/1491460652-4373-DLwEd.png" alt="img" /></p><p>9、选择 C++ File 然后设置文件名为 main.cpp，然后点击 Add：</p><p><img src="https://www.runoob.com/wp-content/uploads/2015/01/zQaws.png" alt="img" /></p><p>10、拷贝以下代码到 main.cpp 中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    std::cout &lt;&lt; &quot;Hello World!\n&quot;;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>界面如下所示：</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/04/1491460652-4849-vTBkv.png" alt="img" /></p><p>11、点击菜单上的 Debug -&gt; Start Without Debugging (或按下 ctrl + F5) :</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/04/1491460653-6088-B3twO.png" alt="img" /></p><p>12、完成以上操作后，你可以看到以下输出：</p><p><img src="https://www.runoob.com/wp-content/uploads/2017/04/1491460652-1492-1AwnS.png" alt="img" /></p><hr /><h2 id="26-g-应用说明"><a class="markdownIt-Anchor" href="#26-g-应用说明"></a> 2.6. g++ 应用说明</h2><p>程序 g++ 是将 gcc 默认语言设为 C++ 的一个特殊的版本，链接时它自动使用 C++ 标准库而不用 C 标准库。通过遵循源码的命名规范并指定对应库的名字，用 gcc 来编译链接 C++ 程序是可行的，如下例所示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ gcc main.cpp -lstdc++ -o main</span><br></pre></td></tr></table></figure><p>下面是一个保存在文件 helloworld.cpp 中一个简单的 C++ 程序的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    cout &lt;&lt; &quot;Hello, world!&quot; &lt;&lt; endl;</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最简单的编译方式：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ helloworld.cpp</span><br></pre></td></tr></table></figure><p>由于命令行中未指定可执行程序的文件名，编译器采用默认的 a.out。程序可以这样来运行：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./a.out</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>通常我们使用 <strong>-o</strong> 选项指定可执行程序的文件名，以下实例生成一个 helloworld 的可执行文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ helloworld.cpp -o helloworld</span><br></pre></td></tr></table></figure><p>执行 helloworld:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./helloworld</span><br><span class="line">Hello, world!</span><br></pre></td></tr></table></figure><p>如果是多个 C++ 代码文件，如 runoob1.cpp、runoob2.cpp，编译命令如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ g++ runoob1.cpp runoob2.cpp -o runoob</span><br></pre></td></tr></table></figure><p>生成一个 runoob 可执行文件。</p><p>g++ 有些系统默认是使用 C<ins>98，我们可以指定使用 C</ins>11 来编译 main.cpp 文件：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">g++ -g -Wall -std=c++11 main.cpp</span><br></pre></td></tr></table></figure><h3 id="261-g-常用命令选项"><a class="markdownIt-Anchor" href="#261-g-常用命令选项"></a> 2.6.1. g++ 常用命令选项</h3><table><thead><tr><th style="text-align:left">选项</th><th style="text-align:left">解释</th></tr></thead><tbody><tr><td style="text-align:left">-ansi</td><td style="text-align:left">只支持 ANSI 标准的 C 语法。这一选项将禁止 GNU C 的某些特色， 例如 asm 或 typeof 关键词。</td></tr><tr><td style="text-align:left">-c</td><td style="text-align:left">只编译并生成目标文件。</td></tr><tr><td style="text-align:left">-DMACRO</td><td style="text-align:left">以字符串&quot;1&quot;定义 MACRO 宏。</td></tr><tr><td style="text-align:left">-DMACRO=DEFN</td><td style="text-align:left">以字符串&quot;DEFN&quot;定义 MACRO 宏。</td></tr><tr><td style="text-align:left">-E</td><td style="text-align:left">只运行 C 预编译器。</td></tr><tr><td style="text-align:left">-g</td><td style="text-align:left">生成调试信息。GNU 调试器可利用该信息。</td></tr><tr><td style="text-align:left">-IDIRECTORY</td><td style="text-align:left">指定额外的头文件搜索路径DIRECTORY。</td></tr><tr><td style="text-align:left">-LDIRECTORY</td><td style="text-align:left">指定额外的函数库搜索路径DIRECTORY。</td></tr><tr><td style="text-align:left">-lLIBRARY</td><td style="text-align:left">连接时搜索指定的函数库LIBRARY。</td></tr><tr><td style="text-align:left">-m486</td><td style="text-align:left">针对 486 进行代码优化。</td></tr><tr><td style="text-align:left">-o</td><td style="text-align:left">FILE 生成指定的输出文件。用在生成可执行文件时。</td></tr><tr><td style="text-align:left">-O0</td><td style="text-align:left">不进行优化处理。</td></tr><tr><td style="text-align:left">-O</td><td style="text-align:left">或 -O1 优化生成代码。</td></tr><tr><td style="text-align:left">-O2</td><td style="text-align:left">进一步优化。</td></tr><tr><td style="text-align:left">-O3</td><td style="text-align:left">比 -O2 更进一步优化，包括 inline 函数。</td></tr><tr><td style="text-align:left">-shared</td><td style="text-align:left">生成共享目标文件。通常用在建立共享库时。</td></tr><tr><td style="text-align:left">-static</td><td style="text-align:left">禁止使用共享连接。</td></tr><tr><td style="text-align:left">-UMACRO</td><td style="text-align:left">取消对 MACRO 宏的定义。</td></tr><tr><td style="text-align:left">-w</td><td style="text-align:left">不生成任何警告信息。</td></tr><tr><td style="text-align:left">-Wall</td><td style="text-align:left">生成所有警告信息。</td></tr></tbody></table><h2 id="27-note"><a class="markdownIt-Anchor" href="#27-note"></a> 2.7. Note</h2><h2 id="28-调试时界面一闪而过解决办法"><a class="markdownIt-Anchor" href="#28-调试时界面一闪而过解决办法"></a> 2.8. 调试时界面一闪而过解决办法：</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cin.clear();  // 清空缓存</span><br><span class="line">cin.sync();   // 清空缓存</span><br><span class="line">cin.get();    // 接收键盘输入</span><br></pre></td></tr></table></figure><h2 id="29-一闪而过的解决方法"><a class="markdownIt-Anchor" href="#29-一闪而过的解决方法"></a> 2.9. 一闪而过的解决方法：</h2><ol><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  getchar();</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ol start="2"><li></li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;stdlib.h&gt;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">  system(&quot;pause&quot;); //注意：“system(&quot;pause&quot;)”;语句会显示“请按任意键继续……”</span><br><span class="line">  return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-c-基本语法"><a class="markdownIt-Anchor" href="#3-c-基本语法"></a> 3. C++ 基本语法</h1><p>C++ 程序可以定义为对象的集合，这些对象通过调用彼此的方法进行交互。现在让我们简要地看一下什么是类、对象，方法、即时变量。</p><ul><li><strong>对象 -</strong> 对象具有状态和行为。例如：一只狗的状态 - 颜色、名称、品种，行为 - 摇动、叫唤、吃。对象是类的实例。</li><li><strong>类 -</strong> 类可以定义为描述对象行为/状态的模板/蓝图。</li><li><strong>方法 -</strong> 从基本上说，一个方法表示一种行为。一个类可以包含多个方法。可以在方法中写入逻辑、操作数据以及执行所有的动作。</li><li><strong>即时变量 -</strong> 每个对象都有其独特的即时变量。对象的状态是由这些即时变量的值创建的。</li></ul><h2 id="31-c-程序结构"><a class="markdownIt-Anchor" href="#31-c-程序结构"></a> 3.1. C++ 程序结构</h2><p>让我们看一段简单的代码，可以输出单词 <em>Hello World</em>。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="comment">// main() 是程序开始执行的地方</span></span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">   cout &lt;&lt; <span class="string">&quot;Hello World&quot;</span>; <span class="comment">// 输出 Hello World</span></span><br><span class="line">   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来我们讲解一下上面这段程序：</p><ul><li>C++ 语言定义了一些头文件，这些头文件包含了程序中必需的或有用的信息。上面这段程序中，包含了头文件 <code>&lt;iostream&gt;</code>。</li><li>下一行 <strong>using namespace std;</strong> 告诉编译器使用 std 命名空间。命名空间是 C++ 中一个相对新的概念。</li><li>下一行 <strong>// main() 是程序开始执行的地方</strong> 是一个单行注释。单行注释以 // 开头，在行末结束。</li><li>下一行 <strong>int main()</strong> 是主函数，程序从这里开始执行。</li><li>下一行 <strong>cout &lt;&lt; “Hello World”;</strong> 会在屏幕上显示消息 “Hello World”。</li><li>下一行 <strong>return 0;</strong> 终止 main( )函数，并向调用进程返回值 0。</li></ul><h2 id="32-编译-执行-c-程序"><a class="markdownIt-Anchor" href="#32-编译-执行-c-程序"></a> 3.2. 编译 &amp; 执行 C++ 程序</h2><p>接下来让我们看看如何把源代码保存在一个文件中，以及如何编译并运行它。下面是简单的步骤：</p><ul><li>打开一个文本编辑器，添加上述代码。</li><li>保存文件为 hello.cpp。</li><li>打开命令提示符，进入到保存文件所在的目录。</li><li>键入 'g++ hello.cpp '，输入回车，编译代码。如果代码中没有错误，命令提示符会跳到下一行，并生成 a.out 可执行文件。</li><li>现在，键入 ’ a.out’ 来运行程序。</li><li>您可以看到屏幕上显示 ’ Hello World '。</li></ul><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ g++ hello.cpp</span><br><span class="line">$ ./a.out</span><br><span class="line">Hello World</span><br></pre></td></tr></table></figure><p>请确保您的路径中已包含 g++ 编译器，并确保在包含源文件 hello.cpp 的目录中运行它。</p><p>您也可以使用 makefile 来编译 C/C++ 程序。</p><h2 id="33-c-中的分号-语句块"><a class="markdownIt-Anchor" href="#33-c-中的分号-语句块"></a> 3.3. C++ 中的分号 &amp; 语句块</h2><p>在 C++ 中，分号是语句结束符。也就是说，每个语句必须以分号结束。它表明一个逻辑实体的结束。</p><p>例如，下面是三个不同的语句：</p><p>x = y; y = y+1; add(x, y);</p><p>语句块是一组使用大括号括起来的按逻辑连接的语句。例如：</p><p>{   cout &lt;&lt; “Hello World”; // 输出 Hello World   return 0; }</p><p>C++ 不以行末作为结束符的标识，因此，您可以在一行上放置多个语句。例如：</p><p>x = y; y = y+1; add(x, y);</p><p>等同于</p><p>x = y; y = y+1; add(x, y);</p><h2 id="34-c-标识符"><a class="markdownIt-Anchor" href="#34-c-标识符"></a> 3.4. C++ 标识符</h2><p>C++ 标识符是用来标识变量、函数、类、模块，或任何其他用户自定义项目的名称。一个标识符以字母 A-Z 或 a-z 或下划线 _ 开始，后跟零个或多个字母、下划线和数字（0-9）。</p><p>C++ 标识符内不允许出现标点字符，比如 @、&amp; 和 %。C++ 是区分大小写的编程语言。因此，在 C++ 中，<strong>Manpower</strong> 和 <strong>manpower</strong> 是两个不同的标识符。</p><p>下面列出几个有效的标识符：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mohd       zara    abc   move_name  a_123</span><br><span class="line">myname50   _temp   j     a23b9      retVal</span><br></pre></td></tr></table></figure><h2 id="35-c-关键字"><a class="markdownIt-Anchor" href="#35-c-关键字"></a> 3.5. C++ 关键字</h2><p>下表列出了 C++ 中的保留字。这些保留字不能作为常量名、变量名或其他标识符名称。</p><table><thead><tr><th>asm</th><th>else</th><th>new</th><th>this</th></tr></thead><tbody><tr><td>auto</td><td>enum</td><td>operator</td><td>throw</td></tr><tr><td>bool</td><td>explicit</td><td>private</td><td>true</td></tr><tr><td>break</td><td>export</td><td>protected</td><td>try</td></tr><tr><td>case</td><td>extern</td><td>public</td><td>typedef</td></tr><tr><td>catch</td><td>false</td><td>register</td><td>typeid</td></tr><tr><td>char</td><td>float</td><td>reinterpret_cast</td><td>typename</td></tr><tr><td>class</td><td>for</td><td>return</td><td>union</td></tr><tr><td>const</td><td>friend</td><td>short</td><td>unsigned</td></tr><tr><td>const_cast</td><td>goto</td><td>signed</td><td>using</td></tr><tr><td>continue</td><td>if</td><td>sizeof</td><td>virtual</td></tr><tr><td>default</td><td>inline</td><td>static</td><td>void</td></tr><tr><td>delete</td><td>int</td><td>static_cast</td><td>volatile</td></tr><tr><td>do</td><td>long</td><td>struct</td><td>wchar_t</td></tr><tr><td>double</td><td>mutable</td><td>switch</td><td>while</td></tr><tr><td>dynamic_cast</td><td>namespace</td><td>template</td><td></td></tr></tbody></table><p>完整关键字介绍可查阅：<a href="https://www.runoob.com/w3cnote/cpp-keyword-intro.html">C++ 的关键字（保留字）完整介绍</a></p><h2 id="36-三字符组"><a class="markdownIt-Anchor" href="#36-三字符组"></a> 3.6. 三字符组</h2><p>三字符组就是用于表示另一个字符的三个字符序列，又称为三字符序列。三字符序列总是以两个问号开头。</p><p>三字符序列不太常见，但 C++ 标准允许把某些字符指定为三字符序列。以前为了表示键盘上没有的字符，这是必不可少的一种方法。</p><p>三字符序列可以出现在任何地方，包括字符串、字符序列、注释和预处理指令。</p><p>下面列出了最常用的三字符序列：</p><table><thead><tr><th style="text-align:left">三字符组</th><th style="text-align:left">替换</th></tr></thead><tbody><tr><td style="text-align:left">??=</td><td style="text-align:left">#</td></tr><tr><td style="text-align:left">??/</td><td style="text-align:left">\</td></tr><tr><td style="text-align:left">??’</td><td style="text-align:left">^</td></tr><tr><td style="text-align:left">??(</td><td style="text-align:left">[</td></tr><tr><td style="text-align:left">??)</td><td style="text-align:left">]</td></tr><tr><td style="text-align:left">??!</td><td style="text-align:left">|</td></tr><tr><td style="text-align:left">??&lt;</td><td style="text-align:left">{</td></tr><tr><td style="text-align:left">??&gt;</td><td style="text-align:left">}</td></tr><tr><td style="text-align:left">??-</td><td style="text-align:left">~</td></tr></tbody></table><p>如果希望在源程序中有两个连续的问号，且不希望被预处理器替换，这种情况出现在字符常量、字符串字面值或者是程序注释中，可选办法是用字符串的自动连接：&quot;…?&quot;&quot;?..“或者转义序列：”…??..&quot;。</p><p>从Microsoft Visual C++ 2010版开始，该编译器默认不再自动替换三字符组。如果需要使用三字符组替换（如为了兼容古老的软件代码），需要设置编译器命令行选项/Zc:trigraphs</p><p>g++仍默认支持三字符组，但会给出编译警告。</p><h2 id="37-c-中的空格"><a class="markdownIt-Anchor" href="#37-c-中的空格"></a> 3.7. C++ 中的空格</h2><p>只包含空格的行，被称为空白行，可能带有注释，C++ 编译器会完全忽略它。</p><p>在 C++ 中，空格用于描述空白符、制表符、换行符和注释。空格分隔语句的各个部分，让编译器能识别语句中的某个元素（比如 int）在哪里结束，下一个元素在哪里开始。因此，在下面的语句中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">int age;</span><br></pre></td></tr></table></figure><p>在这里，int 和 age 之间必须至少有一个空格字符（通常是一个空白符），这样编译器才能够区分它们。另一方面，在下面的语句中：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fruit = apples + oranges;   // 获取水果的总数</span><br></pre></td></tr></table></figure><p>fruit 和 =，或者 = 和 apples 之间的空格字符不是必需的，但是为了增强可读性，您可以根据需要适当增加一些空格。</p>]]></content>
      
      
      <categories>
          
          <category> 编程语言 </category>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 编程语言 </tag>
            
            <tag> C++ </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
