<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>ROS-roscpp | Malloy Yuan 的个人博客</title><meta name="keywords" content="ROS,Linux"><meta name="author" content="Malloy Yuan"><meta name="copyright" content="Malloy Yuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="机器人操作系统"><meta property="og:type" content="article"><meta property="og:title" content="ROS-roscpp"><meta property="og:url" content="https://elec-creator.com/posts/3b2a603b.html"><meta property="og:site_name" content="Malloy Yuan 的个人博客"><meta property="og:description" content="机器人操作系统"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg"><meta property="article:published_time" content="2020-04-28T08:26:40.000Z"><meta property="article:modified_time" content="2022-02-10T03:46:06.118Z"><meta property="article:author" content="Malloy Yuan"><meta property="article:tag" content="ROS"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg"><link rel="shortcut icon" href="/img/private/favicon.ico"><link rel="canonical" href="https://elec-creator.com/posts/3b2a603b"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/img/private/pwa/manifest.json"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="/img/private/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/private/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/private/pwa/16.png"><link rel="mask-icon" href="/img/private/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-6017375467561303",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f0eee211545bfd4d4a152fd36de6c1a1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-161823084-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-161823084-1")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"ROS-roscpp",isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2022-02-10 11:46:06"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_1975360_mudsyg8elc9.css"><style>.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Malloy Yuan 的个人博客" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/portrait/portrait-3.jpg" onerror='onerror=null,src="/img/private/site_img-load-404-1.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i> <span>电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i> <span>照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>阅读</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageaboard/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-cat"></i> <span>说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-book"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/top/post-top/ros-top.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Malloy Yuan 的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i> <span>电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i> <span>照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>阅读</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageaboard/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-cat"></i> <span>说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-book"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">ROS-roscpp</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-04-28T08:26:40.000Z" title="发表于 2020-04-28 16:26:40">2020-04-28</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-10T03:46:06.118Z" title="更新于 2022-02-10 11:46:06">2022-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/ros/">ROS</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.5k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>24分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="ROS-roscpp"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/3b2a603b.html#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet external nofollow noreferrer" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><div class="note primary flat"><p>📖 许多工具本质上都是基于ROS的客户端库（Client Libarary）实现的，所谓客户端库，简单的理解就是一套接口，ROS为我们机器人开发者提供了不同语言的接口，比如roscpp是C++语言ROS接口，rospy是python语言的ROS接口，我们直接调用它所提供的函数就可以实现topic、service等通信功能。</p></div><hr><h1 id="1-client-library与roscpp"><a class="markdownIt-Anchor" href="#1-client-library与roscpp"></a> 1. Client Library与roscpp</h1><h2 id="11-client-library简介"><a class="markdownIt-Anchor" href="#11-client-library简介"></a> 1.1. Client Library简介</h2><p>ROS为机器人开发者们提供了不同语言的编程接口，比如C++接口叫做roscpp，Python接口叫做rospy，Java接口叫做rosjava。尽管语言不通，但这些接口都可以用来创建topic、service、param，实现ROS的通信功能。Clinet Lirary有点类似开发中的Helper Class，把一些常用的基本功能做了封装。</p><p>目前ROS支持的Clinet Library包括：</p><table><thead><tr><th style="text-align:center">Client Library</th><th style="text-align:center">介绍</th></tr></thead><tbody><tr><td style="text-align:center">roscpp</td><td style="text-align:center">ROS的C++库，是目前最广泛应用的ROS客户端库，执行效率高</td></tr><tr><td style="text-align:center">rospy</td><td style="text-align:center">ROS的Python库，开发效率高，通常用在对运行时间没有太大要求的场合，例如配置、初始化等操作</td></tr><tr><td style="text-align:center">roslisp</td><td style="text-align:center">ROS的LISP库</td></tr><tr><td style="text-align:center">roscs</td><td style="text-align:center">Mono/.NET.库，可用任何Mono/.NET语言，包括C#，Iron Python， Iron Ruby等</td></tr><tr><td style="text-align:center">rosgo</td><td style="text-align:center">ROS Go语言库</td></tr><tr><td style="text-align:center">rosjava</td><td style="text-align:center">ROS Java语言库</td></tr><tr><td style="text-align:center">rosnodejs</td><td style="text-align:center">Javascript客户端库</td></tr><tr><td style="text-align:center">…</td><td style="text-align:center">…</td></tr></tbody></table><p>目前最常用的只有roscpp和rospy，而其余的语言版本基本都还是测试版。</p><p>从开发客户端库的角度看，一个客户端库，至少需要能够包括master注册、名称管理、消息收发等功能。这样才能给开发者提供对ROS通信架构进行配置的方法。</p><p>整个ROS包括的packages如下，你可以看到roscpp、rospy处于什么位置。</p><p><img src="/img/private/loading-4.gif" data-lazy-src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/ros_pkgs.png" alt="img"></p><h2 id="12-roscpp"><a class="markdownIt-Anchor" href="#12-roscpp"></a> 1.2. roscpp</h2><p>roscpp位于<code>/opt/ros/kinetic</code>之下，用C<ins>实现了ROS通信。在ROS中，C</ins>的代码是通过catkin这个编译系统（扩展的CMake）来进行编译构建的。所以简单地理解，你也可以把roscpp就当作为一个C++的库，我们创建一个CMake工程，在其中include了roscpp等ROS的libraries，这样就可以在工程中使用ROS提供的函数了。</p><p>通常我们要调用ROS的C++接口，首先就需要<code>#include</code>。</p><p>roscpp的主要部分包括：</p><ul><li>ros::init() : 解析传入的ROS参数，创建node第一步需要用到的函数</li><li>ros::NodeHandle : 和topic、service、param等交互的公共接口</li><li>ros::master : 包含从master查询信息的函数</li><li>ros::this_node：包含查询这个进程(node)的函数</li><li>ros::service：包含查询服务的函数</li><li>ros::param：包含查询参数服务器的函数，而不需要用到NodeHandle</li><li>ros::names：包含处理ROS图资源名称的函数</li></ul><p>具体可见：<a target="_blank" rel="noopener external nofollow noreferrer" href="http://docs.ros.org/api/roscpp/html/index.html">http://docs.ros.org/api/roscpp/html/index.html</a></p><p>以上功能可以分为以下几类：</p><ul><li>Initialization and Shutdown 初始与关闭</li><li>Topics 话题</li><li>Services 服务</li><li>Parameter Server 参数服务器</li><li>Timers 定时器</li><li>NodeHandles 节点句柄</li><li>Callbacks and Spinning 回调和自旋（或者翻译叫轮询？）</li><li>Logging 日志</li><li>Names and Node Information 名称管理</li><li>Time 时钟</li><li>Exception 异常</li></ul><p>看到这么多接口，千万别觉得复杂，我们日常开发并不会用到所有的功能，你只需对要有一些印象，掌握几个比较常见和重要的用法就足够了。下面我们来介绍关键的用法。</p><h1 id="2-节点初始-关闭以及nodehandle"><a class="markdownIt-Anchor" href="#2-节点初始-关闭以及nodehandle"></a> 2. 节点初始、关闭以及NodeHandle</h1><p>当执行一个ROS程序，就被加载到了内存中，就成为了一个进程，在ROS里叫做节点。每一个ROS的节点尽管功能不同，但都有必不可少的一些步骤，比如初始化、销毁，需要通行的场景通常都还需要节点的句柄。 这一节我们来学习Node最基本的一些操作。</p><h2 id="21-初始化节点"><a class="markdownIt-Anchor" href="#21-初始化节点"></a> 2.1. 初始化节点</h2><p>对于一个C<ins>写的ROS程序，之所以它区别于普通C</ins>程序，是因为代码中做了两层工作：</p><ol><li>调用了<code>ros::init()</code>函数，从而初始化节点的名称和其他信息，一般我们ROS程序一开始都会以这种方式开始。</li><li>创建<code>ros::NodeHandle</code>对象，也就是节点的句柄，它可以用来创建Publisher、Subscriber以及做其他事情。</li></ol><p>句柄(Handle)这个概念可以理解为一个“把手”，你握住了门把手，就可以很容易把整扇门拉开，而不必关心门是什么样子。NodeHandle就是对节点资源的描述，有了它你就可以操作这个节点了，比如为程序提供服务、监听某个topic上的消息、访问和修改param等等。</p><h2 id="22-关闭节点"><a class="markdownIt-Anchor" href="#22-关闭节点"></a> 2.2. 关闭节点</h2><p>通常我们要关闭一个节点可以直接在终端上按<code>Ctrl</code>+<code>C</code>，系统会自动触发SIGINT句柄来关闭这个进程。 你也可以通过调用<code>ros::shutdown()</code>来手动关闭节点，但通常我们很少这样做。</p><p>以下是一个节点初始化、关闭的例子。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;ros/ros.h&gt;</span><br><span class="line">int main(int argc, char** argv)</span><br><span class="line">&#123;</span><br><span class="line">    ros::init(argc, argv, &quot;your_node_name&quot;); </span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    //....节点功能</span><br><span class="line">    //....</span><br><span class="line">    ros::spin();//用于触发topic、service的响应队列</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这段代码是最常见的一个ROS程序的执行步骤，通常要启动节点，获取句柄，而关闭的工作系统自动帮我们完成，如果有特殊需要你也可以自定义。你可能很关心句柄可以用来做些什么，接下来我们来看看NodeHandle常用的成员函数。</p><h2 id="23-nodehandle常用成员函数"><a class="markdownIt-Anchor" href="#23-nodehandle常用成员函数"></a> 2.3. NodeHandle常用成员函数</h2><p>NodeHandle是Node的句柄，用来对当前节点进行各种操作。在ROS中，NodeHandle是一个定义好的类，通过<code>include</code>，我们可以创建这个类，以及使用它的成员函数。</p><p>NodeHandle常用成员函数包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建话题的publisher </span></span><br><span class="line"><span class="function">ros::Publisher <span class="title">advertise</span><span class="params">(<span class="keyword">const</span> string &amp;topic, <span class="keyword">uint32_t</span> queue_size, <span class="keyword">bool</span> latch=<span class="literal">false</span>)</span></span>; </span><br><span class="line"><span class="comment">//第一个参数为发布话题的名称</span></span><br><span class="line"><span class="comment">//第二个是消息队列的最大长度，如果发布的消息超过这个长度而没有被接收，那么就的消息就会出队。通常设为一个较小的数即可。</span></span><br><span class="line"><span class="comment">//第三个参数是是否锁存。某些话题并不是会以某个频率发布，比如/map这个topic，只有在初次订阅或者地图更新这两种情况下，/map才会发布消息。这里就用到了锁存。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建话题的subscriber</span></span><br><span class="line"><span class="function">ros::Subscriber <span class="title">subscribe</span><span class="params">(<span class="keyword">const</span> string &amp;topic, <span class="keyword">uint32_t</span> queue_size, <span class="keyword">void</span>(*)(M))</span></span>;</span><br><span class="line"><span class="comment">//第一个参数是订阅话题的名称</span></span><br><span class="line"><span class="comment">//第二个参数是订阅队列的长度，如果受到的消息都没来得及处理，那么新消息入队，就消息就会出队</span></span><br><span class="line"><span class="comment">//第三个参数是回调函数指针，指向回调函数来处理接收到的消息</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务的server，提供服务</span></span><br><span class="line"><span class="function">ros::ServiceServer <span class="title">advertiseService</span><span class="params">(<span class="keyword">const</span> string &amp;service, <span class="keyword">bool</span>(*srv_func)(Mreq &amp;, Mres &amp;))</span></span>; </span><br><span class="line"><span class="comment">//第一个参数是service名称</span></span><br><span class="line"><span class="comment">//第二个参数是服务函数的指针，指向服务函数。指向的函数应该有两个参数，分别接受请求和响应。</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//创建服务的client</span></span><br><span class="line"><span class="function">ros::ServiceClient <span class="title">serviceClient</span><span class="params">(<span class="keyword">const</span> string &amp;service_name, <span class="keyword">bool</span> persistent=<span class="literal">false</span>)</span></span>; </span><br><span class="line"><span class="comment">//第一个函数式service名称</span></span><br><span class="line"><span class="comment">//第二个参数用于设置服务的连接是否持续，如果为true，client将会保持与远程主机的连接，这样后续的请求会快一些。通常我们设为flase</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//查询某个参数的值</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getParam</span><span class="params">(<span class="keyword">const</span> string &amp;key, std::string &amp;s)</span></span>; </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">double</span> &amp;d)</span> <span class="keyword">const</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">getParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> &amp;i)</span> <span class="keyword">const</span>；</span></span><br><span class="line"><span class="function"><span class="comment">//从参数服务器上获取key对应的值，已重载了多个类型</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="comment">//给参数赋值</span></span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">const</span> std::string &amp;s)</span> <span class="keyword">const</span>；</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">const</span> <span class="keyword">char</span> *s)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">setParam</span> <span class="params">(<span class="keyword">const</span> std::string &amp;key, <span class="keyword">int</span> i)</span> <span class="keyword">const</span></span>;</span><br><span class="line"><span class="comment">//给key对应的val赋值，重载了多个类型的val</span></span><br></pre></td></tr></table></figure><p>可以看出，NodeHandle对象在ROS C++程序里非常重要，各种类型的通信都需要用NodeHandle来创建完成。 下面我们具体来看topic、service和param这三种基本通信方式的写法。</p><h1 id="3-topic-in-roscpp"><a class="markdownIt-Anchor" href="#3-topic-in-roscpp"></a> 3. topic in roscpp</h1><h2 id="31-topic通信"><a class="markdownIt-Anchor" href="#31-topic通信"></a> 3.1. Topic通信</h2><p>Topic是ROS里一种异步通信的模型，一般是节点间分工明确，有的只负责发送，有的只负责接收处理。对于绝大多数的机器人应用场景，比如传感器数据收发，速度控制指令的收发，Topic模型是最适合的通信方式。</p><p>为了讲明白topic通信的编程思路，我们首先来看<code>topic_demo</code>中的代码,这个程序是一个消息收发的例子：<strong>自定义一个类型为gps的消息（包括位置x，y和工作状态state信息），一个node以一定频率发布模拟的gps消息，另一个node接收并处理，算出到原点的距离。</strong> 源代码见<code>ROS-Academy-for-Beginners/topic_demo</code></p><h2 id="32-创建gps消息"><a class="markdownIt-Anchor" href="#32-创建gps消息"></a> 3.2. 创建gps消息</h2><p>在代码中，我们会用到自定义类型的gps消息，因此就需要来自定义gps消息，在msg路径下创建<code>gps.msg</code>： 见<code>topic_demo/msg/gps.msg</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">string state   #工作状态</span><br><span class="line">float32 x      #x坐标</span><br><span class="line">float32 y      #y坐标</span><br></pre></td></tr></table></figure><p>以上就定义了一个gps类型的消息，你可以把它理解成一个C语言中的结构体，类似于</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">gps</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string state;</span><br><span class="line">    float32 x;</span><br><span class="line">    float32 y;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在程序中对一个gps消息进行创建修改的方法和对结构体的操作一样。</p><p>当你创建完了msg文件，记得修改<code>CMakeLists.txt</code>和<code>package.xml</code>，从而让系统能够编译自定义消息。 在<code>CMakeLists.txt</code>中需要改动</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">find_package</span>(catkin REQUIRED COMPONENTS</span><br><span class="line">roscpp</span><br><span class="line">std_msgs</span><br><span class="line">message_generation   <span class="comment">#需要添加的地方</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">add_message_files(FILES gps.msg)  </span><br><span class="line"><span class="comment">#catkin在cmake之上新增的命令，指定从哪个消息文件生成</span></span><br><span class="line"></span><br><span class="line">generate_messages(DEPENDENCIES std_msgs) </span><br><span class="line"><span class="comment">#catkin新增的命令，用于生成消息</span></span><br><span class="line"><span class="comment">#DEPENDENCIES后面指定生成msg需要依赖其他什么消息，由于gps.msg用到了flaot32这种ROS标准消息，因此需要再把std_msgs作为依赖</span></span><br></pre></td></tr></table></figure><p><code>package.xml</code>中需要的改动</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">build_depend</span>&gt;</span>message_generation<span class="tag">&lt;/<span class="name">build_depend</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">run_depend</span>&gt;</span>message_runtime<span class="tag">&lt;/<span class="name">run_depend</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当你完成了以上所有工作，就可以回到工作空间，然后编译了。编译完成之后会在<code>devel</code>路径下生成<code>gps.msg</code>对应的头文件，头文件按照C++的语法规则定义了<code>topic_demo::gps</code>类型的数据。</p><p>要在代码中使用自定义消息类型，只要<code>#include</code>，然后声明，按照对结构体操作的方式修改内容即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">topic_demo::gps mygpsmsg;</span><br><span class="line">mygpsmsg.x = <span class="number">1.6</span>;</span><br><span class="line">mygpsmsg.y = <span class="number">5.5</span>;</span><br><span class="line">mygpsmsg.state = <span class="string">&quot;working&quot;</span>;</span><br></pre></td></tr></table></figure><h2 id="33-消息发布节点"><a class="markdownIt-Anchor" href="#33-消息发布节点"></a> 3.3. 消息发布节点</h2><p>定义完了消息，就可以开始写ROS代码了。通常我们会把消息收发的两端分成两个节点来写，一个节点就是一个完整的C++程序。</p><p>见<code>topic_demo/src/talker.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span>   </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;topic_demo/gps.h&gt;</span>  <span class="comment">//自定义msg产生的头文件</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);  <span class="comment">//用于解析ROS参数，第三个参数为本节点名</span></span><br><span class="line">  ros::NodeHandle nh;    <span class="comment">//实例化句柄，初始化node</span></span><br><span class="line"></span><br><span class="line">  topic_demo::gps msg;  <span class="comment">//自定义gps消息并初始化 </span></span><br><span class="line">   ...</span><br><span class="line"></span><br><span class="line">  ros::Publisher pub = nh.advertise&lt;topic_demo::gps&gt;(<span class="string">&quot;gps_info&quot;</span>, <span class="number">1</span>); <span class="comment">//创建publisher，往&quot;gps_info&quot;话题上发布消息</span></span><br><span class="line">  <span class="function">ros::Rate <span class="title">loop_rate</span><span class="params">(<span class="number">1.0</span>)</span></span>;   <span class="comment">//定义发布的频率，1HZ </span></span><br><span class="line">  <span class="keyword">while</span> (ros::<span class="built_in">ok</span>())   <span class="comment">//循环发布msg</span></span><br><span class="line">  &#123;</span><br><span class="line">    ...   <span class="comment">//处理msg</span></span><br><span class="line">    pub.<span class="built_in">publish</span>(msg);<span class="comment">//以1Hz的频率发布msg</span></span><br><span class="line">    loop_rate.<span class="built_in">sleep</span>();<span class="comment">//根据前面的定义的loop_rate,设置1s的暂停</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>机器人上几乎所有的传感器，几乎都是按照固定频率发布消息这种通信方式来传输数据，只是发布频率和数据类型的区别。</p><h2 id="34-消息接收节点"><a class="markdownIt-Anchor" href="#34-消息接收节点"></a> 3.4. 消息接收节点</h2><p>见<code>topic_demo/src/listener.cpp</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;topic_demo/gps.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;std_msgs/Float32.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">gpsCallback</span><span class="params">(<span class="keyword">const</span> topic_demo::gps::ConstPtr &amp;msg)</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    std_msgs::Float32 distance;  <span class="comment">//计算离原点(0,0)的距离</span></span><br><span class="line">    distance.data = <span class="built_in">sqrt</span>(<span class="built_in">pow</span>(msg-&gt;x,<span class="number">2</span>)+<span class="built_in">pow</span>(msg-&gt;y,<span class="number">2</span>));</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Listener: Distance to origin = %f, state: %s&quot;</span>,distance.data,msg-&gt;state.<span class="built_in">c_str</span>()); <span class="comment">//输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;listener&quot;</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line">  ros::Subscriber sub = n.<span class="built_in">subscribe</span>(<span class="string">&quot;gps_info&quot;</span>, <span class="number">1</span>, gpsCallback);  <span class="comment">//设置回调函数gpsCallback</span></span><br><span class="line">  ros::<span class="built_in">spin</span>(); <span class="comment">//ros::spin()用于调用所有可触发的回调函数，将进入循环，不会返回，类似于在循环里反复调用spinOnce() </span></span><br><span class="line">  <span class="comment">//而ros::spinOnce()只会去触发一次</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在topic接收方，有一个比较重要的概念，就是<strong>回调(CallBack)</strong>，在本例中，回调就是预先给<code>gps_info</code>话题传来的消息准备一个回调函数，你事先定义好回调函数的操作，本例中是计算到原点的距离。只有当有消息来时，回调函数才会被触发执行。具体去触发的命令就是<code>ros::spin()</code>，它会反复的查看有没有消息来，如果有就会让回调函数去处理。</p><p>因此千万不要认为，只要指定了回调函数，系统就回去自动触发，你必须<code>ros::spin()</code>或者<code>ros::spinOnce()</code>才能真正使回调函数生效。</p><h2 id="35-cmakeliststxt文件修改"><a class="markdownIt-Anchor" href="#35-cmakeliststxt文件修改"></a> 3.5. CMakeLists.txt文件修改</h2><p>在<code>CMakeLists.txt</code>添加以下内容，生成可执行文件</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">add_executable</span>(talker src/talker.cpp) <span class="comment">#生成可执行文件talker</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(talker topic_demo_generate_messages_cpp)</span><br><span class="line"><span class="comment">#表明在编译talker前，必须先生编译完成自定义消息</span></span><br><span class="line"><span class="comment">#必须添加add_dependencies，否则找不到自定义的msg产生的头文件</span></span><br><span class="line"><span class="comment">#表明在编译talker前，必须先生编译完成自定义消息</span></span><br><span class="line"><span class="keyword">target_link_libraries</span>(talker <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>) <span class="comment">#链接</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">add_executable</span>(listener src/listener.cpp ) <span class="comment">#声称可执行文件listener</span></span><br><span class="line"><span class="keyword">add_dependencies</span>(listener topic_demo_generate_messages_cpp)</span><br><span class="line"><span class="keyword">target_link_libraries</span>(listener <span class="variable">$&#123;catkin_LIBRARIES&#125;</span>)<span class="comment">#链接</span></span><br></pre></td></tr></table></figure><p>以上cmake语句告诉catkin编译系统如何去编译生成我们的程序。这些命令都是标准的cmake命令，如果不理解，请查阅cmake教程。</p><p>之后经过<code>catkin_make</code>，一个自定义消息+发布接收的基本模型就完成了。</p><h2 id="36-扩展回调函数与spin方法"><a class="markdownIt-Anchor" href="#36-扩展回调函数与spin方法"></a> 3.6. 扩展：回调函数与spin()方法</h2><p>回调函数在编程中是一种重要的方法，在维基百科上的解释是：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">In computer programming, a callback is any executable code that is passed as an argument to other code, which is expected to call back (execute) the argument at a given time.</span><br></pre></td></tr></table></figure><p>回调函数作为参数被传入到了另一个函数中（在本例中传递的是函数指针），在未来某个时刻（当有新的message到达），就会立即执行。Subscriber接收到消息，实际上是先把消息放到一个<strong>队列</strong>中去，如图所示。队列的长度在Subscriber构建的时候设置好了。当有spin函数执行，就会去处理消息队列中队首的消息。</p><p><img src="/img/private/loading-4.gif" data-lazy-src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/cb_queue.png" alt="img"></p><p>spin具体处理的方法又可分为阻塞/非阻塞,单线程/多线程，在ROS函数接口层面我们有4种spin的方式：</p><table><thead><tr><th style="text-align:center">spin方法</th><th style="text-align:center">阻塞</th><th style="text-align:center">线程</th></tr></thead><tbody><tr><td style="text-align:center"><code>ros::spin()</code></td><td style="text-align:center">阻塞</td><td style="text-align:center">单线程</td></tr><tr><td style="text-align:center"><code>ros::spinOnce()</code></td><td style="text-align:center">非阻塞</td><td style="text-align:center">单线程</td></tr><tr><td style="text-align:center"><code>ros::MultiThreadedSpin()</code></td><td style="text-align:center">阻塞</td><td style="text-align:center">多线程</td></tr><tr><td style="text-align:center"><code>ros::AsyncMultiThreadedSpin()</code></td><td style="text-align:center">非阻塞</td><td style="text-align:center">多线程</td></tr></tbody></table><p>阻塞与非阻塞的区别我们已经讲了，下面来看看单线程与多线程的区别：</p><p><img src="/img/private/loading-4.gif" data-lazy-src="https://sychaichangkun.gitbooks.io/ros-tutorial-icourse163/content/pics/single-multi-spin.png" alt="img"></p><p>我们常用的<code>spin()</code>、<code>spinOnce()</code>是单个线程逐个处理回调队列里的数据。有些场合需要用到多线程分别处理，则可以用到<code>MultiThreadedSpin()</code>、<code>AsyncMultiThreadedSpin()</code>。</p><h1 id="4-service-in-roscpp"><a class="markdownIt-Anchor" href="#4-service-in-roscpp"></a> 4. service in roscpp</h1><h2 id="41-service通信"><a class="markdownIt-Anchor" href="#41-service通信"></a> 4.1. Service通信</h2><p>Service是一种请求-反馈的通信机制。请求的一方通常被称为客户端，提供服务的一方叫做服务器端。Service机制相比于Topic的不同之处在于：</p><ol><li>消息的传输是双向的，有反馈的，而不是单一的流向。</li><li>消息往往不会以固定频率传输，不连续，而是在需要时才会向服务器发起请求。</li></ol><p>在ROS中如何请求或者提供一个服务，我们来看<code>service_demo</code>的代码：<strong>一个节点发出服务请求（姓名，年龄），另一个节点进行服务响应，答复请求。</strong></p><h2 id="42-创建greeting服务"><a class="markdownIt-Anchor" href="#42-创建greeting服务"></a> 4.2. 创建Greeting服务</h2><p>创建<code>service_demo/Greeting.srv</code>文件，内容包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">string name        #短横线上边部分是服务请求的数据</span><br><span class="line">int32 age          </span><br><span class="line">---                #短横线下面是服务回传的内容。</span><br><span class="line">string feedback</span><br></pre></td></tr></table></figure><p>srv格式的文件创建后，也需要修改<code>CMakeLissts.txt</code>,在其中加入</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">add_service_files(FILES Greeting.srv)</span><br></pre></td></tr></table></figure><p>其余与添加msg的改动一样。然后进行<code>catkin_make</code>，系统就会生成在代码中可用的Greeting类型。在代码中使用,只需要<code>#include</code>，然后即可创建该类型的srv。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service_demo::Greeting grt;  <span class="comment">//grt分为grt.request和grt.response两部分</span></span><br><span class="line">grt.request.name = <span class="string">&quot;HAN&quot;</span>; <span class="comment">//不能用grt.name或者grt.age来访问  </span></span><br><span class="line">grt.request.age = <span class="string">&quot;20&quot;</span>;</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>新生成的Greeting类型的服务，其结构体的风格更为明显，可以这么理解，一个Greeting服务结构体中嵌套了两个结构体，分别是请求和响应：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Greeting</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Request</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        string name;</span><br><span class="line">        <span class="keyword">int</span> age;</span><br><span class="line">    &#125;request;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">Response</span></span></span><br><span class="line"><span class="class">    &#123;</span></span><br><span class="line">        string feedback;</span><br><span class="line">    &#125;response;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="43-创建提供服务节点server"><a class="markdownIt-Anchor" href="#43-创建提供服务节点server"></a> 4.3. 创建提供服务节点(server)</h2><p><code>service_demo/srv/server.cpp</code>内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;service_demo/Greeting.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">handle_function</span><span class="params">(service_demo::Greeting::Request &amp;req, service_demo::Greeting::Response &amp;res)</span></span>&#123;</span><br><span class="line">    <span class="comment">//显示请求信息</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(“Request from %s with age %d”, req.name.<span class="built_in">c_str</span>(), req.age);</span><br><span class="line">    <span class="comment">//处理请求，结果写入response</span></span><br><span class="line">    res.feedback = “Hi ” + req.name + “. I’m server!”;</span><br><span class="line">    <span class="comment">//返回true，正确处理了请求</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, “greetings_server”);        <span class="comment">//解析参数，命名节点</span></span><br><span class="line">    ros::NodeHandle nh;                       <span class="comment">//创建句柄，实例化node</span></span><br><span class="line">    ros::ServiceServer service = nh.<span class="built_in">advertiseService</span>(“greetings”, handle_function);  <span class="comment">//写明服务的处理函数</span></span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在以上代码中，服务的处理操作都写在<code>handle_function()</code>中，它的输入参数就是Greeting的Request和Response两部分，而非整个Greeting对象。通常在处理函数中，我们对Requst数据进行需要的操作，将结果写入到Response中。在roscpp中，处理函数返回值是bool型，也就是服务是否成功执行。不要理解成输入Request，返回Response，在rospy中是这样的。</p><h2 id="44-创建服务请求节点client"><a class="markdownIt-Anchor" href="#44-创建服务请求节点client"></a> 4.4. 创建服务请求节点(client)</h2><p><code>service_demo/srv/client.cpp</code>内容如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;ros/ros.h&quot;</span></span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">include</span> <span class="meta-string">&quot;service_demo/Greeting.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;greetings_client&quot;</span>);<span class="comment">// 初始化，节点命名为&quot;greetings_client&quot;</span></span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    ros::ServiceClient client = nh.serviceClient&lt;service_demo::Greeting&gt;(<span class="string">&quot;greetings&quot;</span>);</span><br><span class="line">    <span class="comment">// 定义service客户端，service名字为“greetings”，service类型为Service_demo</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 实例化srv，设置其request消息的内容，这里request包含两个变量，name和age，见Greeting.srv</span></span><br><span class="line">    service_demo::Greeting srv;</span><br><span class="line">    srv.request.name = <span class="string">&quot;HAN&quot;</span>;</span><br><span class="line">    srv.request.age = <span class="number">20</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (client.<span class="built_in">call</span>(srv))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 注意我们的response部分中的内容只包含一个变量response，另，注意将其转变成字符串</span></span><br><span class="line">        <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Response from server: %s&quot;</span>, srv.response.feedback.<span class="built_in">c_str</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">ROS_ERROR</span>(<span class="string">&quot;Failed to call service Service_demo&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上代码比较关键的地方有两处，一个是建立一个ServiceClient，另一个是开始调用服务。建立client需要用<code>nh.serviceClient(&quot;greetings&quot;)</code>，指明服务的类型和服务的名称。而调用时可以直接用<code>client.call(srv)</code>，返回结果不是response，而是是否成功调用远程服务。</p><p><code>CMakeLists.txt</code>和<code>pacakge.xml</code>修改方法和<code>topic_demo</code>修改方法类似，不再赘述。</p><h1 id="5-param-in-roscpp"><a class="markdownIt-Anchor" href="#5-param-in-roscpp"></a> 5. param in roscpp</h1><h2 id="51-parameter-server"><a class="markdownIt-Anchor" href="#51-parameter-server"></a> 5.1. Parameter Server</h2><p>严格来说，param并不能称作一种通信方式，因为它往往只是用来存储一些静态的设置，而不是动态变化的。所以关于param的操作非常轻巧，非常简单。 关于param的API，roscpp为我们提供了两套，一套是放在<code>ros::param</code>namespace下，另一套是在<code>ros::NodeHandle</code>下，这两套API的操作完全一样，用哪一个取决于你的习惯。</p><h2 id="52-param_demo"><a class="markdownIt-Anchor" href="#52-param_demo"></a> 5.2. param_demo</h2><p>我们来看看在C++中如何进行param_demo的操作，<code>param_demo/param.cpp</code>文件，内容包括：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;param_demo&quot;</span>);</span><br><span class="line">    ros::NodeHandle nh;</span><br><span class="line">    <span class="keyword">int</span> parameter1, parameter2, parameter3, parameter4, parameter5;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Get Param的三种方法</span></span><br><span class="line">    <span class="comment">//① ros::param::get()获取参数“param1”的value，写入到parameter1上</span></span><br><span class="line">    <span class="keyword">bool</span> ifget1 = ros::param::<span class="built_in">get</span>(<span class="string">&quot;param1&quot;</span>, parameter1);</span><br><span class="line">    <span class="comment">//② ros::NodeHandle::getParam()获取参数，与①作用相同</span></span><br><span class="line">    <span class="keyword">bool</span> ifget2 = nh.<span class="built_in">getParam</span>(<span class="string">&quot;param2&quot;</span>,parameter2);</span><br><span class="line">    <span class="comment">//③ ros::NodeHandle::param()类似于①和②</span></span><br><span class="line">    <span class="comment">//但如果get不到指定的param，它可以给param指定一个默认值(如33333)</span></span><br><span class="line">        nh.<span class="built_in">param</span>(<span class="string">&quot;param3&quot;</span>, parameter3, <span class="number">33333</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(ifget1) <span class="comment">//param是否取得</span></span><br><span class="line">        ...</span><br><span class="line"></span><br><span class="line">        <span class="comment">//Set Param</span></span><br><span class="line">    <span class="comment">//① ros::param::set()设置参数</span></span><br><span class="line">    parameter4 = <span class="number">4</span>;</span><br><span class="line">    ros::param::<span class="built_in">set</span>(<span class="string">&quot;param4&quot;</span>, parameter4);</span><br><span class="line">    <span class="comment">//② ros::NodeHandle::setParam()设置参数</span></span><br><span class="line">    parameter5 = <span class="number">5</span>;</span><br><span class="line">    nh.<span class="built_in">setParam</span>(<span class="string">&quot;param5&quot;</span>,parameter5);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Check Param</span></span><br><span class="line">    <span class="comment">//① ros::NodeHandle::hasParam()</span></span><br><span class="line">    <span class="keyword">bool</span> ifparam5 = nh.<span class="built_in">hasParam</span>(<span class="string">&quot;param5&quot;</span>);</span><br><span class="line">    <span class="comment">//② ros::param::has()</span></span><br><span class="line">    <span class="keyword">bool</span> ifparam6 = ros::param::<span class="built_in">has</span>(<span class="string">&quot;param6&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//Delete Param</span></span><br><span class="line">    <span class="comment">//① ros::NodeHandle::deleteParam()</span></span><br><span class="line">    <span class="keyword">bool</span> ifdeleted5 = nh.<span class="built_in">deleteParam</span>(<span class="string">&quot;param5&quot;</span>);</span><br><span class="line">    <span class="comment">//② ros::param::del()</span></span><br><span class="line">    <span class="keyword">bool</span> ifdeleted6 = ros::param::<span class="built_in">del</span>(<span class="string">&quot;param6&quot;</span>);</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以上是roscpp中对param进行增删改查所有操作的方法，非常直观。</p><h2 id="53-param_demo中的launch文件"><a class="markdownIt-Anchor" href="#53-param_demo中的launch文件"></a> 5.3. param_demo中的launch文件</h2><p>实际项目中我们对参数进行设置，尤其是添加参数，一般都不是在程序中，而是在launch文件中。因为launch文件可以方便的修改参数，而写成代码之后，修改参数必须重新编译。 因此我们会在launch文件中将param都定义好，比如这个demo正确的打开方式应该是<code>roslaunch param_demo param_demo_cpp.launch</code></p><p><code>param_demo/launch/param_demo_cpp.launch</code>内容为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--param参数配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param1&quot;</span> <span class="attr">value</span>=<span class="string">&quot;1&quot;</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;param2&quot;</span> <span class="attr">value</span>=<span class="string">&quot;2&quot;</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!--rosparam参数配置--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">rosparam</span>&gt;</span>   </span><br><span class="line">        param3: 3</span><br><span class="line">        param4: 4</span><br><span class="line">        param5: 5</span><br><span class="line">       <span class="tag">&lt;/<span class="name">rosparam</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--以上写法将参数转成YAML文件加载，注意param前面必须为空格，不能用Tab，否则YAML解析错误--&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--rosparam file=&quot;$(find robot_sim_demo)/config/xbot2_control.yaml&quot; command=&quot;load&quot; /--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">node</span> <span class="attr">pkg</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">name</span>=<span class="string">&quot;param_demo&quot;</span> <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>通过和两个标签我们设置好了5个param，从而在之前的代码中进行增删改查的操作。</p><h2 id="54-命名空间对param的影响"><a class="markdownIt-Anchor" href="#54-命名空间对param的影响"></a> 5.4. 命名空间对param的影响</h2><p>在实际的项目中，实例化句柄时，经常会看到两种不同的写法 ros::NodeHandle n; ros::NodeHandle nh(&quot;~&quot;);` 这两种写法有什么不同呢？以本教学报的name_demo为例。在本节launch文件夹的demo.launch定义两个参数，一个全局serial 他的数值是5,一个是局部的serial，他的数值是10.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">launch</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!--全局参数serial--&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">value</span>=<span class="string">&quot;5&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">node</span> <span class="attr">name</span>=<span class="string">&quot;name_demo&quot;</span> <span class="attr">pkg</span>=<span class="string">&quot;name_demo&quot;</span> <span class="attr">type</span>=<span class="string">&quot;name_demo&quot;</span></span></span><br><span class="line"><span class="tag">   <span class="attr">output</span>=<span class="string">&quot;screen&quot;</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--局部参数serial--&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">&quot;serial&quot;</span> <span class="attr">value</span>=<span class="string">&quot;10&quot;</span> /&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">node</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">launch</span>&gt;</span></span><br></pre></td></tr></table></figure><p>在name_demo.cpp中，我们分别尝试了，利用全局命名空间句柄提取全局的param和局部的param，以及在局部命名空间下的句柄提取全局的param和局部的param，详细的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ros/ros.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> serial_number = <span class="number">-1</span>;<span class="comment">//serial_number初始化</span></span><br><span class="line">    ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;name_demo&quot;</span>);<span class="comment">//node初始化</span></span><br><span class="line">    <span class="comment">/*创建命名空间*/</span></span><br><span class="line">    <span class="comment">//n 是全局命名空间</span></span><br><span class="line">    ros::NodeHandle n;</span><br><span class="line">    <span class="comment">//nh 是局部命名空间</span></span><br><span class="line">    <span class="function">ros::NodeHandle <span class="title">nh</span><span class="params">(<span class="string">&quot;~&quot;</span>)</span></span>;</span><br><span class="line">    <span class="comment">/*全局命名空间下的Param*/</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;global namespace&quot;</span>);</span><br><span class="line">    <span class="comment">//提取全局命名空间下的参数serial</span></span><br><span class="line">    n.<span class="built_in">getParam</span>(<span class="string">&quot;serial&quot;</span>, serial_number);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;global_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    <span class="comment">//提取局部命名空间下的参数serial</span></span><br><span class="line">    n.<span class="built_in">getParam</span>(<span class="string">&quot;name_demo/serial&quot;</span>, serial_number);<span class="comment">//在全局命名空间下，要提取局部命名空间下的参数，需要添加node name</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;global_to_local_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    <span class="comment">/*局部命名空间下的Param*/</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;local namespace&quot;</span>);</span><br><span class="line">    <span class="comment">//提取局部命名空间下的参数serial</span></span><br><span class="line">    nh.<span class="built_in">getParam</span>(<span class="string">&quot;serial&quot;</span>, serial_number);</span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;local_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    <span class="comment">//提取全局命名空间下的参数serial</span></span><br><span class="line">    nh.<span class="built_in">getParam</span>(<span class="string">&quot;/serial&quot;</span>, serial_number);<span class="comment">//在局部命名空间下，要提取全局命名空间下的参数，需要添加“/”</span></span><br><span class="line">    <span class="built_in">ROS_INFO</span>(<span class="string">&quot;local_to_global_Serial was %d&quot;</span>, serial_number);</span><br><span class="line">    ros::<span class="built_in">spin</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后的结果</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[ INFO] [1525095241.802257811]: global namespace</span><br><span class="line">[ INFO] [1525095241.803512501]: global_Serial was 5</span><br><span class="line">[ INFO] [1525095241.804515959]: global_to_local_Serial was 10</span><br><span class="line">[ INFO] [1525095241.804550167]: local namespace</span><br><span class="line">[ INFO] [1525095241.805126562]: local_Serial was 10</span><br><span class="line">[ INFO] [1525095241.806137701]: local_to_global_Serial was 5</span><br></pre></td></tr></table></figure><h1 id="6-时钟"><a class="markdownIt-Anchor" href="#6-时钟"></a> 6. 时钟</h1><h2 id="61-time-与-duration"><a class="markdownIt-Anchor" href="#61-time-与-duration"></a> 6.1. Time 与 Duration</h2><p>ROS里经常用到的一个功能就是时钟，比如计算机器人移动距离、设定一些程序的等待时间、设定计时器等等。roscpp同样给我们提供了时钟方面的操作。<br>具体来说，roscpp里有两种时间的表示方法，一种是时刻（ros::Time），一种是时长（ros::Duration）。无论是Time还是Duration都具有相同的表示方法：<br>···<br>int32 sec<br>int32 nsec<br>···<br>Time/Duration都由秒和纳秒组成。 要使用Time和Duration，需要<code>#include</code>和<code>#include</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ros::Time begin = ros::Time::<span class="built_in">now</span>(); <span class="comment">//获取当前时间</span></span><br><span class="line"><span class="function">ros::Time <span class="title">at_some_time1</span><span class="params">(<span class="number">5</span>,<span class="number">20000000</span>)</span></span>;  <span class="comment">//5.2s</span></span><br><span class="line"><span class="function">ros::Time <span class="title">at_some_time2</span><span class="params">(<span class="number">5.2</span>)</span> <span class="comment">//同上，重载了float类型和两个uint类型的构造函数</span></span></span><br><span class="line"><span class="function">ros::Duration <span class="title">one_hour</span><span class="params">(<span class="number">60</span>*<span class="number">60</span>,<span class="number">0</span>)</span></span>; <span class="comment">//1h</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">double</span> secs1 = at_some_time1.<span class="built_in">toSec</span>();<span class="comment">//将Time转为double型时间</span></span><br><span class="line"><span class="keyword">double</span> secs2 = one_hour.<span class="built_in">toSec</span>();<span class="comment">//将Duration转为double型时间</span></span><br></pre></td></tr></table></figure><p>Time和Duration表示的概念并不相同，Time指的是某个时刻，而Duration指的是某个时段，尽管他们的数据结构都相同，但是用在不同的场景下。 ROS为我们重载了Time、Duration类型之间的加减运算，比如:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ros::Time t1 = ros::Time::<span class="built_in">now</span>() - ros::<span class="built_in">Duration</span>(<span class="number">5.5</span>); <span class="comment">//t1是5.5s前的时刻，Time加减Duration返回都是Time</span></span><br><span class="line">ros::Time t2 = ros::Time::<span class="built_in">now</span>() + ros::<span class="built_in">Duration</span>(<span class="number">3.3</span>);<span class="comment">//t2是当前时刻往后推3.3s的时刻</span></span><br><span class="line">ros::Duration d1 = t2 - t1;<span class="comment">//从t1到t2的时长，两个Time相减返回Duration类型</span></span><br><span class="line">ros::Duration d2 = d1 -ros::<span class="built_in">Duration</span>(<span class="number">0</span>,<span class="number">300</span>);<span class="comment">//两个Duration相减，还是Duration</span></span><br></pre></td></tr></table></figure><p>以上是Time、Duration之间的加减运算，要注意没有Time+Time的做法。</p><h2 id="62-sleep"><a class="markdownIt-Anchor" href="#62-sleep"></a> 6.2. sleep</h2><p>通常在机器人任务执行中可能有需要等待的场景，这时就要用到sleep功能，roscpp中提供了两种sleep的方法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">ros::<span class="built_in">Duration</span>(<span class="number">0.5</span>).<span class="built_in">sleep</span>(); <span class="comment">//用Duration对象的sleep方法休眠</span></span><br><span class="line"></span><br><span class="line"><span class="function">ros::Rate <span class="title">r</span><span class="params">(<span class="number">10</span>)</span></span>; <span class="comment">//10HZ</span></span><br><span class="line"><span class="keyword">while</span>(ros::<span class="built_in">ok</span>())</span><br><span class="line">&#123;</span><br><span class="line">    r.<span class="built_in">sleep</span>();     </span><br><span class="line">    <span class="comment">//定义好sleep的频率，Rate对象会自动让整个循环以10hz休眠，即使有任务执行占用了时间</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="63-timer"><a class="markdownIt-Anchor" href="#63-timer"></a> 6.3. Timer</h2><p>Rate的功能是指定一个频率，让某些动作按照这个频率来循环执行。与之类似的是ROS中的定时器Timer，它是通过设定回调函数和触发时间来实现某些动作的反复执行，创建方法和topic中的subscriber很像。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback1</span><span class="params">(<span class="keyword">const</span> ros::TimerEvent&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Callback 1 triggered&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">callback2</span><span class="params">(<span class="keyword">const</span> ros::TimerEvent&amp;)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="built_in">ROS_INFO</span>(<span class="string">&quot;Callback 2 triggered&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  ros::<span class="built_in">init</span>(argc, argv, <span class="string">&quot;talker&quot;</span>);</span><br><span class="line">  ros::NodeHandle n;</span><br><span class="line"></span><br><span class="line">  ros::Timer timer1 = n.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">0.1</span>), callback1);  <span class="comment">//timer1每0.1s触发一次callback1函数</span></span><br><span class="line">  ros::Timer timer2 = n.<span class="built_in">createTimer</span>(ros::<span class="built_in">Duration</span>(<span class="number">1.0</span>), callback2);  <span class="comment">//timer2每1.0s触发一次callback2函数</span></span><br><span class="line"></span><br><span class="line">  ros::<span class="built_in">spin</span>();  <span class="comment">//千万别忘了spin，只有spin了才能真正去触发回调函数</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Malloy Yuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://elec-creator.com/posts/3b2a603b.html">https://elec-creator.com/posts/3b2a603b.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://elec-creator.com" target="_blank">Malloy Yuan 的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/ros/">ROS</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" data-sites="facebook,twitter,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/wechat.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/wechat.jpg" alt="Wechat"></a><div class="post-qr-code-desc">Wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/alipay.jpg" alt="Alipay"></a><div class="post-qr-code-desc">Alipay</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-fb+5w+4e-db+86" data-ad-client="ca-pub-6017375467561303" data-ad-slot="3926580292"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/posts/53197a40.html"><img class="prev-cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" onerror='onerror=null,src="/img/private/post_img-load-404-1.jpg"' alt="cover of previous post"><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">ROS-rospy</div></div></a></div><div class="next-post pull-right"><a href="/posts/28077269.html"><img class="next-cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" onerror='onerror=null,src="/img/private/post_img-load-404-1.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">ROS-TF与URDF</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/72d3205.html" title="ROS-windows安装ROS环境"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-07</div><div class="title">ROS-windows安装ROS环境</div></div></a></div><div><a href="/posts/15fa7048.html" title="ROS"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-18</div><div class="title">ROS</div></div></a></div><div><a href="/posts/b74e4547.html" title="ROS学习过程的疑问"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">ROS学习过程的疑问</div></div></a></div><div><a href="/posts/59244a47.html" title="ROS常用工具"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-05-03</div><div class="title">ROS常用工具</div></div></a></div><div><a href="/posts/894a0bcb.html" title="ROS常用指令整理"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-07-05</div><div class="title">ROS常用指令整理</div></div></a></div><div><a href="/posts/53197a40.html" title="ROS-rospy"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/ros-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-04-28</div><div class="title">ROS-rospy</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/portrait/portrait-3.jpg" onerror='this.onerror=null,this.src="/img/private/site_img-load-404-1.gif"' alt="avatar"></div><div class="author-info__name">Malloy Yuan</div><div class="author-info__description">__在总结中前进,在反思中提升__个人学习/经历/感悟/项目经验/生活 点滴的记录与分享</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=980298390&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://weibo.com/u/6622047516" rel="external nofollow noreferrer" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="https://www.zhihu.com/people/yyyml" rel="external nofollow noreferrer" target="_blank" title="Zhihu"><i class="fab fa-zhihu"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=19122520" rel="external nofollow noreferrer" target="_blank" title="Neteasy music"><i class="iconfont icon-wangyiyunyinyuemusic1193417easyiconnet"></i></a><a class="social-icon" href="https://space.bilibili.com/432676565" rel="external nofollow noreferrer" target="_blank" title="bilibili"><i class="iconfont icon-bilibili-fill"></i></a><a class="social-icon" href="mailto:yuanml0807@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">不定时更的个人博客,喜欢记得收藏,欢迎沟通交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-client-library%E4%B8%8Eroscpp"><span class="toc-text">1. Client Library与roscpp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-client-library%E7%AE%80%E4%BB%8B"><span class="toc-text">1.1. Client Library简介</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-roscpp"><span class="toc-text">1.2. roscpp</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E8%8A%82%E7%82%B9%E5%88%9D%E5%A7%8B-%E5%85%B3%E9%97%AD%E4%BB%A5%E5%8F%8Anodehandle"><span class="toc-text">2. 节点初始、关闭以及NodeHandle</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%88%9D%E5%A7%8B%E5%8C%96%E8%8A%82%E7%82%B9"><span class="toc-text">2.1. 初始化节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#22-%E5%85%B3%E9%97%AD%E8%8A%82%E7%82%B9"><span class="toc-text">2.2. 关闭节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#23-nodehandle%E5%B8%B8%E7%94%A8%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0"><span class="toc-text">2.3. NodeHandle常用成员函数</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-topic-in-roscpp"><span class="toc-text">3. topic in roscpp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-topic%E9%80%9A%E4%BF%A1"><span class="toc-text">3.1. Topic通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#32-%E5%88%9B%E5%BB%BAgps%E6%B6%88%E6%81%AF"><span class="toc-text">3.2. 创建gps消息</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#33-%E6%B6%88%E6%81%AF%E5%8F%91%E5%B8%83%E8%8A%82%E7%82%B9"><span class="toc-text">3.3. 消息发布节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#34-%E6%B6%88%E6%81%AF%E6%8E%A5%E6%94%B6%E8%8A%82%E7%82%B9"><span class="toc-text">3.4. 消息接收节点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#35-cmakeliststxt%E6%96%87%E4%BB%B6%E4%BF%AE%E6%94%B9"><span class="toc-text">3.5. CMakeLists.txt文件修改</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#36-%E6%89%A9%E5%B1%95%E5%9B%9E%E8%B0%83%E5%87%BD%E6%95%B0%E4%B8%8Espin%E6%96%B9%E6%B3%95"><span class="toc-text">3.6. 扩展：回调函数与spin()方法</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-service-in-roscpp"><span class="toc-text">4. service in roscpp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-service%E9%80%9A%E4%BF%A1"><span class="toc-text">4.1. Service通信</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#42-%E5%88%9B%E5%BB%BAgreeting%E6%9C%8D%E5%8A%A1"><span class="toc-text">4.2. 创建Greeting服务</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#43-%E5%88%9B%E5%BB%BA%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8A%A1%E8%8A%82%E7%82%B9server"><span class="toc-text">4.3. 创建提供服务节点(server)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#44-%E5%88%9B%E5%BB%BA%E6%9C%8D%E5%8A%A1%E8%AF%B7%E6%B1%82%E8%8A%82%E7%82%B9client"><span class="toc-text">4.4. 创建服务请求节点(client)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-param-in-roscpp"><span class="toc-text">5. param in roscpp</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-parameter-server"><span class="toc-text">5.1. Parameter Server</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-param_demo"><span class="toc-text">5.2. param_demo</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#53-param_demo%E4%B8%AD%E7%9A%84launch%E6%96%87%E4%BB%B6"><span class="toc-text">5.3. param_demo中的launch文件</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#54-%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E5%AF%B9param%E7%9A%84%E5%BD%B1%E5%93%8D"><span class="toc-text">5.4. 命名空间对param的影响</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-%E6%97%B6%E9%92%9F"><span class="toc-text">6. 时钟</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-time-%E4%B8%8E-duration"><span class="toc-text">6.1. Time 与 Duration</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#62-sleep"><span class="toc-text">6.2. sleep</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#63-timer"><span class="toc-text">6.3. Timer</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a8c481ea.html" title="总结基础知识点面(一) 单片机篇"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/summarization-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="总结基础知识点面(一) 单片机篇"></a><div class="content"><a class="title" href="/posts/a8c481ea.html" title="总结基础知识点面(一) 单片机篇">总结基础知识点面(一) 单片机篇</a><time datetime="2020-08-08T16:55:00.000Z" title="发表于 2020-08-09 00:55:00">2020-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3a13bccb.html" title="C++ array模板类使用"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ array模板类使用"></a><div class="content"><a class="title" href="/posts/3a13bccb.html" title="C++ array模板类使用">C++ array模板类使用</a><time datetime="2020-07-24T14:52:40.000Z" title="发表于 2020-07-24 22:52:40">2020-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/925153f2.html" title="C++ 代码换行的问题"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ 代码换行的问题"></a><div class="content"><a class="title" href="/posts/925153f2.html" title="C++ 代码换行的问题">C++ 代码换行的问题</a><time datetime="2020-07-24T14:24:40.000Z" title="发表于 2020-07-24 22:24:40">2020-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dd9d548b.html" title="C++ 对数组进行复制"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ 对数组进行复制"></a><div class="content"><a class="title" href="/posts/dd9d548b.html" title="C++ 对数组进行复制">C++ 对数组进行复制</a><time datetime="2020-07-24T14:20:40.000Z" title="发表于 2020-07-24 22:20:40">2020-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4858c62f.html" title="C++ vector的用法"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ vector的用法"></a><div class="content"><a class="title" href="/posts/4858c62f.html" title="C++ vector的用法">C++ vector的用法</a><time datetime="2020-07-24T14:12:40.000Z" title="发表于 2020-07-24 22:12:40">2020-07-24</time></div></div></div></div><div class="card-widget ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6017375467561303" data-ad-slot="4346183088" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></main><footer id="footer" style="background-image:url(https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/top/post-top/ros-top.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022<i style="color:#ff6a6a" class="fa fa-heartbeat"></i>Malloy Yuan</div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/private/loading-4.gif" data-lazy-src="/img/private/icp.png"><span>湘ICP备20005957号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(e.length){window.runMermaid=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,i="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent;mermaid.mermaidAPI.render(r,i,e=>{d.insertAdjacentHTML("afterend",e)})})};const t=()=>{window.loadMermaid?runMermaid():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(runMermaid)};window.pjax?t():document.addEventListener("DOMContentLoaded",t)}})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-five-olive.vercel.app/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.vemoji)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&twikoo.getCommentsCount({envId:"https://twikoo-five-olive.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(t){document.getElementById("twikoo-count").innerText=t[0].count})).catch((function(t){console.error(t)}))},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo@1.4.15/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};o()})()</script></div><div class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"點擊刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="//code.tidio.co/xmigmag8yz8wxyxf4rx4tsq9ejzzdqki.js" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/live2d-widget-model/haru/01/assets/haru01.model.json"},display:{superSample:2,width:150,height:490,position:"left",hOffset:270,vOffset:-50},mobile:{show:!1,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html>