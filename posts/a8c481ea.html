<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no"><title>总结基础知识点面(一) 单片机篇 | Malloy Yuan 的个人博客</title><meta name="keywords" content="知识梳理"><meta name="author" content="Malloy Yuan"><meta name="copyright" content="Malloy Yuan"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="MCU单片机使用总结梳理"><meta property="og:type" content="article"><meta property="og:title" content="总结基础知识点面(一) 单片机篇"><meta property="og:url" content="https://elec-creator.com/posts/a8c481ea.html"><meta property="og:site_name" content="Malloy Yuan 的个人博客"><meta property="og:description" content="MCU单片机使用总结梳理"><meta property="og:locale" content="zh_CN"><meta property="og:image" content="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/summarization-cover.jpg"><meta property="article:published_time" content="2020-08-08T16:55:00.000Z"><meta property="article:modified_time" content="2022-02-10T03:46:06.114Z"><meta property="article:author" content="Malloy Yuan"><meta property="article:tag" content="MCU"><meta property="article:tag" content="知识梳理"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/summarization-cover.jpg"><link rel="shortcut icon" href="/img/private/favicon.ico"><link rel="canonical" href="https://elec-creator.com/posts/a8c481ea"><link rel="preconnect" href="//cdn.jsdelivr.net"><link rel="preconnect" href="//www.google-analytics.com" crossorigin=""><link rel="preconnect" href="//hm.baidu.com"><link rel="preconnect" href="//fonts.googleapis.com" crossorigin=""><link rel="preconnect" href="//busuanzi.ibruce.info"><link rel="manifest" href="/img/private/pwa/manifest.json"><meta name="msapplication-TileColor" content="#000000"><link rel="apple-touch-icon" sizes="180x180" href="/img/private/pwa/apple-touch-icon.png"><link rel="icon" type="image/png" sizes="32x32" href="/img/private/pwa/32.png"><link rel="icon" type="image/png" sizes="16x16" href="/img/private/pwa/16.png"><link rel="mask-icon" href="/img/private/pwa/safari-pinned-tab.svg" color="#5bbad5"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free/css/all.min.css" media="print" onload='this.media="all"'><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.css" media="print" onload='this.media="all"'><script async src="https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script><script>(adsbygoogle=window.adsbygoogle||[]).push({google_ad_client:"ca-pub-6017375467561303",enable_page_level_ads:"true"})</script><script>var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?f0eee211545bfd4d4a152fd36de6c1a1";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script async src="https://www.googletagmanager.com/gtag/js?id=UA-161823084-1"></script><script>function gtag(){dataLayer.push(arguments)}window.dataLayer=window.dataLayer||[],gtag("js",new Date),gtag("config","UA-161823084-1")</script><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web" media="print" onload='this.media="all"'><script>const GLOBAL_CONFIG={root:"/",algolia:void 0,localSearch:{path:"search.xml",languages:{hits_empty:"找不到您查询的内容：${query}"}},translate:{defaultEncoding:2,translateDelay:0,msgToTraditionalChinese:"繁",msgToSimplifiedChinese:"简"},noticeOutdate:void 0,highlight:{plugin:"highlighjs",highlightCopy:!0,highlightLang:!0,highlightHeightLimit:200},copy:{success:"复制成功",error:"复制错误",noSupport:"浏览器不支持"},relativeDate:{homepage:!1,post:!1},runtime:"天",date_suffix:{just:"刚刚",min:"分钟前",hour:"小时前",day:"天前",month:"个月前"},copyright:void 0,lightbox:"fancybox",Snackbar:void 0,source:{justifiedGallery:{js:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.js",css:"https://cdn.jsdelivr.net/npm/flickr-justified-gallery@2/dist/fjGallery.min.css"}},isPhotoFigcaption:!1,islazyload:!0,isAnchor:!0}</script><script id="config-diff">var GLOBAL_CONFIG_SITE={title:"总结基础知识点面(一) 单片机篇",isPost:!0,isHome:!1,isHighlightShrink:!0,isToc:!0,postUpdate:"2022-02-10 11:46:06"}</script><noscript><style>#nav{opacity:1}.justified-gallery img{opacity:1}#post-meta time,#recent-posts time{display:inline!important}</style></noscript><script>(e=>{e.saveToLocal={set:function(e,t,o){if(0===o)return;const n=864e5*o,a={value:t,expiry:(new Date).getTime()+n};localStorage.setItem(e,JSON.stringify(a))},get:function(e){const t=localStorage.getItem(e);if(!t)return;const o=JSON.parse(t);if(!((new Date).getTime()>o.expiry))return o.value;localStorage.removeItem(e)}},e.getScript=e=>new Promise((t,o)=>{const n=document.createElement("script");n.src=e,n.async=!0,n.onerror=o,n.onload=n.onreadystatechange=function(){const e=this.readyState;e&&"loaded"!==e&&"complete"!==e||(n.onload=n.onreadystatechange=null,t())},document.head.appendChild(n)}),e.activateDarkMode=function(){document.documentElement.setAttribute("data-theme","dark"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#0d0d0d")},e.activateLightMode=function(){document.documentElement.setAttribute("data-theme","light"),null!==document.querySelector('meta[name="theme-color"]')&&document.querySelector('meta[name="theme-color"]').setAttribute("content","#ffffff")};const t=saveToLocal.get("theme");"dark"===t?activateDarkMode():"light"===t&&activateLightMode();const o=saveToLocal.get("aside-status");void 0!==o&&("hide"===o?document.documentElement.classList.add("hide-aside"):document.documentElement.classList.remove("hide-aside"));/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)&&document.documentElement.classList.add("apple")})(window)</script><link rel="stylesheet" href="//at.alicdn.com/t/font_1975360_mudsyg8elc9.css"><style>.app-refresh{position:fixed;top:-2.2rem;left:0;right:0;z-index:99999;padding:0 1rem;font-size:15px;height:2.2rem;transition:all .3s ease}.app-refresh-wrap{display:flex;color:#fff;height:100%;align-items:center;justify-content:center}.app-refresh-wrap a{color:#fff;text-decoration:underline;cursor:pointer}</style><meta name="generator" content="Hexo 5.4.0"><link rel="alternate" href="/atom.xml" title="Malloy Yuan 的个人博客" type="application/atom+xml"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/portrait/portrait-3.jpg" onerror='onerror=null,src="/img/private/site_img-load-404-1.gif"' alt="avatar"></div><div class="site-data is-center"><div class="data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div><div class="data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div></div><hr><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i> <span>电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i> <span>照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>阅读</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageaboard/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-cat"></i> <span>说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-book"></i> <span>关于</span></a></div></div></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header" style="background-image:url(https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/top/post-top/summarization-top.jpg)"><nav id="nav"><span id="blog_name"><a id="site-name" href="/">Malloy Yuan 的个人博客</a></span><div id="menus"><div id="search-button"><a class="site-page social-icon search"><i class="fas fa-search fa-fw"></i> <span>搜索</span></a></div><div class="menus_items"><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fas fa-home"></i> <span>主页</span></a></div><div class="menus_item"><a class="site-page" href="/archives/"><i class="fa-fw fas fa-archive"></i> <span>时间轴</span></a></div><div class="menus_item"><a class="site-page" href="/tags/"><i class="fa-fw fas fa-tags"></i> <span>标签</span></a></div><div class="menus_item"><a class="site-page" href="/categories/"><i class="fa-fw fas fa-folder-open"></i> <span>分类</span></a></div><div class="menus_item"><a class="site-page group" href="javascript:void(0);" rel="external nofollow noreferrer"><i class="fa-fw fas fa-list"></i> <span>娱乐</span><i class="fas fa-chevron-down"></i></a><ul class="menus_item_child"><li><a class="site-page child" href="/music/"><i class="fa-fw fas fa-music"></i> <span>音乐</span></a></li><li><a class="site-page child" href="/movies/"><i class="fa-fw fas fa-film"></i> <span>电影</span></a></li><li><a class="site-page child" href="/gallery/"><i class="fa-fw fas fa-camera-retro"></i> <span>照片</span></a></li><li><a class="site-page child" href="/books/"><i class="fa-fw fas fa-book"></i> <span>阅读</span></a></li><li><a class="site-page child" href="/games/"><i class="fa-fw fas fa-gamepad"></i> <span>游戏</span></a></li></ul></div><div class="menus_item"><a class="site-page" href="/messageaboard/"><i class="fa-fw fas fa-comment-dots"></i> <span>留言板</span></a></div><div class="menus_item"><a class="site-page" href="/artitalk/"><i class="fa-fw fas fa-cat"></i> <span>说说</span></a></div><div class="menus_item"><a class="site-page" href="/link/"><i class="fa-fw fas fa-link"></i> <span>友链</span></a></div><div class="menus_item"><a class="site-page" href="/about/"><i class="fa-fw fas fa-address-book"></i> <span>关于</span></a></div></div><div id="toggle-menu"><a class="site-page"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">总结基础知识点面(一) 单片机篇</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2020-08-08T16:55:00.000Z" title="发表于 2020-08-09 00:55:00">2020-08-09</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2022-02-10T03:46:06.114Z" title="更新于 2022-02-10 11:46:06">2022-02-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/summarization/">知识梳理</a><i class="fas fa-angle-right post-meta-separator"></i><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/summarization/mcu/">MCU</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-wordcount"><i class="far fa-file-word fa-fw post-meta-icon"></i><span class="post-meta-label">字数总计:</span><span class="word-count">6.2k</span><span class="post-meta-separator">|</span><i class="far fa-clock fa-fw post-meta-icon"></i><span class="post-meta-label">阅读时长:</span><span>20分钟</span></span><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" data-flag-title="总结基础知识点面(一) 单片机篇"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"></span></span><span class="post-meta-separator">|</span><span class="post-meta-commentcount"><i class="far fa-comments fa-fw post-meta-icon"></i><span class="post-meta-label">评论数:</span><a href="/posts/a8c481ea.html#post-comment"><span id="twikoo-count"></span></a></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><link rel="stylesheet external nofollow noreferrer" href="https://cdn.jsdelivr.net/hint.css/2.4.1/hint.min.css"><h1 id="1-预处理器-preprocessor"><a class="markdownIt-Anchor" href="#1-预处理器-preprocessor"></a> 1. 预处理器 (Preprocessor)</h1><h2 id="11-用预处理指令define-声明一个常数用以表明1年中有多少秒忽略闰年问题"><a class="markdownIt-Anchor" href="#11-用预处理指令define-声明一个常数用以表明1年中有多少秒忽略闰年问题"></a> 1.1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒(忽略闰年问题)</h2><p><code>#define SECONDS_PER_YEAR (60 * 60 * 24 * 365)UL</code></p><p>在这想看到几件事情：</p><ol><li><p>#define 语法的基本知识(例如：不能以分号结束，括号的使用，等等)</p></li><li><p>懂得预处理器将为你计算常数表达式的值，因此直接写出你如何计算一年中有多少秒而不是计算出实际的值，是更清晰而没有代价的。</p></li><li><p>意识到这个表达式将使一个16位机的整型数溢出-因此要用到长整型符号L,告诉编译器这个常数是的长整型数。</p></li><li><p>如果你在你的表达式中用到UL(表示无符号长整型)，那么你有了一个好的起点。记住，第一印象很重要。</p></li></ol><h2 id="12-写一个标准宏min-这个宏输入两个参数并返回较小的一个"><a class="markdownIt-Anchor" href="#12-写一个标准宏min-这个宏输入两个参数并返回较小的一个"></a> 1.2. 写一个&quot;标准&quot;宏MIN ，这个宏输入两个参数并返回较小的一个。</h2><p><code>#define MIN(A,B) ((A)&lt;= (B) ? (A) : (B))</code></p><p>这个测试是为下面的目的而设的：</p><ol><li><p>标识#define在宏中应用的基本知识。这是很重要的。因为在 嵌入(inline)操作符 变为标准C的一部分之前，宏是方便产生嵌入代码的唯一方法，对于嵌入式系统来说，为了能达到要求的性能，嵌入代码经常是必须的方法。</p></li><li><p>三重条件操作符的知识。这个操作符存在C语言中的原因是它使得编译器能产生比if-then-else更优的代码，了解这个用法是很重要的。</p></li><li><p>懂得在宏中小心地把参数用括号括起来</p></li><li><p>我也用这个问题开始讨论宏的副作用，例如：当你写下面的代码时会发生什么事？</p></li></ol><p><code>least = MIN(*p++, b); -&gt;((*p++) &lt;b ？(*p++) : b)</code> 此时前后两个的<em>p++ 的值已经不是同一个了，多处使用这个宏时，每次的</em>p++ 都不是同一个值</p><h2 id="13-预处理器标识error的目的是什么"><a class="markdownIt-Anchor" href="#13-预处理器标识error的目的是什么"></a> 1.3. 预处理器标识#error的目的是什么？</h2><p>这问题对区分一个正常的伙计和一个书呆子是很有用的。只有书呆子才会读C语言课本的附录去找出象这种问题的答案。当然如果你不是在找一个书呆子，那么应试者最好希望自己不要知道答案。</p><h1 id="2-死循环-infinite-loops"><a class="markdownIt-Anchor" href="#2-死循环-infinite-loops"></a> 2. 死循环 (Infinite loops)</h1><h2 id="21-嵌入式系统中经常要用到无限循环你怎么样用-c-编写死循环呢"><a class="markdownIt-Anchor" href="#21-嵌入式系统中经常要用到无限循环你怎么样用-c-编写死循环呢"></a> 2.1. 嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？</h2><p>这个问题用几个解决方案。我首选的方案是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些程序员更喜欢如下方案：</p><p>一些程序员更喜欢如下方案：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(;;)</span><br><span class="line">&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个实现方式让我为难， 因为这个语法没有确切表达到底怎么回事。 如果一个应试者给出这个作为方案， 我将用这个作为一个机会去探究他们这样做的基本原理。 如果他们的基本答案是： “我被教着这样做，但从没有想到过为什么。 ”这会给我留下一个坏印象。第三个方案是用 goto</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loop:</span><br><span class="line"><span class="keyword">goto</span> Loop;</span><br></pre></td></tr></table></figure><p>应试者如给出上面的方案， 这说明或者他是一个汇编语言程序员 (这也许是好事) 或者他是一个想进入新领域的 BASIC/FORTRAN 程序员。</p><h1 id="3-数据声明-data-declarations"><a class="markdownIt-Anchor" href="#3-数据声明-data-declarations"></a> 3. 数据声明 (Data declarations)</h1><h2 id="31-用变量-a-给出下面的定义"><a class="markdownIt-Anchor" href="#31-用变量-a-给出下面的定义"></a> 3.1. 用变量 a 给出下面的定义</h2><p>a) 一个整型数(An integer )<br>b) 一个指向整型数的指针(A pointer to an integer )<br>c) 一个指向指针的的指针，它指向的指针是指向一个整型数(A pointer to a pointer to aninteger)<br>d) 一个有 10 个整型数的数组(An array of 10 integers )<br>e) 一个有 10 个指针的数组， 该指针是指向一个整型数的 (An array of 10 pointers to integers )<br>f) 一个指向有 10 个整型数数组的指针(A pointer to an array of 10 integers )<br>g) 一个指向函数的指针，该函数有一个整型参数并返回一个整型数(A pointer to a function that takes an integer as an argument and returns an integer )<br>h) 一个有 10 个指针的数组， 该指针指向一个函数， 该函数有一个整型参数并返回一个整型数(An array of ten pointers to functions that take an integer argument and return an integer )</p><p>答案是：</p><p>a) int a; // An integer<br>b) int *a; // A pointer to an integer<br>c) int **a; // A pointer to a pointer to an integer<br>d) int a[10]; // An array of 10 integers<br>e) int *a[10]; // An array of 10 pointers to integers<br>f) int (*a)[10]; // A pointer to an array of 10 integers<br>g) int (*a)(int); // A pointer to a function a that takes an integer argument and returns an integer<br>h) int (*a[10])(int); // An array of 10 pointers to functions that take an integer argument and return an integer</p><p>人们经常声称这里有几个问题是那种要翻一下书才能回答的问题， 我同意这种说法。 当我写这篇文章时，为了确定语法的正确性，我的确查了一下书。但是当我被面试的时候，我期望被问到这个问题 (或者相近的问题) 。因为在被面试的这段时间里，我确定我知道这个问题的答案。应试者如果不知道所有的答案(或至少大部分答案) ，那么也就没有为这次面试做准备，如果该面试者没有为这次面试做准备，那么他又能为什么做出准备呢？</p><h1 id="4-关键字-static"><a class="markdownIt-Anchor" href="#4-关键字-static"></a> 4. 关键字 Static</h1><h2 id="41-关键字-static-的作用是什么"><a class="markdownIt-Anchor" href="#41-关键字-static-的作用是什么"></a> 4.1. 关键字 static 的作用是什么？</h2><p>这个简单的问题很少有人能回答完全。在 C 语言中，关键字 static 有三个明显的作用：<br>(1) 函数体内 static 变量的作用范围为该函数体， 不同于 auto 变量，该变量的内存只被分<br>配一次，因此其值在下次调用时仍维持上次的值；<br>(2)在模块内的 static 全局变量可以被模块内所用函数访问，但不能被模块外其它函数访<br>问；<br>(3)在模块内的 static 函数只可被这一模块内的其它函数调用，这个函数的使用范围被限<br>制在声明它的模块内；<br>(4)在类中的 static 成员变量属于整个类所拥有，对类的所有对象只有一份拷贝；<br>(5)在类中的 static 成员函数属于整个类所拥有，这个函数不接收 this 指针，因而只能访<br>问类的 static 成员变量。</p><h1 id="5-关键字-const"><a class="markdownIt-Anchor" href="#5-关键字-const"></a> 5. 关键字 Const</h1><h2 id="51-关键字-const-是什么含意"><a class="markdownIt-Anchor" href="#51-关键字-const-是什么含意"></a> 5.1 关键字 const 是什么含意？</h2><p>我只要一听到被面试者说： “ const意味着常数 ”，我就知道我正在和一个业余者打交道。去年 Dan Saks 已经在他的文章里完全概括了 const 的所有用法，因此 ESP(译者： Embedded Systems Programming)的每一位读者应该非常熟悉 const 能做什么和不能做什么 .如果你从没有读到那篇文章，只要能说出 const 意味着 “只读 ”就可以了。尽管这个答案不是完全的答案， 但我接受它作为一个正确的答案。 (如果你想知道更详细的答案，仔细读一下 Saks 的文章吧。)如果应试者能正确回答这个问题，我将问他一个附加的问题：<br>下面的声明都是什么意思？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> *a;</span><br><span class="line"><span class="keyword">int</span> * <span class="keyword">const</span> a;</span><br><span class="line"><span class="keyword">int</span> <span class="keyword">const</span> * a <span class="keyword">const</span>;</span><br></pre></td></tr></table></figure><p>前两个的作用是一样， <code>a</code> 是一个常整型数。第三个意味着 a 是一个指向常整型数的指针(也就是，整型数是不可修改的，但指针可以)。第四个意思 a 是一个指向整型数的常指针(也就是说，指针指向的整型数是可以修改的，但指针是不可修改的)。最后一个意味着 <code>a</code> 是一个指向常整型数的常指针 (也就是说， 指针指向的整型数是不可修改的， 同时指针也是不可修改的) 。 如果应试者能正确回答这些问题， 那么他就给我留下了一个好印象。 顺带提一句，也许你可能会问，即使不用关键字 <code>const</code>，也还是能很容易写出功能正确的程序，那么我为什么还要如此看重关键字 <code>const</code> 呢？我也如下的几下理由：</p><ol><li>关键字 <code>const</code> 的作用是为给读你代码的人传达非常有用的信息，实际上，声明一个参数为常量是为了告诉了用户这个参数的应用目的。如果你曾花很多时间清理其它人留下的垃圾，你就会很快学会感谢这点多余的信息。(当然，懂得用 <code>const</code> 的程序员很少会留下的垃圾让别人来清理的。)</li><li>通过给优化器一些附加的信息，使用关键字 <code>const</code> 也许能产生更紧凑的代码。</li><li>合理地使用关键字 <code>const</code> 可以使编译器很自然地保护那些不希望被改变的参数，防止其被无意的代码修改。简而言之，这样可以减少 <code>bug</code> 的出现。</li></ol><p>(1)欲阻止一个变量被改变，可以使用 <code>const</code> 关键字。在定义该 <code>const</code> 变量时，通常需要对它进行初始化，因为以后就没有机会再去改变它了；<br>(2)对指针来说，可以指定指针本身为 <code>const</code>，也可以指定指针所指的数据为 <code>const</code>，或二者同时指定为 <code>const</code>；<br>(3)在一个函数声明中， <code>const</code> 可以修饰形参 ，表明它是一个输入参数，在函数内部不能改变其值；<br>(4)对于类的成员函数，若指定其为 <code>const</code> 类型，则表明其是一个常函数，不能修改类的成员变量；<br>(5) 对于类的成员函数， 有时候必须指定其返回值为 <code>const</code> 类型， 以使得其返回值不为 “左值”。例如：<br><code>const classA operator*(const classA&amp; a1,const classA&amp; a2);*</code><br><code>operator*</code> 的返回结果必须是一个 <code>const</code> 对象。如果不是，这样的变态代码也不会编译出错：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">classA a, b, c;</span><br><span class="line">(a * b) = c; <span class="comment">// 对 a*b 的结果赋值</span></span><br></pre></td></tr></table></figure><p>​ 操作 <code>(a * b) = c</code> 显然不符合编程者的初衷，也没有任何意义。<br>剖析：惊讶吗？小小的 <code>static</code> 和 <code>const</code> 居然有这么多功能，我们能回答几个？如果只能回答1~2 个，那还真得闭关再好好修炼修炼。这个题可以考查面试者对程序设计知识的掌握程度是初级、 中级还是比较深入， 没有一定的知识广度和深度，不可能对这个问题给出全面的解答。大多数人只能回答出 <code>static</code> 和 <code>const</code><br>关键字的部分功能。</p><h2 id="52-写一个函数返回-123-n-的值假定结果不会超过长整型变量的范围"><a class="markdownIt-Anchor" href="#52-写一个函数返回-123-n-的值假定结果不会超过长整型变量的范围"></a> 5.2 写一个函数返回 <code>1+2+3+ , +n</code> 的值(假定结果不会超过长整型变量的范围)</h2><p>解答：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Sum</span><span class="params">( <span class="keyword">int</span> n )</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> ( (<span class="keyword">long</span>)<span class="number">1</span> + n) * n / <span class="number">2</span>; <span class="comment">//或 return (1l + n) * n / 2;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>剖析：对于这个题，只能说，也许最简单的答案就是最好的答案。下面的解答，或者基于下面的解答思路去优化，不管怎么“折腾” ，其效率也不可能与直接 <code>return ( 1 l + n ) * n / 2</code> 相比！</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">int Sum( int n )</span><br><span class="line">&#123;</span><br><span class="line">	long sum = 0;for( int i=1; i&lt;=n; i++ )</span><br><span class="line">    &#123;</span><br><span class="line">    	sum += i;</span><br><span class="line">    &#125;</span><br><span class="line">	return sum;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>所以程序员们需要敏感地将数学等知识用在程序设计中。</p><h1 id="6-6-关键字-volatile"><a class="markdownIt-Anchor" href="#6-6-关键字-volatile"></a> 6. 6 关键字 Volatile</h1><h2 id="61-关键字-volatile-有什么含意并给出三个不同的例子"><a class="markdownIt-Anchor" href="#61-关键字-volatile-有什么含意并给出三个不同的例子"></a> 6.1 关键字 volatile 有什么含意并给出三个不同的例子。</h2><p>一个定义为 <code>volatile</code> 的变量是说这变量可能会被意想不到地改变，这样，编译器就不会去假<br>设这个变量的值了。 精确地说就是， 优化器在用到这个变量时必须每次都小心地重新读取这<br>个变量的值，而不是使用保存在寄存器里的备份。下面是 <code>volatile</code> 变量的几个例子：<br>1). 并行设备的硬件寄存器（如：状态寄存器）<br>2). 一个中断服务子程序中会访问到的非自动变量 <strong>(Non-automatic variables</strong>)<br>3). 多线程应用中被几个任务共享的变量回答不出这个问题的人是不会被雇佣的。我认为这<br>是区分 C 程序员和嵌入式系统程序员的最基本的问题<br>。嵌入式系统程序员经常同硬件、中断、 <strong>RTOS</strong> 等等打交道，所用这些都要求 <code>volatile</code> 变量。<br>不懂得 <code>volatile</code> 内容将会带来灾难。假设被面试者正确地回答了这是问题（嗯，怀疑这否会<br>是这样），我将稍微深究一下，看一下这家伙<br>是不是直正懂得 <code>volatile</code> 完全的重要性。<br>1). 一个参数既可以是 <code>const</code> 还可以是 <code>volatile</code> 吗？解释为什么。<br>2). 一个指针可以是 <code>volatile</code> 吗？解释为什么。<br>3). 下面的函数有什么错误：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">return *ptr * *ptr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是 <code>volatile</code> 因为它可能被意想不到地改变。它<br>是 <code>const</code> 因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 <code>buffer</code> 的<br>指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 <code>*ptr</code> 指向值的平方，但是，由于<br><code>\*ptr</code> 指向一个 <code>volatile</code> 型参数，编译器将产生类似下面的代码：</p><p>下面是答案：<br>1). 是的。一个例子是只读的状态寄存器。它是 <code>volatile</code> 因为它可能被意想不到地改变。它<br>是 <code>const</code> 因为程序不应该试图去修改它。<br>2). 是的。尽管这并不很常见。一个例子是当一个中服务子程序修该一个指向一个 <code>buffer</code> 的<br>指针时。<br>3). 这段代码的有个恶作剧。这段代码的目的是用来返指针 <code>*ptr</code> 指向值的平方，但是，由于<br><code>*ptr</code> 指向一个<code>volatile</code> 型参数，编译器将产生类似下面的代码：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">int a,b;</span><br><span class="line">a = *ptr;</span><br><span class="line">b = *ptr;</span><br><span class="line">return a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于 <code>*ptr</code> 的值可能被意想不到地该变，因此 <code>a</code> 和 <code>b</code> 可能是不同的。结果，这段代码可能返不<br>是你所期望的平方值！正确的代码如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">long square(volatile int *ptr)</span><br><span class="line">&#123;</span><br><span class="line">int a;</span><br><span class="line">a = *ptr;</span><br><span class="line">return a * a;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="7-位操作-bit-manipulation"><a class="markdownIt-Anchor" href="#7-位操作-bit-manipulation"></a> 7. 位操作（ Bit manipulation）</h1><h2 id="71"><a class="markdownIt-Anchor" href="#71"></a> 7.1</h2><p>嵌入式系统总是要用户对变量或寄存器进行位操作。给定一个整型变量 <code>a</code>，写两段代码，第一个设置 <code>a</code> 的 bit 3，第二个清除 <code>a</code> 的 bit 3。在以上两个操作中，要保持其它位不变。对这个问题有三种基本的反应<br>1). 不知道如何下手。该被面者从没做过任何嵌入式系统的工作。<br>2). 用 bit fields 。 Bit fields 是被扔到 C 语言死角的东西，它保证你的代码在不同编译器之间是不可移植的， 同时也保证了的你的代码是不可重用的。 我最近不幸看到 Infineon 为其较复杂的通信芯片写的驱动程序， 它用到了 bit fields 因此完全对我无用， 因为我的编译器用其它的方式来实现 bit fields 的。从道德讲：永远不要让一个非嵌入式的家伙粘实际硬件的边。<br>3). 用 <code>#defines</code> 和 bit masks 操作。 这是一个有极高可移植性的方法， 是应该被用到的方法。<br>最佳的解决方案如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BIT3 (0x1&lt;&lt;3)</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> a;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">set_bit3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a |= BIT3;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">clear_bit3</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">a &amp;= ~BIT3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>一些人喜欢为设置和清除值而定义一个掩码同时定义一些说明常数， 这也是可以接受的。 我希望看到几个要点：<strong>说明常数</strong>、 <code>|=</code>和&amp;<code>=~</code> 操作。</p><h1 id="8-访问固定的内存位置-accessing-fixed-memory-locations"><a class="markdownIt-Anchor" href="#8-访问固定的内存位置-accessing-fixed-memory-locations"></a> 8. 访问固定的内存位置（ Accessing fixed memory locations ）</h1><h2 id="81"><a class="markdownIt-Anchor" href="#81"></a> 8.1</h2><p>嵌入式系统经常具有要求程序员去访问某特定的内存位置的特点。在某工程中，要求设置一绝对地址为 0x67a9 的整型变量的值为 0xaa66。编译器是一个纯粹的 ANSI 编译器。写代码去完成这一任务。这一问题测试你是否知道为了访问一绝对地址把一个整型数强制转换（ typecast）为一指针是合法的。这一问题的实现方式随着个人风格不同而不同。典型的类似代码如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> *ptr;</span><br><span class="line">ptr = (<span class="keyword">int</span> *)<span class="number">0x67a9</span>;*ptr = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>一个较晦涩的方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><p>一个较晦涩的方法是：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">*(<span class="keyword">int</span> * <span class="keyword">const</span>)(<span class="number">0x67a9</span>) = <span class="number">0xaa55</span>;</span><br></pre></td></tr></table></figure><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><p>即使你的品味更接近第二种方案，但我建议你在面试时使用第一种方案。</p><h1 id="9-中断-interrupts"><a class="markdownIt-Anchor" href="#9-中断-interrupts"></a> 9. 中断（ Interrupts）</h1><h2 id="91"><a class="markdownIt-Anchor" href="#91"></a> 9.1</h2><p>中断是嵌入式系统中重要的组成部分， 这导致了很多编译开发商提供一种扩展 —让标准C 支持中断。具代表事实是，产生了一个新的关键字 <code>interrupt</code> 。下面的代码就使用了<code>interrupt</code> 关键字去定义了一个中断服务子程序 (<strong>ISR</strong>) ，请评论一下这段代码的。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__interrupt <span class="keyword">double</span> <span class="title">compute_area</span> <span class="params">(<span class="keyword">double</span> radius)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">double</span> area = PI * radius * radius;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot; Area = %f&quot;</span>, area);</span><br><span class="line"><span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个函数有太多的错误了，以至让人不知从何说起了：</p><ol><li><strong>ISR</strong> 不能返回一个值。如果你不懂这个，那么你不会被雇用的。</li><li><strong>ISR</strong> 不能传递参数。如果你没有看到这一点，你被雇用的机会等同第一项。</li><li>在许多的处理器 /编译器中，浮点一般都是不可重入的。有些处理器 /编译器需要让额处的寄存器入栈，有些处理器 /编译器就是不允许在 <strong>ISR</strong> 中做浮点运算。此外， <strong>ISR</strong> 应该是短而有效率的，在 <strong>ISR</strong> 中做浮点运算是不明智的。</li><li>与第三点一脉相承， <code>printf()</code> 经常有重入和性能上的问题。如果你丢掉了第三和第四点，我不会太为难你的。不用说，如果你能得到后两点，那么你的被雇用前景越来越光明了。代码例子（ <strong>Code examples</strong>）</li></ol><h2 id="92"><a class="markdownIt-Anchor" href="#92"></a> 9.2</h2><p>下面的代码输出是什么，为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">foo</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> a = <span class="number">6</span>;</span><br><span class="line"><span class="keyword">int</span> b = <span class="number">-20</span>;</span><br><span class="line">(a+b &gt; <span class="number">6</span>) <span class="built_in">puts</span>(<span class="string">&quot;&gt; 6&quot;</span>) : <span class="built_in">puts</span>(<span class="string">&quot;&lt;= 6&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个问题测试你是否懂得 C 语言中的整数自动转换原则，我发现有些开发者懂得极少这些东西。 不管如何， 这无符号整型问题的答案是输出是 “ <code>&gt;6</code>”。 原因是当表达式中存在有符号类型和无符号类型时所有的操作数都自动转换为无符号类型。因此 -20 变成了一个非常大的正整数，所以该表达式计算出的结果大于 6。这一点对于应当频繁用到无符号数据类型的嵌入式系统来说是丰常重要的。如果你答错了这个问题，你也就到了得不到这份工作的边缘。</p><h2 id="93"><a class="markdownIt-Anchor" href="#93"></a> 9.3</h2><p>评价下面的代码片断：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> zero = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> compzero = <span class="number">0xFFFF</span>;</span><br><span class="line"><span class="comment">/*1&#x27;s complement of zero */</span></span><br></pre></td></tr></table></figure><p>对于一个 <code>int</code> 型不是 16 位的处理器为说，上面的代码是不正确的。应编写如下：<br><code>unsigned int compzero = ~0;</code>这一问题真正能揭露出应试者是否懂得处理器字长的重要性。 在我的经验里， 好的嵌入式程序员非常准确地明白硬件的细节和它的局限， 然而 PC 机程序往往把硬件作为一个无法避免的烦恼。 到了这个阶段， 应试者或者完全垂头丧气了或者信心满满志在必得。 如果显然应试者不是很好， 那么这个测试就在这里结束了。 但如果显然应试者做得不错， 那么我就扔出下面的追加问题， 这些问题是比较难的， 我想仅仅非常优秀的应试者能做得不错。 提出这些问题， 我希望更多看到应试者应付问题的方法， 而不是答案。 不管如何， 你就当是这个娱乐吧 …</p><h1 id="10-动态内存分配-dynamic-memory-allocation"><a class="markdownIt-Anchor" href="#10-动态内存分配-dynamic-memory-allocation"></a> 10. 动态内存分配（ Dynamic memory allocation）</h1><h2 id="101"><a class="markdownIt-Anchor" href="#101"></a> 10.1</h2><p>尽管不像非嵌入式计算机那么常见，嵌入式系统还是有从堆（ <strong>heap</strong>）中动态分配内存的过程的。那么嵌入式系统中，动态分配内存可能发生的问题是什么？<br>这里， 我期望应试者能提到内存碎片，碎片收集的问题， 变量的持行时间等等。这个主题已经在 ESP 杂志中被广泛地讨论过了（主要是 P.J. Plauger, 他的解释远远超过我这里能提到的任何解释），所有回过头看一下这些杂志吧！让应试者进入一种虚假的安全感觉后，我拿出这么一个小节目：下面的代码片段的输出是什么，为什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">char</span> *ptr;</span><br><span class="line"><span class="keyword">if</span> ((ptr = (<span class="keyword">char</span> *)<span class="built_in">malloc</span>(<span class="number">0</span>)) == <span class="literal">NULL</span>)</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Got a null pointer&quot;</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">puts</span>(<span class="string">&quot;Got a valid pointer&quot;</span>);</span><br></pre></td></tr></table></figure><p>这是一个有趣的问题。 最近在我的一个同事不经意把 0 值传给了函数 <code>malloc</code>， 得到了一个合法的指针之后，我才想到这个问题。这就是上面的代码，该代码的输出是 “ <code>Gota validpointer</code> ” 。我用这个来开始讨论这样的一问题， 看看被面试者是否想到库例程这样做是正确。得到正确的答案固然重要，但解决问题的方法和你做决定的基本原理更重要些。</p><h1 id="11-数据类型-typedef"><a class="markdownIt-Anchor" href="#11-数据类型-typedef"></a> 11. 数据类型 Typedef</h1><h2 id="111"><a class="markdownIt-Anchor" href="#111"></a> 11.1</h2><p>Typedef 在 C 语言中频繁用以声明一个已经存在的数据类型的同义字。也可以用预处理器做类似的事。例如，思考一下下面的例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">#define dPS struct s *</span><br><span class="line">typedef struct s * tPS;</span><br></pre></td></tr></table></figure><p>以上两种情况的意图都是要定义 <strong>dPS</strong> 和 <strong>tPS</strong> 作为一个指向结构 s 指针。哪种方法更好呢？（如果有的话） 为什么？这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是： <code>typedef</code> 更好。思考下面的例子：</p><p>以上两种情况的意图都是要定义 <strong>dPS</strong> 和 tPS <strong>作为</strong>一个指向结构 <strong>s</strong> 指针。哪种方法更好呢？（如果有的话） 为什么？这是一个非常微妙的问题，任何人答对这个问题（正当的原因）是应当被恭喜的。答案是： typedef 更好。思考下面的例子：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dPS p1,p2;</span><br><span class="line">tPS p3,p4;</span><br></pre></td></tr></table></figure><p>第一个扩展为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">p1</span>, <span class="title">p2</span>;</span></span><br></pre></td></tr></table></figure><p>上面的代码定义 <strong>p1</strong> 为一个指向结构的指， <strong>p2</strong> 为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了 <strong>p3</strong> 和 <strong>p4</strong> 两个指针。</p><p>第一个扩展为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">s</span> * <span class="title">p1</span>, <span class="title">p2</span>;</span></span><br></pre></td></tr></table></figure><p>上面的代码定义 p1 为一个指向结构的指， p2 为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了 p3 和 p4 两个指针。</p><p>上面的代码定义 p1 为一个指向结构的指， p2 为一个实际的结构，这也许不是你想要的。第二个例子正确地定义了 p3 和 p4 两个指针。</p><h1 id="12-晦涩的语法"><a class="markdownIt-Anchor" href="#12-晦涩的语法"></a> 12. 晦涩的语法</h1><h2 id="121"><a class="markdownIt-Anchor" href="#121"></a> 12.1</h2><p>C 语言同意一些令人震惊的结构 ,下面的结构是合法的吗，如果是它做些什么？</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> a = <span class="number">5</span>, b = <span class="number">7</span>, c;</span><br><span class="line">c = a+++b;</span><br></pre></td></tr></table></figure><p>这个问题将做为这个测验的一个愉快的结尾。 不管你相不相信， 上面的例子是完全合乎语法的。 问题是编译器如何处理它？水平不高的编译作者实际上会争论这个问题， 根据最处理原则，编译器应当能处理尽可能所有合法的用法。因此，上面的代码被处理成：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">c = a++ + b;</span><br></pre></td></tr></table></figure><p>因此 , 这段代码持行后 <code>a = 6, b = 7, c = 12</code>。如果你知道答案，或猜出正确答案，做得好。如果你不知道答案，我也不把这个当作问题。我发现这个问题的最大好处是 :这是一个关于代码编写风格，代码的可读性，代码的可修改性的好的话题</p></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">文章作者:</span> <span class="post-copyright-info"><a href="mailto:undefined" rel="external nofollow noreferrer">Malloy Yuan</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">文章链接:</span> <span class="post-copyright-info"><a href="https://elec-creator.com/posts/a8c481ea.html">https://elec-creator.com/posts/a8c481ea.html</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">版权声明:</span> <span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" rel="external nofollow noreferrer" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://elec-creator.com" target="_blank">Malloy Yuan 的个人博客</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/mcu/">MCU</a><a class="post-meta__tags" href="/tags/summarization/">知识梳理</a></div><div class="post_share"><div class="social-share" data-image="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/summarization-cover.jpg" data-sites="facebook,twitter,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js/dist/css/share.min.css" media="print" onload='this.media="all"'><script src="https://cdn.jsdelivr.net/npm/social-share.js/dist/js/social-share.min.js" defer></script></div></div><div class="post-reward"><div class="reward-button"><i class="fas fa-qrcode"></i> 打赏</div><div class="reward-main"><ul class="reward-all"><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/wechat.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/wechat.jpg" alt="Wechat"></a><div class="post-qr-code-desc">Wechat</div></li><li class="reward-item"><a href="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/alipay.jpg" rel="external nofollow noreferrer" target="_blank"><img class="post-qr-code-img" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/donate/alipay.jpg" alt="Alipay"></a><div class="post-qr-code-desc">Alipay</div></li></ul></div></div><div class="ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-format="fluid" data-ad-layout-key="-fb+5w+4e-db+86" data-ad-client="ca-pub-6017375467561303" data-ad-slot="3926580292"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div><nav class="pagination-post" id="pagination"><div class="next-post pull-full"><a href="/posts/3a13bccb.html"><img class="next-cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='onerror=null,src="/img/private/post_img-load-404-1.jpg"' alt="cover of next post"><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">C++ array模板类使用</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/posts/47567e3c.html" title="MCU"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/mcu-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-18</div><div class="title">MCU</div></div></a></div><div><a href="/posts/dcf744a9.html" title="Nuvoton"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/nuvoton-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-18</div><div class="title">Nuvoton</div></div></a></div><div><a href="/posts/b900f0d0.html" title="STM32"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/stm32-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-18</div><div class="title">STM32</div></div></a></div><div><a href="/posts/fe9c70ea.html" title="STM8"><img class="cover" src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/stm8-cover.jpg" alt="cover"><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2020-03-18</div><div class="title">STM8</div></div></a></div></div></div><hr><div id="post-comment"><div class="comment-head"><div class="comment-headline"><i class="fas fa-comments fa-fw"></i> <span>评论</span></div></div><div class="comment-wrap"><div><div id="twikoo-wrap"></div></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/portrait/portrait-3.jpg" onerror='this.onerror=null,this.src="/img/private/site_img-load-404-1.gif"' alt="avatar"></div><div class="author-info__name">Malloy Yuan</div><div class="author-info__description">__在总结中前进,在反思中提升__个人学习/经历/感悟/项目经验/生活 点滴的记录与分享</div></div><div class="card-info-data is-center"><div class="card-info-data-item"><a href="/archives/"><div class="headline">文章</div><div class="length-num">54</div></a></div><div class="card-info-data-item"><a href="/tags/"><div class="headline">标签</div><div class="length-num">34</div></a></div><div class="card-info-data-item"><a href="/categories/"><div class="headline">分类</div><div class="length-num">37</div></a></div></div><div class="card-info-social-icons is-center"><a class="social-icon" href="http://wpa.qq.com/msgrd?v=3&amp;uin=980298390&amp;site=qq&amp;menu=yes" rel="external nofollow noreferrer" target="_blank" title="QQ"><i class="fab fa-qq"></i></a><a class="social-icon" href="https://weibo.com/u/6622047516" rel="external nofollow noreferrer" target="_blank" title="Weibo"><i class="fab fa-weibo"></i></a><a class="social-icon" href="https://www.zhihu.com/people/yyyml" rel="external nofollow noreferrer" target="_blank" title="Zhihu"><i class="fab fa-zhihu"></i></a><a class="social-icon" href="https://music.163.com/#/user/home?id=19122520" rel="external nofollow noreferrer" target="_blank" title="Neteasy music"><i class="iconfont icon-wangyiyunyinyuemusic1193417easyiconnet"></i></a><a class="social-icon" href="https://space.bilibili.com/432676565" rel="external nofollow noreferrer" target="_blank" title="bilibili"><i class="iconfont icon-bilibili-fill"></i></a><a class="social-icon" href="mailto:yuanml0807@foxmail.com" rel="external nofollow noreferrer" target="_blank" title="Email"><i class="fas fa-envelope"></i></a><a class="social-icon" href="/atom.xml" target="_blank" title="RSS"><i class="fas fa-rss"></i></a></div></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn card-announcement-animation"></i><span>公告</span></div><div class="announcement_content">不定时更的个人博客,喜欢记得收藏,欢迎沟通交流</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#1-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8-preprocessor"><span class="toc-text">1. 预处理器 (Preprocessor)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#11-%E7%94%A8%E9%A2%84%E5%A4%84%E7%90%86%E6%8C%87%E4%BB%A4define-%E5%A3%B0%E6%98%8E%E4%B8%80%E4%B8%AA%E5%B8%B8%E6%95%B0%E7%94%A8%E4%BB%A5%E8%A1%A8%E6%98%8E1%E5%B9%B4%E4%B8%AD%E6%9C%89%E5%A4%9A%E5%B0%91%E7%A7%92%E5%BF%BD%E7%95%A5%E9%97%B0%E5%B9%B4%E9%97%AE%E9%A2%98"><span class="toc-text">1.1. 用预处理指令#define 声明一个常数，用以表明1年中有多少秒(忽略闰年问题)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#12-%E5%86%99%E4%B8%80%E4%B8%AA%E6%A0%87%E5%87%86%E5%AE%8Fmin-%E8%BF%99%E4%B8%AA%E5%AE%8F%E8%BE%93%E5%85%A5%E4%B8%A4%E4%B8%AA%E5%8F%82%E6%95%B0%E5%B9%B6%E8%BF%94%E5%9B%9E%E8%BE%83%E5%B0%8F%E7%9A%84%E4%B8%80%E4%B8%AA"><span class="toc-text">1.2. 写一个&quot;标准&quot;宏MIN ，这个宏输入两个参数并返回较小的一个。</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#13-%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%E6%A0%87%E8%AF%86error%E7%9A%84%E7%9B%AE%E7%9A%84%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">1.3. 预处理器标识#error的目的是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#2-%E6%AD%BB%E5%BE%AA%E7%8E%AF-infinite-loops"><span class="toc-text">2. 死循环 (Infinite loops)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#21-%E5%B5%8C%E5%85%A5%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%BB%8F%E5%B8%B8%E8%A6%81%E7%94%A8%E5%88%B0%E6%97%A0%E9%99%90%E5%BE%AA%E7%8E%AF%E4%BD%A0%E6%80%8E%E4%B9%88%E6%A0%B7%E7%94%A8-c-%E7%BC%96%E5%86%99%E6%AD%BB%E5%BE%AA%E7%8E%AF%E5%91%A2"><span class="toc-text">2.1. 嵌入式系统中经常要用到无限循环，你怎么样用 C 编写死循环呢？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#3-%E6%95%B0%E6%8D%AE%E5%A3%B0%E6%98%8E-data-declarations"><span class="toc-text">3. 数据声明 (Data declarations)</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#31-%E7%94%A8%E5%8F%98%E9%87%8F-a-%E7%BB%99%E5%87%BA%E4%B8%8B%E9%9D%A2%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="toc-text">3.1. 用变量 a 给出下面的定义</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#4-%E5%85%B3%E9%94%AE%E5%AD%97-static"><span class="toc-text">4. 关键字 Static</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#41-%E5%85%B3%E9%94%AE%E5%AD%97-static-%E7%9A%84%E4%BD%9C%E7%94%A8%E6%98%AF%E4%BB%80%E4%B9%88"><span class="toc-text">4.1. 关键字 static 的作用是什么？</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#5-%E5%85%B3%E9%94%AE%E5%AD%97-const"><span class="toc-text">5. 关键字 Const</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#51-%E5%85%B3%E9%94%AE%E5%AD%97-const-%E6%98%AF%E4%BB%80%E4%B9%88%E5%90%AB%E6%84%8F"><span class="toc-text">5.1 关键字 const 是什么含意？</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#52-%E5%86%99%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E-123-n-%E7%9A%84%E5%80%BC%E5%81%87%E5%AE%9A%E7%BB%93%E6%9E%9C%E4%B8%8D%E4%BC%9A%E8%B6%85%E8%BF%87%E9%95%BF%E6%95%B4%E5%9E%8B%E5%8F%98%E9%87%8F%E7%9A%84%E8%8C%83%E5%9B%B4"><span class="toc-text">5.2 写一个函数返回 1+2+3+ , +n 的值(假定结果不会超过长整型变量的范围)</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#6-6-%E5%85%B3%E9%94%AE%E5%AD%97-volatile"><span class="toc-text">6. 6 关键字 Volatile</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#61-%E5%85%B3%E9%94%AE%E5%AD%97-volatile-%E6%9C%89%E4%BB%80%E4%B9%88%E5%90%AB%E6%84%8F%E5%B9%B6%E7%BB%99%E5%87%BA%E4%B8%89%E4%B8%AA%E4%B8%8D%E5%90%8C%E7%9A%84%E4%BE%8B%E5%AD%90"><span class="toc-text">6.1 关键字 volatile 有什么含意并给出三个不同的例子。</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#7-%E4%BD%8D%E6%93%8D%E4%BD%9C-bit-manipulation"><span class="toc-text">7. 位操作（ Bit manipulation）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#71"><span class="toc-text">7.1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#8-%E8%AE%BF%E9%97%AE%E5%9B%BA%E5%AE%9A%E7%9A%84%E5%86%85%E5%AD%98%E4%BD%8D%E7%BD%AE-accessing-fixed-memory-locations"><span class="toc-text">8. 访问固定的内存位置（ Accessing fixed memory locations ）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#81"><span class="toc-text">8.1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-%E4%B8%AD%E6%96%AD-interrupts"><span class="toc-text">9. 中断（ Interrupts）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#91"><span class="toc-text">9.1</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#92"><span class="toc-text">9.2</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#93"><span class="toc-text">9.3</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#10-%E5%8A%A8%E6%80%81%E5%86%85%E5%AD%98%E5%88%86%E9%85%8D-dynamic-memory-allocation"><span class="toc-text">10. 动态内存分配（ Dynamic memory allocation）</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#101"><span class="toc-text">10.1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#11-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B-typedef"><span class="toc-text">11. 数据类型 Typedef</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#111"><span class="toc-text">11.1</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#12-%E6%99%A6%E6%B6%A9%E7%9A%84%E8%AF%AD%E6%B3%95"><span class="toc-text">12. 晦涩的语法</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#121"><span class="toc-text">12.1</span></a></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item"><a class="thumbnail" href="/posts/a8c481ea.html" title="总结基础知识点面(一) 单片机篇"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/summarization-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="总结基础知识点面(一) 单片机篇"></a><div class="content"><a class="title" href="/posts/a8c481ea.html" title="总结基础知识点面(一) 单片机篇">总结基础知识点面(一) 单片机篇</a><time datetime="2020-08-08T16:55:00.000Z" title="发表于 2020-08-09 00:55:00">2020-08-09</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/3a13bccb.html" title="C++ array模板类使用"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ array模板类使用"></a><div class="content"><a class="title" href="/posts/3a13bccb.html" title="C++ array模板类使用">C++ array模板类使用</a><time datetime="2020-07-24T14:52:40.000Z" title="发表于 2020-07-24 22:52:40">2020-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/925153f2.html" title="C++ 代码换行的问题"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ 代码换行的问题"></a><div class="content"><a class="title" href="/posts/925153f2.html" title="C++ 代码换行的问题">C++ 代码换行的问题</a><time datetime="2020-07-24T14:24:40.000Z" title="发表于 2020-07-24 22:24:40">2020-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/dd9d548b.html" title="C++ 对数组进行复制"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ 对数组进行复制"></a><div class="content"><a class="title" href="/posts/dd9d548b.html" title="C++ 对数组进行复制">C++ 对数组进行复制</a><time datetime="2020-07-24T14:20:40.000Z" title="发表于 2020-07-24 22:20:40">2020-07-24</time></div></div><div class="aside-list-item"><a class="thumbnail" href="/posts/4858c62f.html" title="C++ vector的用法"><img src="/img/private/loading-4.gif" data-lazy-src="https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/cover/post-cover/c++-cover.jpg" onerror='this.onerror=null,this.src="/img/private/post_img-load-404-1.jpg"' alt="C++ vector的用法"></a><div class="content"><a class="title" href="/posts/4858c62f.html" title="C++ vector的用法">C++ vector的用法</a><time datetime="2020-07-24T14:12:40.000Z" title="发表于 2020-07-24 22:12:40">2020-07-24</time></div></div></div></div><div class="card-widget ads-wrap"><ins class="adsbygoogle" style="display:block" data-ad-client="ca-pub-6017375467561303" data-ad-slot="4346183088" data-ad-format="auto" data-full-width-responsive="true"></ins><script>(adsbygoogle=window.adsbygoogle||[]).push({})</script></div></div></div></main><footer id="footer" style="background-image:url(https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/image/top/post-top/summarization-top.jpg)"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2022<i style="color:#ff6a6a" class="fa fa-heartbeat"></i>Malloy Yuan</div><div class="footer_custom_text"><a target="_blank" rel="noopener external nofollow noreferrer" href="http://www.beian.miit.gov.cn"><img class="icp-icon" src="/img/private/loading-4.gif" data-lazy-src="/img/private/icp.png"><span>湘ICP备20005957号</span></a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="translateLink" type="button" title="简繁转换">繁</button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside_config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><a id="to_comment" href="#post-comment" title="直达评论"><i class="fas fa-comments"></i></a><button id="go-up" type="button" title="回到顶部"><i class="fas fa-arrow-up"></i></button></div></div><div id="local-search"><div class="search-dialog"><nav class="search-nav"><span class="search-dialog-title">本地搜索</span><span id="loading-status"></span><button class="search-close-button"><i class="fas fa-times"></i></button></nav><div class="is-center" id="loading-database"><i class="fas fa-spinner fa-pulse"></i> <span>数据库加载中</span></div><div class="search-wrap"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="搜索文章" type="text"></div></div><hr><div id="local-search-results"></div></div></div><div id="search-mask"></div></div><div><script src="/js/utils.js"></script><script src="/js/main.js"></script><script src="/js/tw_cn.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui/dist/fancybox.umd.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page/instantpage.min.js" type="module"></script><script src="https://cdn.jsdelivr.net/npm/vanilla-lazyload/dist/lazyload.iife.min.js"></script><script>function panguFn(){"object"==typeof pangu?pangu.autoSpacingPage():getScript("https://cdn.jsdelivr.net/npm/pangu/dist/browser/pangu.min.js").then(()=>{pangu.autoSpacingPage()})}function panguInit(){panguFn()}document.addEventListener("DOMContentLoaded",panguInit)</script><script src="/js/search/local-search.js"></script><div class="js-pjax"><script>(()=>{const e=document.querySelectorAll("#article-container .mermaid-wrap");if(e.length){window.runMermaid=()=>{window.loadMermaid=!0;const t="dark"===document.documentElement.getAttribute("data-theme")?"dark":"default";Array.from(e).forEach((e,n)=>{const d=e.firstElementChild,r="mermaid-"+n,i="%%{init:{ 'theme':'"+t+"'}}%%\n"+d.textContent;mermaid.mermaidAPI.render(r,i,e=>{d.insertAdjacentHTML("afterend",e)})})};const t=()=>{window.loadMermaid?runMermaid():getScript("https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js").then(runMermaid)};window.pjax?t():document.addEventListener("DOMContentLoaded",t)}})()</script><script>(()=>{const t=()=>{twikoo.init(Object.assign({el:"#twikoo-wrap",envId:"https://twikoo-five-olive.vercel.app/",region:"",onCommentLoaded:function(){btf.loadLightbox(document.querySelectorAll("#twikoo .tk-content img:not(.vemoji)"))}},null)),GLOBAL_CONFIG_SITE.isPost&&twikoo.getCommentsCount({envId:"https://twikoo-five-olive.vercel.app/",region:"",urls:[window.location.pathname],includeReply:!1}).then((function(t){document.getElementById("twikoo-count").innerText=t[0].count})).catch((function(t){console.error(t)}))},o=()=>{"object"!=typeof twikoo?getScript("https://cdn.jsdelivr.net/npm/twikoo@1.4.15/dist/twikoo.all.min.js").then(t):setTimeout(t,0)};o()})()</script></div><div class="app-refresh" id="app-refresh"><div class="app-refresh-wrap"><label>✨ 网站已更新最新版本 👉</label> <a href="javascript:void(0)" rel="external nofollow noreferrer" onclick="location.reload()">点击刷新</a></div></div><script>function showNotification(){if(GLOBAL_CONFIG.Snackbar){var t="light"===document.documentElement.getAttribute("data-theme")?GLOBAL_CONFIG.Snackbar.bgLight:GLOBAL_CONFIG.Snackbar.bgDark,e=GLOBAL_CONFIG.Snackbar.position;Snackbar.show({text:"已更新最新版本",backgroundColor:t,duration:5e5,pos:e,actionText:"點擊刷新",actionTextColor:"#fff",onActionClick:function(t){location.reload()}})}else{var o=`top: 0; background: ${"light"===document.documentElement.getAttribute("data-theme")?"#49b1f5":"#1f1f1f"};`;document.getElementById("app-refresh").style.cssText=o}}"serviceWorker"in navigator&&(navigator.serviceWorker.controller&&navigator.serviceWorker.addEventListener("controllerchange",(function(){showNotification()})),window.addEventListener("load",(function(){navigator.serviceWorker.register("/sw.js")})))</script><script defer id="fluttering_ribbon" mobile="false" src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/canvas-fluttering-ribbon.min.js"></script><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1/dist/activate-power-mode.min.js"></script><script>POWERMODE.colorful=!0,POWERMODE.shake=!1,POWERMODE.mobile=!1,document.body.addEventListener("input",POWERMODE)</script><script src="//code.tidio.co/xmigmag8yz8wxyxf4rx4tsq9ejzzdqki.js" async></script><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div><script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({pluginRootPath:"live2dw/",pluginJsPath:"lib/",pluginModelPath:"assets/",tagMode:!1,log:!1,model:{jsonPath:"https://cdn.jsdelivr.net/gh/MCUheart/Hexo-blog-data@1.0.2/live2d-widget-model/haru/01/assets/haru01.model.json"},display:{superSample:2,width:150,height:490,position:"left",hOffset:270,vOffset:-50},mobile:{show:!1,scale:.5},react:{opacityDefault:.7,opacityOnHover:.2}})</script></body></html>